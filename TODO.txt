TODO
This list contains a number of things which need fixing and/or
improvement.  There's also a small explanatory
note with ideas.  More info is often contained in FIXMEs
at appropriate places in the code.


************ PRESSING ISSUES ***********

**handle smoothing 
    There is a question of whether, if, and how much to allow
    smoothing of the data.  If we smooth, we're not technically
    interpolating, but users often want to smooth data.  

    In fitpack_wrapper the smoothing parameter is s.  It now defaults
    to 0.0 (exact interpolation).  Zero smoothing and moderate (s ~ 1)
    are fast, but small non-zero s makes the algorithm VERY slow.

    Currently the user does see s in Interpolate1d; no smoothing 
    is available.  The Spline class, however, has it available (default = 0.0).


**pick best spline
    Under-the-hood machinery currently comes from _interpolate.cpp
    (used in enthought.interpolate) and FITPACK (Fortran, used in 
    scipy.interpolate).  This isn't necessarily the best.  Other code
    is used in scipy.ndimage and scipy.signal.  There is surely other
    code out there too.  Figure out what is best and incorporate it.

    Signal code is slower than FITPACK, and NDImage requires a
    regular grid.  I'm inclined to stay with FITPACK, except for the
    slow performance when x is small (we could add a hack to not
    let s be tiny > 0).


**clean up fitpack_wrapper.py
    Currently it is all hacked together from scipy.interpolate.
    There is unused functionality, commented-out functionality,
    and other undesirables.  Once it has been established what
    we will include, and what should be accessible to the user, 
    that stuff needs to be cleaned up, and the
    rest needs to be either removed or set aside.
    

**better handling of variable types
    Currently everything is cast to a float64 if it is not already
    a float32.  Is this the best way to do it?

    There's also the question of Y being 2-dimensional and/or
    incorporating strings for record arrays.  My instinct is to
    have Interpolate1d only interpolate functions that are from
    R1 -> R1.  That's how it is currently designed.  Other stuff
    can be made as wrappers around Interpolate1d.
    
    See also "allow y to be 2-dimensional?" below
    
    

*********** DOCUENTATION-TYPE AND NON-URGENT TASKS *******

**improve regression tests
    desired for fitpack_wrapper and _interpolate_wrapper
    as well as Interpolate1d.  What I have now is
    really basic.


**improve unit tests
    interpolate1d.py has its own unit tests, which also call
    the unit tests of fitpack_wrapper and _interpolate_wrapper.
    But they could surely be made better.


**comment all files
    There are comments there already, but they should be
    made better.  Plus, features are changing, which requires
    updating the documentation.


**doc strings for interpolate1d and its members
    There's docstrings there already, but they should be
    made better.  In particular, it must be ensured that
    they are of the proper format and include examples.

    The doc strings for __init__.py, interpolate1d.py,
    Interpolate1d, and interp1d are virtually identical
    and very long; perhaps a master string can be stored
    somewhere that they all reference.  This would make
    updates of documentation easier.


**figure out NumPy stuff with vectorize.
    In function Interpolate1d.__call__
    It would be nice to remove the hack I used.
    I believe vectorize is supposed to handle arrays of
    length 0, but it's not working on my computer.
    
    
    
********* LONGER TERM ************

**update for 2D and ND
    This will probably take the form of two additional
    classes both based on interpolate1d.  Thus it probably
    shouldn't be done until interpolate1d is more settled.
    
    There is an interesting problem here.  Most of the extensions
    I have assume a regular grid.  First off, this is often not general.
    Secondly, if I DO use a regular grid, how do I deal with bad
    data?  The best way is probably a pre-processing where you
    interpolate values for the bad points (linear would be a nice simple
    way to do it at first, just to get it working)
    
    We should probably use something other than FITPACK for this.
    First off it's at most 2D.  But much worse, it doesn't evaluate at
    a set of points; it evaluates over a grid, which requires inputs
    being in sorted order (both in x and y coordinates).  This makes
    input inconvenient and the code runs a lot slower than ndimage.
    ND image has 2 main downsides :1) it requires x and y be uniform
    spacing (since its really interpolating entries of an array, rather
    than values of a function on Rn), and 2) the C code is TERRIBLY
    documented/commented.  But that can be fixed.
    
    So we may have two separate classes: Interpolate1d which is
    based on FITPACK (or something else, depending on what
    happens with the smoothing parameter), and InterpolateNd
    which is based on ndimage.

**high-level road map
    when the module is more established, there should be a page on
    the wiki which describes the big-picture of the module; what
    the capabilities are and which should be added, large-scale
    architecture of the module, etc.

    It might note which underlying C/Fortran modules can or should
    be modified or merged.  It would be great if either 1) there were
    only 1 extension module, or 2) the modules showed natural
    differentiation of functionality (one for splines, one for simple
    operations, etc), rather than being a holdover of where they
    were stolen from.


**allow y to be 2-dimensional?
    It is not decided whether this feature should be supported, but
    I don't think it should; I think there should be another class with
    that functionality which wraps Interpolate1d.  The main reasons
    are:
    1) interpolation should probably be along columns, so the user
    can enter data as enter the data as y=array([obs1, obs2, ...]).  But
    the interpolate_wrapper and fitpack_wrapper interpolate along
    rows; this means there would be messy transposes in the code.
    2) FITPACK doesn't support 2D y arrays, which means we would
    have to store the y columns separately
    3) If we remove bad data, bearing in mind (2), we would also
    have to store copies of x, since the bad data in the y cols aren't
    at the same locations, meaning that different data points should be
    deleted for each column.
