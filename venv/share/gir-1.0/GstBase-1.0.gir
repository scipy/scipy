<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GLib" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gst" version="1.0"/>
  <package name="gstreamer-base-1.0"/>
  <c:include name="gst/base/base.h"/>
  <namespace name="GstBase"
             version="1.0"
             shared-library="libgstbase-1.0.so.0"
             c:identifier-prefixes="Gst"
             c:symbol-prefixes="gst">
    <function-macro name="ADAPTER"
                    c:identifier="GST_ADAPTER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstadapter.h" line="31"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ADAPTER_CLASS"
                    c:identifier="GST_ADAPTER_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstadapter.h" line="33"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="ADAPTER_GET_CLASS"
                    c:identifier="GST_ADAPTER_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstadapter.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR"
                    c:identifier="GST_AGGREGATOR"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="132"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_CAST"
                    c:identifier="GST_AGGREGATOR_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="133"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_CLASS"
                    c:identifier="GST_AGGREGATOR_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="134"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_GET_CLASS"
                    c:identifier="GST_AGGREGATOR_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="135"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_PAD"
                    c:identifier="GST_AGGREGATOR_PAD"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="42"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_PAD_CAST"
                    c:identifier="GST_AGGREGATOR_PAD_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="43"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_PAD_CLASS"
                    c:identifier="GST_AGGREGATOR_PAD_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="44"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_PAD_GET_CLASS"
                    c:identifier="GST_AGGREGATOR_PAD_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="45"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="AGGREGATOR_SRC_PAD"
                    c:identifier="GST_AGGREGATOR_SRC_PAD"
                    version="1.6"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstaggregator.h"
           line="364">Convenience macro to access the source pad of #GstAggregator</doc>
      <source-position filename="libs/gst/base/gstaggregator.h" line="372"/>
      <parameters>
        <parameter name="agg">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.h"
               line="366">a #GstAggregator</doc>
        </parameter>
      </parameters>
    </function-macro>
    <class name="Adapter"
           c:symbol-prefix="adapter"
           c:type="GstAdapter"
           parent="GObject.Object"
           glib:type-name="GstAdapter"
           glib:get-type="gst_adapter_get_type"
           glib:type-struct="AdapterClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstadapter.c"
           line="21">This class is for elements that receive buffers in an undesired size.
While for example raw video contains one image per buffer, the same is not
true for a lot of other formats, especially those that come directly from
a file. So if you have undefined buffer sizes and require a specific size,
this object is for you.

An adapter is created with gst_adapter_new(). It can be freed again with
g_object_unref().

The theory of operation is like this: All buffers received are put
into the adapter using gst_adapter_push() and the data is then read back
in chunks of the desired size using gst_adapter_map()/gst_adapter_unmap()
and/or gst_adapter_copy(). After the data has been processed, it is freed
using gst_adapter_unmap().

Other methods such as gst_adapter_take() and gst_adapter_take_buffer()
combine gst_adapter_map() and gst_adapter_unmap() in one method and are
potentially more convenient for some use cases.

For example, a sink pad's chain function that needs to pass data to a library
in 512-byte chunks could be implemented like this:
|[&lt;!-- language="C" --&gt;
static GstFlowReturn
sink_pad_chain (GstPad *pad, GstObject *parent, GstBuffer *buffer)
{
  MyElement *this;
  GstAdapter *adapter;
  GstFlowReturn ret = GST_FLOW_OK;

  this = MY_ELEMENT (parent);

  adapter = this-&gt;adapter;

  // put buffer into adapter
  gst_adapter_push (adapter, buffer);

  // while we can read out 512 bytes, process them
  while (gst_adapter_available (adapter) &gt;= 512 &amp;&amp; ret == GST_FLOW_OK) {
    const guint8 *data = gst_adapter_map (adapter, 512);
    // use flowreturn as an error value
    ret = my_library_foo (data);
    gst_adapter_unmap (adapter);
    gst_adapter_flush (adapter, 512);
  }
  return ret;
}
]|

For another example, a simple element inside GStreamer that uses #GstAdapter
is the libvisual element.

An element using #GstAdapter in its sink pad chain function should ensure that
when the FLUSH_STOP event is received, that any queued data is cleared using
gst_adapter_clear(). Data should also be cleared or processed on EOS and
when changing state from %GST_STATE_PAUSED to %GST_STATE_READY.

Also check the GST_BUFFER_FLAG_DISCONT flag on the buffer. Some elements might
need to clear the adapter after a discontinuity.

The adapter will keep track of the timestamps of the buffers
that were pushed. The last seen timestamp before the current position
can be queried with gst_adapter_prev_pts(). This function can
optionally return the number of bytes between the start of the buffer that
carried the timestamp and the current adapter position. The distance is
useful when dealing with, for example, raw audio samples because it allows
you to calculate the timestamp of the current adapter position by using the
last seen timestamp and the amount of bytes since.  Additionally, the
gst_adapter_prev_pts_at_offset() can be used to determine the last
seen timestamp at a particular offset in the adapter.

The adapter will also keep track of the offset of the buffers
(#GST_BUFFER_OFFSET) that were pushed. The last seen offset before the
current position can be queried with gst_adapter_prev_offset(). This function
can optionally return the number of bytes between the start of the buffer
that carried the offset and the current adapter position.

Additionally the adapter also keeps track of the PTS, DTS and buffer offset
at the last discontinuity, which can be retrieved with
gst_adapter_pts_at_discont(), gst_adapter_dts_at_discont() and
gst_adapter_offset_at_discont(). The number of bytes that were consumed
since then can be queried with gst_adapter_distance_from_discont().

A last thing to note is that while #GstAdapter is pretty optimized,
merging buffers still might be an operation that requires a `malloc()` and
`memcpy()` operation, and these operations are not the fastest. Because of
this, some functions like gst_adapter_available_fast() are provided to help
speed up such cases should you want to. To avoid repeated memory allocations,
gst_adapter_copy() can be used to copy data into a (statically allocated)
user provided buffer.

#GstAdapter is not MT safe. All operations on an adapter must be serialized by
the caller. This is not normally a problem, however, as the normal use case
of #GstAdapter is inside one pad's chain function, in which case access is
serialized via the pad's STREAM_LOCK.

Note that gst_adapter_push() takes ownership of the buffer passed. Use
gst_buffer_ref() before pushing it into the adapter if you still want to
access the buffer later. The adapter will never modify the data in the
buffer pushed in it.</doc>
      <source-position filename="libs/gst/base/gstadapter.h" line="49"/>
      <constructor name="new" c:identifier="gst_adapter_new">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="237">Creates a new #GstAdapter. Free with g_object_unref().</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="55"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="242">a new #GstAdapter</doc>
          <type name="Adapter" c:type="GstAdapter*"/>
        </return-value>
      </constructor>
      <method name="available" c:identifier="gst_adapter_available">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1309">Gets the maximum amount of bytes available, that is it returns the maximum
value that can be supplied to gst_adapter_map() without that function
returning %NULL.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="106"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1317">number of bytes available in @adapter</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1311">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="available_fast" c:identifier="gst_adapter_available_fast">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1327">Gets the maximum number of bytes that are immediately available without
requiring any expensive operations (like copying the data into a
temporary buffer).</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="109"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1335">number of bytes that are available in @adapter without expensive
operations</doc>
          <type name="gsize" c:type="gsize"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1329">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clear" c:identifier="gst_adapter_clear">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="250">Removes all buffers from @adapter.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="252">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="copy"
              c:identifier="gst_adapter_copy"
              shadowed-by="copy_bytes"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="578">Copies @size bytes of data starting at @offset out of the buffers
contained in #GstAdapter into an array @dest provided by the caller.

The array @dest should be large enough to contain @size bytes.
The user should check that the adapter has (@offset + @size) bytes
available before calling this function.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="580">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="dest"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="581">
    the memory to copy into</doc>
            <array length="2" zero-terminated="0" c:type="gpointer">
              <type name="guint8"/>
            </array>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="583">the bytes offset in the adapter to start from</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="584">the number of bytes to copy</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="copy_bytes"
              c:identifier="gst_adapter_copy_bytes"
              shadows="copy"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="603">Similar to gst_adapter_copy, but more suitable for language bindings. @size
bytes of data starting at @offset will be copied out of the buffers contained
in @adapter and into a new #GBytes structure which is returned. Depending on
the value of the @size argument an empty #GBytes structure may be returned.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="73"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="614">A new #GBytes structure containing the copied data.</doc>
          <type name="GLib.Bytes" c:type="GBytes*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="605">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="606">the bytes offset in the adapter to start from</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="607">the number of bytes to copy</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="distance_from_discont"
              c:identifier="gst_adapter_distance_from_discont"
              version="1.10">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1368">Get the distance in bytes since the last buffer with the
%GST_BUFFER_FLAG_DISCONT flag.

The distance will be reset to 0 for all buffers with
%GST_BUFFER_FLAG_DISCONT on them, and then calculated for all other
following buffers based on their size.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="136"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1381">The offset. Can be %GST_BUFFER_OFFSET_NONE.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1370">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="dts_at_discont"
              c:identifier="gst_adapter_dts_at_discont"
              version="1.10">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1427">Get the DTS that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
flag, or GST_CLOCK_TIME_NONE.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="130"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1436">The DTS at the last discont or GST_CLOCK_TIME_NONE.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1429">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_adapter_flush">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="687">Flushes the first @flush bytes in the @adapter. The caller must ensure that
at least this many bytes are available.

See also: gst_adapter_map(), gst_adapter_unmap()</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="76"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="689">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="flush" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="690">the number of bytes to flush</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer"
              c:identifier="gst_adapter_get_buffer"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="943">Returns a #GstBuffer containing the first @nbytes of the @adapter, but
does not flush them from the adapter. See gst_adapter_take_buffer()
for details.

Caller owns a reference to the returned buffer. gst_buffer_unref() after
usage.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="94"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="957">a #GstBuffer containing the first
    @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
    gst_buffer_unref() when no longer needed.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="945">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="946">the number of bytes to get</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_fast"
              c:identifier="gst_adapter_get_buffer_fast"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="789">Returns a #GstBuffer containing the first @nbytes of the @adapter, but
does not flush them from the adapter. See gst_adapter_take_buffer_fast()
for details.

Caller owns a reference to the returned buffer. gst_buffer_unref() after
usage.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="100"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="803">a #GstBuffer containing the first
    @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
    gst_buffer_unref() when no longer needed.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="791">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="792">the number of bytes to get</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_list"
              c:identifier="gst_adapter_get_buffer_list"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1240">Returns a #GstBufferList of buffers containing the first @nbytes bytes of
the @adapter but does not flush them from the adapter. See
gst_adapter_take_buffer_list() for details.

Caller owns the returned list. Call gst_buffer_list_unref() to free
the list after usage.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="103"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1252">a #GstBufferList of buffers containing
    the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
    available</doc>
          <type name="Gst.BufferList" c:type="GstBufferList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1242">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1243">the number of bytes to get</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_list"
              c:identifier="gst_adapter_get_list"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1128">Returns a #GList of buffers containing the first @nbytes bytes of the
@adapter, but does not flush them from the adapter. See
gst_adapter_take_list() for details.

Caller owns returned list and contained buffers. gst_buffer_unref() each
buffer in the list before freeing the list after usage.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="97"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1140">a #GList of
    buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
    bytes are not available</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gst.Buffer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1130">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1131">the number of bytes to get</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="map" c:identifier="gst_adapter_map">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="461">Gets the first @size bytes stored in the @adapter. The returned pointer is
valid until the next function is called on the adapter.

Note that setting the returned pointer as the data of a #GstBuffer is
incorrect for general-purpose plugins. The reason is that if a downstream
element stores the buffer so that it has access to it outside of the bounds
of its chain function, the buffer will have an invalid data pointer after
your element flushes the bytes. In that case you should use
gst_adapter_take(), which returns a freshly-allocated buffer that you can set
as #GstBuffer memory or the potentially more performant
gst_adapter_take_buffer().

Returns %NULL if @size bytes are not available.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="64"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="480">
    a pointer to the first @size bytes of data, or %NULL</doc>
          <array length="0" zero-terminated="0" c:type="gconstpointer">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="463">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="464">the number of bytes to map/peek</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_adapter_masked_scan_uint32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1743">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.

The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.

It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.

This function calls gst_adapter_masked_scan_uint32_peek() passing %NULL
for value.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="139"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1765">offset of the first match, or -1 if no match was found.

Example:
|[
// Assume the adapter contains 0x00 0x01 0x02 ... 0xfe 0xff

gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_adapter_masked_scan_uint32 (adapter, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_adapter_masked_scan_uint32 (adapter, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
]|</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1745">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1746">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1747">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1748">offset into the adapter data from which to start scanning, returns
         the last scanned position.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1750">number of bytes to scan from offset</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32_peek"
              c:identifier="gst_adapter_masked_scan_uint32_peek">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1629">Scan for pattern @pattern with applied mask @mask in the adapter data,
starting from offset @offset.  If a match is found, the value that matched
is returned through @value, otherwise @value is left untouched.

The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
adapter for it to match, even if the first or last bytes are masked out.

It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the adapter.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="142"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1650">offset of the first match, or -1 if no match was found.</doc>
          <type name="gssize" c:type="gssize"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1631">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1632">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1633">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1634">offset into the adapter data from which to start scanning, returns
         the last scanned position.</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1636">number of bytes to scan from offset</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1637">pointer to uint32 to return matching data</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="offset_at_discont"
              c:identifier="gst_adapter_offset_at_discont"
              version="1.10">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1389">Get the offset that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
flag, or GST_BUFFER_OFFSET_NONE.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="133"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1398">The offset at the last discont or GST_BUFFER_OFFSET_NONE.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1391">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="prev_dts" c:identifier="gst_adapter_prev_dts">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1502">Get the dts that was before the current byte in the adapter. When
@distance is given, the amount of bytes between the dts and the current
position is returned.

The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a dts is removed from the adapter, the dts
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="115"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1516">The previously seen dts.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1504">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1505">pointer to location for distance, or %NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_dts_at_offset"
              c:identifier="gst_adapter_prev_dts_at_offset"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1579">Get the dts that was before the byte at offset @offset in the adapter. When
@distance is given, the amount of bytes between the dts and the current
position is returned.

The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a dts is removed from the adapter, the dts
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="121"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1595">The previously seen dts at given offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1581">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1582">the offset in the adapter at which to get timestamp</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1583">pointer to location for distance, or %NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_offset"
              c:identifier="gst_adapter_prev_offset"
              version="1.10">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1446">Get the offset that was before the current byte in the adapter. When
@distance is given, the amount of bytes between the offset and the current
position is returned.

The offset is reset to GST_BUFFER_OFFSET_NONE and the distance is set to 0
when the adapter is first created or when it is cleared. This also means that
before the first byte with an offset is removed from the adapter, the offset
and distance returned are GST_BUFFER_OFFSET_NONE and 0 respectively.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="124"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1462">The previous seen offset.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1448">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1449">pointer to a location for distance, or %NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_pts" c:identifier="gst_adapter_prev_pts">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1475">Get the pts that was before the current byte in the adapter. When
@distance is given, the amount of bytes between the pts and the current
position is returned.

The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a pts is removed from the adapter, the pts
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="112"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1489">The previously seen pts.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1477">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1478">pointer to location for distance, or %NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prev_pts_at_offset"
              c:identifier="gst_adapter_prev_pts_at_offset"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1529">Get the pts that was before the byte at offset @offset in the adapter. When
@distance is given, the amount of bytes between the pts and the current
position is returned.

The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
the adapter is first created or when it is cleared. This also means that before
the first byte with a pts is removed from the adapter, the pts
and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="118"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1545">The previously seen pts at given offset.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1531">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1532">the offset in the adapter at which to get timestamp</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="distance"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1533">pointer to location for distance, or %NULL</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pts_at_discont"
              c:identifier="gst_adapter_pts_at_discont"
              version="1.10">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1408">Get the PTS that was on the last buffer with the GST_BUFFER_FLAG_DISCONT
flag, or GST_CLOCK_TIME_NONE.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="127"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1417">The PTS at the last discont or GST_CLOCK_TIME_NONE.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1410">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push" c:identifier="gst_adapter_push">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="369">Adds the data from @buf to the data stored inside @adapter and takes
ownership of the buffer.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="61"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="371">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="372">a #GstBuffer to add to queue in the adapter</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="take" c:identifier="gst_adapter_take">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="753">Returns a freshly allocated buffer containing the first @nbytes bytes of the
@adapter. The returned bytes will be flushed from the adapter.

Caller owns returned value. g_free after usage.

Free-function: g_free</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="79"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="765">
    oven-fresh hot data, or %NULL if @nbytes bytes are not available</doc>
          <array length="0" zero-terminated="0" c:type="gpointer">
            <type name="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="755">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="756">the number of bytes to take</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_buffer" c:identifier="gst_adapter_take_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1040">Returns a #GstBuffer containing the first @nbytes bytes of the
@adapter. The returned bytes will be flushed from the adapter.
This function is potentially more performant than
gst_adapter_take() since it can reuse the memory in pushed buffers
by subbuffering or merging. This function will always return a
buffer with a single memory region.

Note that no assumptions should be made as to whether certain buffer
flags such as the DISCONT flag are set on the returned buffer, or not.
The caller needs to explicitly set or unset flags that should be set or
unset.

Since 1.6 this will also copy over all GstMeta of the input buffers except
for meta with the %GST_META_FLAG_POOLED flag or with the "memory" tag.

Caller owns a reference to the returned buffer. gst_buffer_unref() after
usage.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="82"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1065">a #GstBuffer containing the first
    @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
    gst_buffer_unref() when no longer needed.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1042">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1043">the number of bytes to take</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_buffer_fast"
              c:identifier="gst_adapter_take_buffer_fast"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="865">Returns a #GstBuffer containing the first @nbytes of the @adapter.
The returned bytes will be flushed from the adapter.  This function
is potentially more performant than gst_adapter_take_buffer() since
it can reuse the memory in pushed buffers by subbuffering or
merging. Unlike gst_adapter_take_buffer(), the returned buffer may
be composed of multiple non-contiguous #GstMemory objects, no
copies are made.

Note that no assumptions should be made as to whether certain buffer
flags such as the DISCONT flag are set on the returned buffer, or not.
The caller needs to explicitly set or unset flags that should be set or
unset.

This will also copy over all GstMeta of the input buffers except
for meta with the %GST_META_FLAG_POOLED flag or with the "memory" tag.

This function can return buffer up to the return value of
gst_adapter_available() without making copies if possible.

Caller owns a reference to the returned buffer. gst_buffer_unref() after
usage.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="88"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="894">a #GstBuffer containing the first
    @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
    gst_buffer_unref() when no longer needed.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="867">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="868">the number of bytes to take</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_buffer_list"
              c:identifier="gst_adapter_take_buffer_list"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1186">Returns a #GstBufferList of buffers containing the first @nbytes bytes of
the @adapter. The returned bytes will be flushed from the adapter.
When the caller can deal with individual buffers, this function is more
performant because no memory should be copied.

Caller owns the returned list. Call gst_buffer_list_unref() to free
the list after usage.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="91"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1199">a #GstBufferList of buffers containing
    the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
    available</doc>
          <type name="Gst.BufferList" c:type="GstBufferList*"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1188">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1189">the number of bytes to take</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="take_list" c:identifier="gst_adapter_take_list">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="1084">Returns a #GList of buffers containing the first @nbytes bytes of the
@adapter. The returned bytes will be flushed from the adapter.
When the caller can deal with individual buffers, this function is more
performant because no memory should be copied.

Caller owns returned list and contained buffers. gst_buffer_unref() each
buffer in the list before freeing the list after usage.</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="85"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstadapter.c"
               line="1097">a #GList of
    buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
    bytes are not available</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="Gst.Buffer"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1086">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="1087">the number of bytes to take</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <method name="unmap" c:identifier="gst_adapter_unmap">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstadapter.c"
             line="559">Releases the memory obtained with the last gst_adapter_map().</doc>
        <source-position filename="libs/gst/base/gstadapter.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="adapter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstadapter.c"
                 line="561">a #GstAdapter</doc>
            <type name="Adapter" c:type="GstAdapter*"/>
          </instance-parameter>
        </parameters>
      </method>
    </class>
    <record name="AdapterClass"
            c:type="GstAdapterClass"
            disguised="1"
            opaque="1"
            glib:is-gtype-struct-for="Adapter">
      <source-position filename="libs/gst/base/gstadapter.h" line="49"/>
    </record>
    <class name="Aggregator"
           c:symbol-prefix="aggregator"
           c:type="GstAggregator"
           version="1.14"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstAggregator"
           glib:get-type="gst_aggregator_get_type"
           glib:type-struct="AggregatorClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstaggregator.c"
           line="22">Manages a set of pads with the purpose of aggregating their buffers.
Control is given to the subclass when all pads have data.

 * Base class for mixers and muxers. Subclasses should at least implement
   the #GstAggregatorClass::aggregate virtual method.

 * Installs a #GstPadChainFunction, a #GstPadEventFullFunction and a
   #GstPadQueryFunction to queue all serialized data packets per sink pad.
   Subclasses should not overwrite those, but instead implement
   #GstAggregatorClass::sink_event and #GstAggregatorClass::sink_query as
   needed.

 * When data is queued on all pads, the aggregate vmethod is called.

 * One can peek at the data on any given GstAggregatorPad with the
   gst_aggregator_pad_peek_buffer() method, and remove it from the pad
   with the gst_aggregator_pad_pop_buffer () method. When a buffer
   has been taken with pop_buffer (), a new buffer can be queued
   on that pad.

 * When gst_aggregator_pad_peek_buffer() or gst_aggregator_pad_has_buffer()
   are called, a reference is taken to the returned buffer, which stays
   valid until either:

     - gst_aggregator_pad_pop_buffer() is called, in which case the caller
       is guaranteed that the buffer they receive is the same as the peeked
       buffer.
     - gst_aggregator_pad_drop_buffer() is called, in which case the caller
       is guaranteed that the dropped buffer is the one that was peeked.
     - the subclass implementation of #GstAggregatorClass.aggregate returns.

   Subsequent calls to gst_aggregator_pad_peek_buffer() or
   gst_aggregator_pad_has_buffer() return / check the same buffer that was
   returned / checked, until one of the conditions listed above is met.

   Subclasses are only allowed to call these methods from the aggregate
   thread.

 * If the subclass wishes to push a buffer downstream in its aggregate
   implementation, it should do so through the
   gst_aggregator_finish_buffer() method. This method will take care
   of sending and ordering mandatory events such as stream start, caps
   and segment. Buffer lists can also be pushed out with
   gst_aggregator_finish_buffer_list().

 * Same goes for EOS events, which should not be pushed directly by the
   subclass, it should instead return GST_FLOW_EOS in its aggregate
   implementation.

 * Note that the aggregator logic regarding gap event handling is to turn
   these into gap buffers with matching PTS and duration. It will also
   flag these buffers with GST_BUFFER_FLAG_GAP and GST_BUFFER_FLAG_DROPPABLE
   to ease their identification and subsequent processing.
   In addition, if the gap event was flagged with GST_GAP_FLAG_MISSING_DATA,
   a custom meta is added to the resulting gap buffer (GstAggregatorMissingDataMeta).

 * Subclasses must use (a subclass of) #GstAggregatorPad for both their
   sink and source pads.
   See gst_element_class_add_static_pad_template_with_gtype().

This class used to live in gst-plugins-bad and was moved to core.</doc>
      <source-position filename="libs/gst/base/gstaggregator.h" line="358"/>
      <virtual-method name="aggregate">
        <source-position filename="libs/gst/base/gstaggregator.h" line="294"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="timeout" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="clip">
        <source-position filename="libs/gst/base/gstaggregator.h" line="267"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create_new_pad" introspectable="0">
        <source-position filename="libs/gst/base/gstaggregator.h" line="303"/>
        <return-value>
          <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="templ" transfer-ownership="none">
            <type name="Gst.PadTemplate" c:type="GstPadTemplate*"/>
          </parameter>
          <parameter name="req_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="const GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <source-position filename="libs/gst/base/gstaggregator.h" line="319"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finish_buffer" invoker="finish_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="735">This method will push the provided output buffer downstream. If needed,
mandatory events such as stream-start, caps, and segment events will be
sent before pushing the buffer.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="271"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="737">The #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="738">the #GstBuffer to push.</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="finish_buffer_list"
                      invoker="finish_buffer_list"
                      version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="774">This method will push the provided output buffer list downstream. If needed,
mandatory events such as stream-start, caps, and segment events will be
sent before pushing the buffer.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="344"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="776">The #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="bufferlist" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="777">the #GstBufferList to push.</doc>
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate_src_caps">
        <source-position filename="libs/gst/base/gstaggregator.h" line="315"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="flush">
        <source-position filename="libs/gst/base/gstaggregator.h" line="265"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_next_time">
        <source-position filename="libs/gst/base/gstaggregator.h" line="301"/>
        <return-value transfer-ownership="none">
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate" version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="1349">Negotiates src pad caps with downstream elements.
Unmarks GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again
if #GstAggregatorClass::negotiate fails.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="326"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="1357">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="1351">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiated_src_caps">
        <source-position filename="libs/gst/base/gstaggregator.h" line="317"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="peek_next_sample"
                      invoker="peek_next_sample"
                      version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="325">Use this function to determine what input buffers will be aggregated
to produce the next output buffer. This should only be called from
a #GstAggregator::samples-selected handler, and can be used to precisely
control aggregating parameters for a given set of input samples.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="353"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="333">The sample that is about to be aggregated. It may hold a #GstBuffer
  or a #GstBufferList. The contents of its info structure is subclass-dependent,
  and documented on a subclass basis. The buffers held by the sample are
  not writable.</doc>
          <type name="Gst.Sample" c:type="GstSample*"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <source-position filename="libs/gst/base/gstaggregator.h" line="321"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="decide_query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <source-position filename="libs/gst/base/gstaggregator.h" line="275"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event_pre_queue">
        <source-position filename="libs/gst/base/gstaggregator.h" line="328"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query">
        <source-position filename="libs/gst/base/gstaggregator.h" line="279"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query_pre_queue">
        <source-position filename="libs/gst/base/gstaggregator.h" line="332"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="aggregator_pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_activate">
        <source-position filename="libs/gst/base/gstaggregator.h" line="290"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="mode" transfer-ownership="none">
            <type name="Gst.PadMode" c:type="GstPadMode"/>
          </parameter>
          <parameter name="active" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <source-position filename="libs/gst/base/gstaggregator.h" line="284"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_query">
        <source-position filename="libs/gst/base/gstaggregator.h" line="287"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <source-position filename="libs/gst/base/gstaggregator.h" line="299"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <source-position filename="libs/gst/base/gstaggregator.h" line="297"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_src_caps">
        <source-position filename="libs/gst/base/gstaggregator.h" line="312"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="ret"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <type name="Gst.Caps" c:type="GstCaps**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="finish_buffer" c:identifier="gst_aggregator_finish_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="735">This method will push the provided output buffer downstream. If needed,
mandatory events such as stream-start, caps, and segment events will be
sent before pushing the buffer.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="379"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="737">The #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="738">the #GstBuffer to push.</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </method>
      <method name="finish_buffer_list"
              c:identifier="gst_aggregator_finish_buffer_list"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="774">This method will push the provided output buffer list downstream. If needed,
mandatory events such as stream-start, caps, and segment events will be
sent before pushing the buffer.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="383"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggregator" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="776">The #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="bufferlist" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="777">the #GstBufferList to push.</doc>
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_allocator" c:identifier="gst_aggregator_get_allocator">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3818">Lets #GstAggregator sub-classes get the memory @allocator
acquired by the base class and its @params.

Unref the @allocator after use it.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="408"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3820">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3821">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3823">the
#GstAllocationParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_pool"
              c:identifier="gst_aggregator_get_buffer_pool">
        <source-position filename="libs/gst/base/gstaggregator.h" line="405"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3799">the instance of the #GstBufferPool used
by @trans; free it after use it</doc>
          <type name="Gst.BufferPool" c:type="GstBufferPool*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3797">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_force_live"
              c:identifier="gst_aggregator_get_force_live"
              version="1.22">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3991">Subclasses may use the return value to inform whether they should return
%GST_FLOW_EOS from their aggregate implementation.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="438"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3997">whether live status was forced on @self.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ignore_inactive_pads"
              c:identifier="gst_aggregator_get_ignore_inactive_pads"
              version="1.20">
        <source-position filename="libs/gst/base/gstaggregator.h" line="435"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3974">whether inactive pads will not be waited on</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency"
              c:identifier="gst_aggregator_get_latency"
              glib:get-property="latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="2246">Retrieves the latency values reported by @self in response to the latency
query, or %GST_CLOCK_TIME_NONE if there is not live source connected and the element
will not wait for the clock.

Typically only called by subclasses.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="402"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="2256">The latency or %GST_CLOCK_TIME_NONE if the element does not sync</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2248">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="negotiate"
              c:identifier="gst_aggregator_negotiate"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="1349">Negotiates src pad caps with downstream elements.
Unmarks GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again
if #GstAggregatorClass::negotiate fails.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="391"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="1357">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="1351">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_next_sample"
              c:identifier="gst_aggregator_peek_next_sample"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="325">Use this function to determine what input buffers will be aggregated
to produce the next output buffer. This should only be called from
a #GstAggregator::samples-selected handler, and can be used to precisely
control aggregating parameters for a given set of input samples.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="420"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="333">The sample that is about to be aggregated. It may hold a #GstBuffer
  or a #GstBufferList. The contents of its info structure is subclass-dependent,
  and documented on a subclass basis. The buffers held by the sample are
  not writable.</doc>
          <type name="Gst.Sample" c:type="GstSample*"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="selected_samples"
              c:identifier="gst_aggregator_selected_samples"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3912">Subclasses should call this when they have prepared the
buffers they will aggregate for each of their sink pads, but
before using any of the properties of the pads that govern
*how* aggregation should be performed, for example z-index
for video aggregators.

If gst_aggregator_update_segment() is used by the subclass,
it MUST be called before gst_aggregator_selected_samples().

This function MUST only be called from the #GstAggregatorClass::aggregate()
function.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="424"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="pts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3914">The presentation timestamp of the next output buffer</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="dts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3915">The decoding timestamp of the next output buffer</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3916">The duration of the next output buffer</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3917">a #GstStructure containing additional information</doc>
            <type name="Gst.Structure" c:type="GstStructure*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_force_live"
              c:identifier="gst_aggregator_set_force_live"
              version="1.22">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="4007">Subclasses should call this at construction time in order for @self to
aggregate on a timeout even when no live source is connected.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="441"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="force_live" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ignore_inactive_pads"
              c:identifier="gst_aggregator_set_ignore_inactive_pads"
              version="1.20">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3948">Subclasses should call this when they don't want to time out
waiting for a pad that hasn't yet received any buffers in live
mode.

#GstAggregator will still wait once on each newly-added pad, making
sure upstream has had a fair chance to start up.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="431"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="ignore" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3950">whether inactive pads should not be waited on</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency"
              c:identifier="gst_aggregator_set_latency"
              glib:set-property="latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3751">Lets #GstAggregator sub-classes tell the baseclass what their internal
latency is. Will also post a LATENCY message on the bus so the pipeline
can reconfigure its global latency if the values changed.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3753">a #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="min_latency" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3754">minimum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max_latency" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3755">maximum latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_src_caps" c:identifier="gst_aggregator_set_src_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="685">Sets the caps to be used on the src pad.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="387"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="687">The #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="688">The #GstCaps to set on the src pad.</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="simple_get_next_time"
              c:identifier="gst_aggregator_simple_get_next_time"
              version="1.16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3845">This is a simple #GstAggregatorClass::get_next_time implementation that
just looks at the #GstSegment on the srcpad of the aggregator and bases
the next time on the running time there.

This is the desired behaviour in most cases where you have a live source
and you have a dead line based aggregator subclass.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="413"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3856">The running time based on the position</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3847">A #GstAggregator</doc>
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_segment"
              c:identifier="gst_aggregator_update_segment"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3882">Subclasses should use this to update the segment on their
source pad, instead of directly pushing new segment events
downstream.

Subclasses MUST call this before gst_aggregator_selected_samples(),
if it is used at all.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="416"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="const GstSegment*"/>
          </parameter>
        </parameters>
      </method>
      <property name="emit-signals"
                version="1.18"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="2915">Enables the emission of signals such as #GstAggregator::samples-selected</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="latency"
                writable="1"
                transfer-ownership="none"
                setter="set_latency"
                getter="get_latency"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="min-upstream-latency"
                version="1.16"
                writable="1"
                transfer-ownership="none"
                default-value="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="2881">Force minimum upstream latency (in nanoseconds). When sources with a
higher latency are expected to be plugged in dynamically after the
aggregator has started playing, this allows overriding the minimum
latency reported by the initial source(s). This is only taken into
account when larger than the actually reported minimum latency.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="start-time"
                writable="1"
                transfer-ownership="none"
                default-value="18446744073709551615">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="start-time-selection"
                writable="1"
                transfer-ownership="none"
                default-value="GST_AGGREGATOR_START_TIME_SELECTION_ZERO">
        <type name="AggregatorStartTimeSelection"/>
      </property>
      <field name="parent">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="srcpad">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.h"
             line="143">the aggregator's source pad</doc>
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AggregatorPrivate" c:type="GstAggregatorPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="samples-selected" when="first" version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="2927">Signals that the #GstAggregator subclass has selected the next set
of input samples it will aggregate. Handlers may call
gst_aggregator_peek_next_sample() at that point.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2930">The #GstSegment the next output buffer is part of</doc>
            <type name="Gst.Segment"/>
          </parameter>
          <parameter name="pts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2931">The presentation timestamp of the next output buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="dts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2932">The decoding timestamp of the next output buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2933">The duration of the next output buffer</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="info"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="2934">a #GstStructure containing additional information</doc>
            <type name="Gst.Structure"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AggregatorClass"
            c:type="GstAggregatorClass"
            glib:is-gtype-struct-for="Aggregator"
            version="1.14">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstaggregator.h"
           line="162">The aggregator base class will handle in a thread-safe way all manners of
concurrent flushes, seeks, pad additions and removals, leaving to the
subclass the responsibility of clipping buffers, and aggregating buffers in
the way the implementor sees fit.

It will also take care of event ordering (stream-start, segment, eos).

Basically, a simple implementation will override @aggregate, and call
_finish_buffer from inside that function.</doc>
      <source-position filename="libs/gst/base/gstaggregator.h" line="358"/>
      <field name="parent_class">
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="flush">
        <callback name="flush">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="265"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="clip">
        <callback name="clip">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="267"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finish_buffer">
        <callback name="finish_buffer">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="271"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstaggregator.c"
                   line="737">The #GstAggregator</doc>
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstaggregator.c"
                   line="738">the #GstBuffer to push.</doc>
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="275"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query">
        <callback name="sink_query">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="279"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="284"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_query">
        <callback name="src_query">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="287"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_activate">
        <callback name="src_activate">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="290"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="mode" transfer-ownership="none">
              <type name="Gst.PadMode" c:type="GstPadMode"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="aggregate">
        <callback name="aggregate">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="294"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="timeout" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="297"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="299"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_next_time">
        <callback name="get_next_time">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="301"/>
          <return-value transfer-ownership="none">
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create_new_pad" introspectable="0">
        <callback name="create_new_pad" introspectable="0">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="303"/>
          <return-value>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="templ" transfer-ownership="none">
              <type name="Gst.PadTemplate" c:type="GstPadTemplate*"/>
            </parameter>
            <parameter name="req_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="const GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_src_caps">
        <callback name="update_src_caps">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="312"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="ret"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       optional="1"
                       allow-none="1">
              <type name="Gst.Caps" c:type="GstCaps**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate_src_caps">
        <callback name="fixate_src_caps">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="315"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiated_src_caps">
        <callback name="negotiated_src_caps">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="317"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="319"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="321"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="decide_query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="326"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="1357">%TRUE if the negotiation succeeded, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="self" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstaggregator.c"
                   line="1351">a #GstAggregator</doc>
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event_pre_queue">
        <callback name="sink_event_pre_queue">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="328"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query_pre_queue">
        <callback name="sink_query_pre_queue">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="332"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="finish_buffer_list">
        <callback name="finish_buffer_list">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="344"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstaggregator.c"
                   line="776">The #GstAggregator</doc>
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="bufferlist" transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstaggregator.c"
                   line="777">the #GstBufferList to push.</doc>
              <type name="Gst.BufferList" c:type="GstBufferList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="peek_next_sample">
        <callback name="peek_next_sample">
          <source-position filename="libs/gst/base/gstaggregator.h"
                           line="353"/>
          <return-value transfer-ownership="full" nullable="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="333">The sample that is about to be aggregated. It may hold a #GstBuffer
  or a #GstBufferList. The contents of its info structure is subclass-dependent,
  and documented on a subclass basis. The buffers held by the sample are
  not writable.</doc>
            <type name="Gst.Sample" c:type="GstSample*"/>
          </return-value>
          <parameters>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="aggregator_pad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="15">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <class name="AggregatorPad"
           c:symbol-prefix="aggregator_pad"
           c:type="GstAggregatorPad"
           version="1.14"
           parent="Gst.Pad"
           glib:type-name="GstAggregatorPad"
           glib:get-type="gst_aggregator_pad_get_type"
           glib:type-struct="AggregatorPadClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstaggregator.c"
           line="94">Pads managed by a #GstAggregator subclass.

This class used to live in gst-plugins-bad and was moved to core.</doc>
      <source-position filename="libs/gst/base/gstaggregator.h" line="100"/>
      <virtual-method name="flush">
        <source-position filename="libs/gst/base/gstaggregator.h" line="95"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggpad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
          <parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="skip_buffer">
        <source-position filename="libs/gst/base/gstaggregator.h" line="96"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="aggpad" transfer-ownership="none">
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
          <parameter name="aggregator" transfer-ownership="none">
            <type name="Aggregator" c:type="GstAggregator*"/>
          </parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="drop_buffer" c:identifier="gst_aggregator_pad_drop_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3575">Drop the buffer currently queued in @pad.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="116"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3581">TRUE if there was a buffer queued in @pad, or FALSE if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3577">the pad where to drop any pending buffer</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_buffer"
              c:identifier="gst_aggregator_pad_has_buffer"
              version="1.14.1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3634">This checks if a pad has a buffer available that will be returned by
a call to gst_aggregator_pad_peek_buffer() or
gst_aggregator_pad_pop_buffer().</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="119"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3642">%TRUE if the pad has a buffer available as the next thing.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3636">the pad to check the buffer on</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_eos" c:identifier="gst_aggregator_pad_is_eos">
        <source-position filename="libs/gst/base/gstaggregator.h" line="122"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3670">%TRUE if the pad is EOS, otherwise %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3668">an aggregator pad</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_inactive"
              c:identifier="gst_aggregator_pad_is_inactive"
              version="1.20">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3684">It is only valid to call this method from #GstAggregatorClass::aggregate()</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="125"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3690">%TRUE if the pad is inactive, %FALSE otherwise.
  See gst_aggregator_ignore_inactive_pads() for more info.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3686">an aggregator pad</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_buffer" c:identifier="gst_aggregator_pad_peek_buffer">
        <source-position filename="libs/gst/base/gstaggregator.h" line="113"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3601">A reference to the buffer in @pad or
NULL if no buffer was queued. You should unref the buffer after
usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3599">the pad to get buffer from</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_buffer" c:identifier="gst_aggregator_pad_pop_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3517">Steal the ref to the buffer currently queued in @pad.</doc>
        <source-position filename="libs/gst/base/gstaggregator.h" line="110"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstaggregator.c"
               line="3523">The buffer in @pad or NULL if no buffer was
  queued. You should unref the buffer after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstaggregator.c"
                 line="3519">the pad to get buffer from</doc>
            <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="emit-signals"
                version="1.16"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.c"
             line="3428">Enables the emission of signals such as #GstAggregatorPad::buffer-consumed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="parent">
        <type name="Gst.Pad" c:type="GstPad"/>
      </field>
      <field name="segment">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.h"
             line="59">last segment received.</doc>
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="AggregatorPadPrivate" c:type="GstAggregatorPadPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="buffer-consumed" when="first">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="object" transfer-ownership="none">
            <type name="Gst.Buffer"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="AggregatorPadClass"
            c:type="GstAggregatorPadClass"
            glib:is-gtype-struct-for="AggregatorPad"
            version="1.14">
      <source-position filename="libs/gst/base/gstaggregator.h" line="100"/>
      <field name="parent_class">
        <type name="Gst.PadClass" c:type="GstPadClass"/>
      </field>
      <field name="flush">
        <callback name="flush">
          <source-position filename="libs/gst/base/gstaggregator.h" line="95"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="aggpad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="skip_buffer">
        <callback name="skip_buffer">
          <source-position filename="libs/gst/base/gstaggregator.h" line="96"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="aggpad" transfer-ownership="none">
              <type name="AggregatorPad" c:type="GstAggregatorPad*"/>
            </parameter>
            <parameter name="aggregator" transfer-ownership="none">
              <type name="Aggregator" c:type="GstAggregator*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="AggregatorPadPrivate"
            c:type="GstAggregatorPadPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstaggregator.h" line="55"/>
    </record>
    <record name="AggregatorPrivate"
            c:type="GstAggregatorPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstaggregator.h" line="34"/>
    </record>
    <enumeration name="AggregatorStartTimeSelection"
                 version="1.18"
                 glib:type-name="GstAggregatorStartTimeSelection"
                 glib:get-type="gst_aggregator_start_time_selection_get_type"
                 c:type="GstAggregatorStartTimeSelection">
      <member name="zero"
              value="0"
              c:identifier="GST_AGGREGATOR_START_TIME_SELECTION_ZERO"
              glib:nick="zero"
              glib:name="GST_AGGREGATOR_START_TIME_SELECTION_ZERO">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.h"
             line="446">Start at running time 0.</doc>
      </member>
      <member name="first"
              value="1"
              c:identifier="GST_AGGREGATOR_START_TIME_SELECTION_FIRST"
              glib:nick="first"
              glib:name="GST_AGGREGATOR_START_TIME_SELECTION_FIRST">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.h"
             line="447">Start at the running time of
the first buffer that is received.</doc>
      </member>
      <member name="set"
              value="2"
              c:identifier="GST_AGGREGATOR_START_TIME_SELECTION_SET"
              glib:nick="set"
              glib:name="GST_AGGREGATOR_START_TIME_SELECTION_SET">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstaggregator.h"
             line="449">Start at the running time
selected by the `start-time` property.</doc>
      </member>
    </enumeration>
    <function-macro name="BASE_PARSE"
                    c:identifier="GST_BASE_PARSE"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="31"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_CAST"
                    c:identifier="GST_BASE_PARSE_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_CLASS"
                    c:identifier="GST_BASE_PARSE_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="32"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_DRAINING"
                    c:identifier="GST_BASE_PARSE_DRAINING"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="76">Obtains current drain status (ie. whether EOS has been received and
the parser is now processing the frames at the end of the stream)</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="83"/>
      <parameters>
        <parameter name="parse">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.h"
               line="78">base parse instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="BASE_PARSE_FLAG_DRAINING"
              value="2"
              c:type="GST_BASE_PARSE_FLAG_DRAINING">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="66"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <constant name="BASE_PARSE_FLAG_LOST_SYNC"
              value="1"
              c:type="GST_BASE_PARSE_FLAG_LOST_SYNC">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="65"/>
      <type name="gint" c:type="gint"/>
    </constant>
    <function-macro name="BASE_PARSE_GET_CLASS"
                    c:identifier="GST_BASE_PARSE_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="33"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_LOST_SYNC"
                    c:identifier="GST_BASE_PARSE_LOST_SYNC"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="68">Obtains current sync status.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="74"/>
      <parameters>
        <parameter name="parse">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.h"
               line="70">base parse instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_SINK_PAD"
                    c:identifier="GST_BASE_PARSE_SINK_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="46">Gives the pointer to the sink #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="52"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.h"
               line="48">base parse instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_PARSE_SRC_PAD"
                    c:identifier="GST_BASE_PARSE_SRC_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="38">Gives the pointer to the source #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="44"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.h"
               line="40">base parse instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK"
                    c:identifier="GST_BASE_SINK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="33"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_CAST"
                    c:identifier="GST_BASE_SINK_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="38"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_CLASS"
                    c:identifier="GST_BASE_SINK_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="34"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_GET_CLASS"
                    c:identifier="GST_BASE_SINK_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_GET_PREROLL_COND"
                    c:identifier="GST_BASE_SINK_GET_PREROLL_COND"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="53"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_GET_PREROLL_LOCK"
                    c:identifier="GST_BASE_SINK_GET_PREROLL_LOCK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="48"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PAD"
                    c:identifier="GST_BASE_SINK_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesink.h"
           line="40">Gives the pointer to the #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbasesink.h" line="46"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.h"
               line="42">base sink instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_BROADCAST"
                    c:identifier="GST_BASE_SINK_PREROLL_BROADCAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="59"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_LOCK"
                    c:identifier="GST_BASE_SINK_PREROLL_LOCK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="49"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_SIGNAL"
                    c:identifier="GST_BASE_SINK_PREROLL_SIGNAL"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="58"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_TRYLOCK"
                    c:identifier="GST_BASE_SINK_PREROLL_TRYLOCK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="50"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_UNLOCK"
                    c:identifier="GST_BASE_SINK_PREROLL_UNLOCK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="51"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_WAIT"
                    c:identifier="GST_BASE_SINK_PREROLL_WAIT"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="54"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SINK_PREROLL_WAIT_UNTIL"
                    c:identifier="GST_BASE_SINK_PREROLL_WAIT_UNTIL"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="56"/>
      <parameters>
        <parameter name="obj">
        </parameter>
        <parameter name="end_time">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC"
                    c:identifier="GST_BASE_SRC"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="33"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_CAST"
                    c:identifier="GST_BASE_SRC_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="38"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_CLASS"
                    c:identifier="GST_BASE_SRC_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="34"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_GET_CLASS"
                    c:identifier="GST_BASE_SRC_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_IS_STARTED"
                    c:identifier="GST_BASE_SRC_IS_STARTED"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="56"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_IS_STARTING"
                    c:identifier="GST_BASE_SRC_IS_STARTING"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="55"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_SRC_PAD"
                    c:identifier="GST_BASE_SRC_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesrc.h"
           line="62">Gives the pointer to the #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbasesrc.h" line="68"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.h"
               line="64">base source instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_TRANSFORM"
                    c:identifier="GST_BASE_TRANSFORM"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="30"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_TRANSFORM_CAST"
                    c:identifier="GST_BASE_TRANSFORM_CAST"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_TRANSFORM_CLASS"
                    c:identifier="GST_BASE_TRANSFORM_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="31"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BASE_TRANSFORM_GET_CLASS"
                    c:identifier="GST_BASE_TRANSFORM_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="32"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <constant name="BASE_TRANSFORM_SINK_NAME"
              value="sink"
              c:type="GST_BASE_TRANSFORM_SINK_NAME">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.h"
           line="37">The name of the templates for the sink pad.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="42"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="BASE_TRANSFORM_SINK_PAD"
                    c:identifier="GST_BASE_TRANSFORM_SINK_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.h"
           line="58">Gives the pointer to the sink #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="64"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.h"
               line="60">base transform instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <constant name="BASE_TRANSFORM_SRC_NAME"
              value="src"
              c:type="GST_BASE_TRANSFORM_SRC_NAME">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.h"
           line="43">The name of the templates for the source pad.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="48"/>
      <type name="utf8" c:type="gchar*"/>
    </constant>
    <function-macro name="BASE_TRANSFORM_SRC_PAD"
                    c:identifier="GST_BASE_TRANSFORM_SRC_PAD"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.h"
           line="50">Gives the pointer to the source #GstPad object of the element.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="56"/>
      <parameters>
        <parameter name="obj">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.h"
               line="52">base transform instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BIT_READER"
                    c:identifier="GST_BIT_READER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbitreader.h" line="31"/>
      <parameters>
        <parameter name="reader">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BIT_READER_INIT"
                    c:identifier="GST_BIT_READER_INIT"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitreader.h"
           line="105">A #GstBitReader must be initialized with this macro, before it can be
used. This macro can used be to initialize a variable, but it cannot
be assigned to a variable. In that case you have to use
gst_bit_reader_init().</doc>
      <source-position filename="libs/gst/base/gstbitreader.h" line="115"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.h"
               line="107">Data from which the #GstBitReader should read</doc>
        </parameter>
        <parameter name="size">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.h"
               line="108">Size of @data in bytes</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BIT_WRITER"
                    c:identifier="GST_BIT_WRITER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbitwriter.h" line="35"/>
      <parameters>
        <parameter name="writer">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BIT_WRITER_BIT_SIZE"
                    c:identifier="GST_BIT_WRITER_BIT_SIZE"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbitwriter.h" line="34"/>
      <parameters>
        <parameter name="writer">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BIT_WRITER_DATA"
                    c:identifier="GST_BIT_WRITER_DATA"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbitwriter.h" line="33"/>
      <parameters>
        <parameter name="writer">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BYTE_READER"
                    c:identifier="GST_BYTE_READER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbytereader.h" line="30"/>
      <parameters>
        <parameter name="reader">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BYTE_READER_INIT"
                    c:identifier="GST_BYTE_READER_INIT"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytereader.h"
           line="274">A #GstByteReader must be initialized with this macro, before it can be
used. This macro can used be to initialize a variable, but it cannot
be assigned to a variable. In that case you have to use
gst_byte_reader_init().</doc>
      <source-position filename="libs/gst/base/gstbytereader.h" line="284"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.h"
               line="276">Data from which the #GstByteReader should read</doc>
        </parameter>
        <parameter name="size">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.h"
               line="277">Size of @data in bytes</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="BYTE_WRITER"
                    c:identifier="GST_BYTE_WRITER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbytewriter.h" line="31"/>
      <parameters>
        <parameter name="writer">
        </parameter>
      </parameters>
    </function-macro>
    <class name="BaseParse"
           c:symbol-prefix="base_parse"
           c:type="GstBaseParse"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseParse"
           glib:get-type="gst_base_parse_get_type"
           glib:type-struct="BaseParseClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.c"
           line="24">This base class is for parser elements that process data and splits it
into separate audio/video/whatever frames.

It provides for:

  * provides one sink pad and one source pad
  * handles state changes
  * can operate in pull mode or push mode
  * handles seeking in both modes
  * handles events (SEGMENT/EOS/FLUSH)
  * handles queries (POSITION/DURATION/SEEKING/FORMAT/CONVERT)
  * handles flushing

The purpose of this base class is to provide the basic functionality of
a parser and share a lot of rather complex code.

# Description of the parsing mechanism:

## Set-up phase

 * #GstBaseParse calls #GstBaseParseClass::start to inform subclass
   that data processing is about to start now.

 * #GstBaseParse class calls #GstBaseParseClass::set_sink_caps to
   inform the subclass about incoming sinkpad caps. Subclass could
   already set the srcpad caps accordingly, but this might be delayed
   until calling gst_base_parse_finish_frame() with a non-queued frame.

 * At least at this point subclass needs to tell the #GstBaseParse class
   how big data chunks it wants to receive (minimum frame size ). It can
   do this with gst_base_parse_set_min_frame_size().

 * #GstBaseParse class sets up appropriate data passing mode (pull/push)
   and starts to process the data.

## Parsing phase

 * #GstBaseParse gathers at least min_frame_size bytes of data either
   by pulling it from upstream or collecting buffers in an internal
   #GstAdapter.

 * A buffer of (at least) min_frame_size bytes is passed to subclass
   with #GstBaseParseClass::handle_frame. Subclass checks the contents
   and can optionally return #GST_FLOW_OK along with an amount of data
   to be skipped to find a valid frame (which will result in a
   subsequent DISCONT).  If, otherwise, the buffer does not hold a
   complete frame, #GstBaseParseClass::handle_frame can merely return
   and will be called again when additional data is available.  In push
   mode this amounts to an additional input buffer (thus minimal
   additional latency), in pull mode this amounts to some arbitrary
   reasonable buffer size increase.

   Of course, gst_base_parse_set_min_frame_size() could also be used if
   a very specific known amount of additional data is required.  If,
   however, the buffer holds a complete valid frame, it can pass the
   size of this frame to gst_base_parse_finish_frame().

   If acting as a converter, it can also merely indicate consumed input
   data while simultaneously providing custom output data.  Note that
   baseclass performs some processing (such as tracking overall consumed
   data rate versus duration) for each finished frame, but other state
   is only updated upon each call to #GstBaseParseClass::handle_frame
   (such as tracking upstream input timestamp).

   Subclass is also responsible for setting the buffer metadata
   (e.g. buffer timestamp and duration, or keyframe if applicable).
   (although the latter can also be done by #GstBaseParse if it is
   appropriately configured, see below).  Frame is provided with
   timestamp derived from upstream (as much as generally possible),
   duration obtained from configuration (see below), and offset
   if meaningful (in pull mode).

   Note that #GstBaseParseClass::handle_frame might receive any small
   amount of input data when leftover data is being drained (e.g. at
   EOS).

 * As part of finish frame processing, just prior to actually pushing
   the buffer in question, it is passed to
   #GstBaseParseClass::pre_push_frame which gives subclass yet one last
   chance to examine buffer metadata, or to send some custom (tag)
   events, or to perform custom (segment) filtering.

 * During the parsing process #GstBaseParseClass will handle both srcpad
   and sinkpad events. They will be passed to subclass if
   #GstBaseParseClass::sink_event or #GstBaseParseClass::src_event
   implementations have been provided.

## Shutdown phase

* #GstBaseParse class calls #GstBaseParseClass::stop to inform the
  subclass that data parsing will be stopped.

Subclass is responsible for providing pad template caps for source and
sink pads. The pads need to be named "sink" and "src". It also needs to
set the fixed caps on srcpad, when the format is ensured (e.g.  when
base class calls subclass' #GstBaseParseClass::set_sink_caps function).

This base class uses %GST_FORMAT_DEFAULT as a meaning of frames. So,
subclass conversion routine needs to know that conversion from
%GST_FORMAT_TIME to %GST_FORMAT_DEFAULT must return the
frame number that can be found from the given byte position.

#GstBaseParse uses subclasses conversion methods also for seeking (or
otherwise uses its own default one, see also below).

Subclass @start and @stop functions will be called to inform the beginning
and end of data processing.

Things that subclass need to take care of:

* Provide pad templates
* Fixate the source pad caps when appropriate
* Inform base class how big data chunks should be retrieved. This is
  done with gst_base_parse_set_min_frame_size() function.
* Examine data chunks passed to subclass with
  #GstBaseParseClass::handle_frame and pass proper frame(s) to
  gst_base_parse_finish_frame(), and setting src pad caps and timestamps
  on frame.
* Provide conversion functions
* Update the duration information with gst_base_parse_set_duration()
* Optionally passthrough using gst_base_parse_set_passthrough()
* Configure various baseparse parameters using
  gst_base_parse_set_average_bitrate(), gst_base_parse_set_syncable()
  and gst_base_parse_set_frame_rate().

* In particular, if subclass is unable to determine a duration, but
  parsing (or specs) yields a frames per seconds rate, then this can be
  provided to #GstBaseParse to enable it to cater for buffer time
  metadata (which will be taken from upstream as much as
  possible). Internally keeping track of frame durations and respective
  sizes that have been pushed provides #GstBaseParse with an estimated
  bitrate. A default #GstBaseParseClass::convert (used if not
  overridden) will then use these rates to perform obvious conversions.
  These rates are also used to update (estimated) duration at regular
  frame intervals.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="293"/>
      <virtual-method name="convert">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="267"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="src_format" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value" transfer-ownership="none">
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="detect">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="282"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_sink_caps">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="279"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="handle_frame">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="245">Parses the input data into valid frames as defined by subclass
which should be passed to gst_base_parse_finish_frame().
The frame's input buffer is guaranteed writable,
whereas the input frame ownership is held by caller
(so subclass should make a copy if it needs to hang on).
Input buffer (data) is provided by baseclass with as much
metadata set as possible by baseclass according to upstream
information and/or subclass settings,
though subclass may still set buffer timestamp and duration
if desired.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="260"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="frame" transfer-ownership="none">
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
          <parameter name="skipsize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="gint" c:type="gint*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="pre_push_frame">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="264"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="frame" transfer-ownership="none">
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_sink_caps">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="242"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="273"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_query">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="285"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="276"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_query">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="288"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="238"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <source-position filename="libs/gst/base/gstbaseparse.h" line="240"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="add_index_entry"
              c:identifier="gst_base_parse_add_index_entry">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="1988">Adds an entry to the index associating @offset to @ts.  It is recommended
to only add keyframe entries.  @force allows to bypass checks, such as
whether the stream is (upstream) seekable, another entry is already "close"
to the new entry, etc.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="366"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="2001">#gboolean indicating whether entry was added</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1990">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1991">offset of entry</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="ts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1992">timestamp associated with offset</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1993">whether entry refers to keyframe</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="force" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1994">add entry disregarding sanity checks</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="convert_default"
              c:identifier="gst_base_parse_convert_default">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="1751">Default implementation of #GstBaseParseClass::convert.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="360"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="1761">%TRUE if conversion was successful.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1753">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="src_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1754">#GstFormat describing the source format.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="src_value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1755">Source value to be converted.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="dest_format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1756">#GstFormat defining the converted format.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="dest_value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="1757">Pointer where the conversion result will be put.</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="drain" c:identifier="gst_base_parse_drain" version="1.12">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="2771">Drains the adapter until it is empty. It decreases the min_frame_size to
match the current adapter size and calls chain method until the adapter
is emptied or chain returns with error.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="335"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2773">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="finish_frame" c:identifier="gst_base_parse_finish_frame">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="2675">Collects parsed data and pushes this downstream.
Source pad caps must be set when this is called.

If @frame's out_buffer is set, that will be used as subsequent frame data.
Otherwise, @size samples will be taken from the input and used for output,
and the output's metadata (timestamps etc) will be taken as (optionally)
set by the subclass on @frame's (input) buffer (which is otherwise
ignored for any but the above purpose/information).

Note that the latter buffer is invalidated by this call, whereas the
caller retains ownership of @frame.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="317"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="2693">a #GstFlowReturn that should be escalated to caller (of caller)</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2677">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="frame" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2678">a #GstBaseParseFrame</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2679">consumed input data represented by frame</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="merge_tags"
              c:identifier="gst_base_parse_merge_tags"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="5028">Sets the parser subclass's tags and how they should be merged with any
upstream stream tags. This will override any tags previously-set
with gst_base_parse_merge_tags().

Note that this is provided for convenience, and the subclass is
not required to use this and can still do tag handling on its own.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="375"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="5030">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="tags"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="5031">a #GstTagList to merge, or NULL to unset
    previously-set tags</doc>
            <type name="Gst.TagList" c:type="GstTagList*"/>
          </parameter>
          <parameter name="mode" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="5033">the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE</doc>
            <type name="Gst.TagMergeMode" c:type="GstTagMergeMode"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_frame" c:identifier="gst_base_parse_push_frame">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="2461">Pushes the frame's buffer downstream, sends any pending events and
does some timestamp and segment handling. Takes ownership of
frame's buffer, though caller retains ownership of @frame.

This must be called with sinkpad STREAM_LOCK held.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="314"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="2472">#GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2463">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="frame" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="2464">a #GstBaseParseFrame</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_average_bitrate"
              c:identifier="gst_base_parse_set_average_bitrate">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="3897">Optionally sets the average bitrate detected in media (if non-zero),
e.g. based on metadata, as it will be posted to the application.

By default, announced average bitrate is estimated. The average bitrate
is used to estimate the total duration of the stream and to estimate
a seek position, if there's no index and the format is syncable
(see gst_base_parse_set_syncable()).</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="326"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3899">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="bitrate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3900">average bitrate in bits/second</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_duration" c:identifier="gst_base_parse_set_duration">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="3846">Sets the duration of the currently playing media. Subclass can use this
when it is able to determine duration and/or notices a change in the media
duration.  Alternatively, if @interval is non-zero (default), then stream
duration is determined based on estimated bitrate, and updated every @interval
frames.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="321"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3848">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="fmt" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3849">#GstFormat.</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
          <parameter name="duration" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3850">duration value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="interval" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3851">how often to update the duration estimate based on bitrate, or 0.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_frame_rate"
              c:identifier="gst_base_parse_set_frame_rate">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="3935">If frames per second is configured, parser can take care of buffer duration
and timestamping.  When performing segment clipping, or seeking to a specific
location, a corresponding decoder might need an initial @lead_in and a
following @lead_out number of frames to ensure the desired segment is
entirely filled upon decoding.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="350"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3937">the #GstBaseParse to set</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="fps_num" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3938">frames per second (numerator).</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fps_den" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3939">frames per second (denominator).</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lead_in" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3940">frames needed before a segment for subsequent decode</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="lead_out" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3941">frames needed after a segment</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_has_timing_info"
              c:identifier="gst_base_parse_set_has_timing_info">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="3992">Set if frames carry timing information which the subclass can (generally)
parse and provide.  In particular, intrinsic (rather than estimated) time
can be obtained following a seek.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="332"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3994">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="has_timing" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3995">whether frames carry timing information</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_infer_ts" c:identifier="gst_base_parse_set_infer_ts">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4063">By default, the base class might try to infer PTS from DTS and vice
versa.  While this is generally correct for audio data, it may not
be otherwise. Sub-classes implementing such formats should disable
timestamp inferring.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="347"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4065">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="infer_ts" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4066">%TRUE if parser should infer DTS/PTS from each other</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_latency" c:identifier="gst_base_parse_set_latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4080">Sets the minimum and maximum (which may likely be equal) latency introduced
by the parsing process. If there is such a latency, which depends on the
particular parsing of the format, it typically corresponds to 1 frame duration.

If the provided values changed from previously provided ones, this will
also post a LATENCY message on the bus so the pipeline can reconfigure its
global latency.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="356"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4082">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="min_latency" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4083">minimum parse latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="max_latency" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4084">maximum parse latency</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_min_frame_size"
              c:identifier="gst_base_parse_set_min_frame_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="3917">Subclass can use this function to tell the base class that it needs to
be given buffers of at least @min_size bytes.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="329"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3919">#GstBaseParse.</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="min_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="3920">Minimum size in bytes of the data that this base class should
      give to subclass.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gst_base_parse_set_passthrough">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4024">Set if the nature of the format or configuration does not allow (much)
parsing, and the parser should operate in passthrough mode (which only
applies when operating in push mode). That is, incoming buffers are
pushed through unmodified, i.e. no #GstBaseParseClass::handle_frame
will be invoked, but #GstBaseParseClass::pre_push_frame will still be
invoked, so subclass can perform as much or as little is appropriate for
passthrough semantics in #GstBaseParseClass::pre_push_frame.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="341"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4026">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="passthrough" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4027">%TRUE if parser should run in passthrough mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pts_interpolation"
              c:identifier="gst_base_parse_set_pts_interpolation">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4044">By default, the base class will guess PTS timestamps using a simple
interpolation (previous timestamp + duration), which is incorrect for
data streams with reordering, where PTS can go backward. Sub-classes
implementing such formats should disable PTS interpolation.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="344"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4046">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="pts_interpolate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4047">%TRUE if parser should interpolate PTS timestamps</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_syncable" c:identifier="gst_base_parse_set_syncable">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4008">Set if frame starts can be identified. This is set by default and
determines whether seeking based on bitrate averages
is possible for a format/stream.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="338"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4010">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="syncable" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4011">set if frame starts can be identified</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ts_at_offset"
              c:identifier="gst_base_parse_set_ts_at_offset"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="4988">This function should only be called from a @handle_frame implementation.

#GstBaseParse creates initial timestamps for frames by using the last
timestamp seen in the stream before the frame starts.  In certain
cases, the correct timestamps will occur in the stream after the
start of the frame, but before the start of the actual picture data.
This function can be used to set the timestamps based on the offset
into the frame data that the picture starts.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="372"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="parse" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4990">a #GstBaseParse</doc>
            <type name="BaseParse" c:type="GstBaseParse*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="4991">offset into current buffer</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </method>
      <property name="disable-passthrough"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="554">If set to %TRUE, baseparse will unconditionally force parsing of the
incoming data. This can be required in the rare cases where the incoming
side-data (caps, pts, dts, ...) is not trusted by the user and wants to
force validation and parsing of the incoming data.
If set to %FALSE, decision of whether to parse the data or not is up to
the implementation (standard behaviour).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="element">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="156">the parent element.</doc>
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="flags">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseParsePrivate" c:type="GstBaseParsePrivate*"/>
      </field>
    </class>
    <record name="BaseParseClass"
            c:type="GstBaseParseClass"
            glib:is-gtype-struct-for="BaseParse">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="179">Subclasses can override any of the available virtual methods or not, as
needed. At minimum @handle_frame needs to be overridden.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="293"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="181">the parent class</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="start">
        <callback name="start">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="238"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="240"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_sink_caps">
        <callback name="set_sink_caps">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="242"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="handle_frame">
        <callback name="handle_frame">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="260"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="frame" transfer-ownership="none">
              <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
            </parameter>
            <parameter name="skipsize"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="gint" c:type="gint*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="pre_push_frame">
        <callback name="pre_push_frame">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="264"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="frame" transfer-ownership="none">
              <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="convert">
        <callback name="convert">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="267"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="src_format" transfer-ownership="none">
              <type name="Gst.Format" c:type="GstFormat"/>
            </parameter>
            <parameter name="src_value" transfer-ownership="none">
              <type name="gint64" c:type="gint64"/>
            </parameter>
            <parameter name="dest_format" transfer-ownership="none">
              <type name="Gst.Format" c:type="GstFormat"/>
            </parameter>
            <parameter name="dest_value" transfer-ownership="none">
              <type name="gint64" c:type="gint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="273"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="276"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_sink_caps">
        <callback name="get_sink_caps">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="279"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="detect">
        <callback name="detect">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="282"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_query">
        <callback name="sink_query">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="285"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_query">
        <callback name="src_query">
          <source-position filename="libs/gst/base/gstbaseparse.h" line="288"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="parse" transfer-ownership="none">
              <type name="BaseParse" c:type="GstBaseParse*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="18">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseParseFrame"
            c:type="GstBaseParseFrame"
            glib:type-name="GstBaseParseFrame"
            glib:get-type="gst_base_parse_frame_get_type"
            c:symbol-prefix="base_parse_frame">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="115">Frame (context) data passed to each frame parsing virtual methods.  In
addition to providing the data to be checked for a valid frame or an already
identified frame, it conveys additional metadata or control information
from and to the subclass w.r.t. the particular frame in question (rather
than global parameters).  Some of these may apply to each parsing stage, others
only to some a particular one.  These parameters are effectively zeroed at start
of each frame's processing, i.e. parsing virtual method invocation sequence.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="148"/>
      <field name="buffer" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="117">input data to be parsed for frames.</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="out_buffer" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="118">output data.</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="flags" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="125">a combination of input and output #GstBaseParseFrameFlags that
 convey additional context to subclass or allow subclass to tune
 subsequent #GstBaseParse actions.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="offset" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="119">media specific offset of input frame
  Note that a converter may have a different one on the frame's buffer.</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="overhead" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="121">subclass can set this to indicates the metadata overhead
  for the given frame, which is then used to enable more accurate bitrate
  computations. If this is -1, it is assumed that this frame should be
  skipped in bitrate calculation.</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="size" readable="0" private="1">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="_gst_reserved_i" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="guint" c:type="guint"/>
        </array>
      </field>
      <field name="_gst_reserved_p" readable="0" private="1">
        <array zero-terminated="0" fixed-size="2">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <field name="_private_flags" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <constructor name="new" c:identifier="gst_base_parse_frame_new">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="751">Allocates a new #GstBaseParseFrame. This function is mainly for bindings,
elements written in C should usually allocate the frame on the stack and
then use gst_base_parse_frame_init() to initialise it.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="302"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="763">a newly-allocated #GstBaseParseFrame. Free with
    gst_base_parse_frame_free() when no longer needed.</doc>
          <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
        </return-value>
        <parameters>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="753">a #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="754">the flags</doc>
            <type name="BaseParseFrameFlags" c:type="GstBaseParseFrameFlags"/>
          </parameter>
          <parameter name="overhead" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="755">number of bytes in this frame which should be counted as
    metadata overhead, ie. not used to calculate the average bitrate.
    Set to -1 to mark the entire frame as metadata. If in doubt, set to 0.</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="copy"
              c:identifier="gst_base_parse_frame_copy"
              version="1.12.1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="682">Copies a #GstBaseParseFrame.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="309"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbaseparse.c"
               line="688">A copy of @frame</doc>
          <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
        </return-value>
        <parameters>
          <instance-parameter name="frame" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="684">a #GstBaseParseFrame</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_base_parse_frame_free">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="706">Frees the provided @frame.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="frame" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="708">A #GstBaseParseFrame</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_base_parse_frame_init">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.c"
             line="733">Sets a #GstBaseParseFrame to initial state.  Currently this means
all public fields are zero-ed and a private flag is set to make
sure gst_base_parse_frame_free() only frees the contents but not
the actual frame. Use this function to initialise a #GstBaseParseFrame
allocated on the stack.</doc>
        <source-position filename="libs/gst/base/gstbaseparse.h" line="306"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="frame" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbaseparse.c"
                 line="735">#GstBaseParseFrame.</doc>
            <type name="BaseParseFrame" c:type="GstBaseParseFrame*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <bitfield name="BaseParseFrameFlags" c:type="GstBaseParseFrameFlags">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbaseparse.h"
           line="85">Flags to be used in a #GstBaseParseFrame.</doc>
      <source-position filename="libs/gst/base/gstbaseparse.h" line="113"/>
      <member name="none"
              value="0"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_NONE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="87">no flag</doc>
      </member>
      <member name="new_frame"
              value="1"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_NEW_FRAME">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="88">set by baseclass if current frame
  is passed for processing to the subclass for the first time
  (and not set on subsequent calls with same data).</doc>
      </member>
      <member name="no_frame"
              value="2"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_NO_FRAME">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="91">set to indicate this buffer should not be
  counted as frame, e.g. if this frame is dependent on a previous one.
  As it is not counted as a frame, bitrate increases but frame to time
  conversions are maintained.</doc>
      </member>
      <member name="clip"
              value="4"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_CLIP">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="95">@pre_push_frame can set this to indicate
   that regular segment clipping can still be performed (as opposed to
   any custom one having been done).</doc>
      </member>
      <member name="drop"
              value="8"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_DROP">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="98">indicates to @finish_frame that the
   the frame should be dropped (and might be handled internally by subclass)</doc>
      </member>
      <member name="queue"
              value="16"
              c:identifier="GST_BASE_PARSE_FRAME_FLAG_QUEUE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbaseparse.h"
             line="100">indicates to @finish_frame that the
   the frame should be queued for now and processed fully later
   when the first non-queued frame is finished</doc>
      </member>
    </bitfield>
    <record name="BaseParsePrivate"
            c:type="GstBaseParsePrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="152"/>
    </record>
    <class name="BaseSink"
           c:symbol-prefix="base_sink"
           c:type="GstBaseSink"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSink"
           glib:get-type="gst_base_sink_get_type"
           glib:type-struct="BaseSinkClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesink.c"
           line="22">#GstBaseSink is the base class for sink elements in GStreamer, such as
xvimagesink or filesink. It is a layer on top of #GstElement that provides a
simplified interface to plugin writers. #GstBaseSink handles many details
for you, for example: preroll, clock synchronization, state changes,
activation in push or pull mode, and queries.

In most cases, when writing sink elements, there is no need to implement
class methods from #GstElement or to set functions on pads, because the
#GstBaseSink infrastructure should be sufficient.

#GstBaseSink provides support for exactly one sink pad, which should be
named "sink". A sink implementation (subclass of #GstBaseSink) should
install a pad template in its class_init function, like so:
|[&lt;!-- language="C" --&gt;
static void
my_element_class_init (GstMyElementClass *klass)
{
  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);

  // sinktemplate should be a #GstStaticPadTemplate with direction
  // %GST_PAD_SINK and name "sink"
  gst_element_class_add_static_pad_template (gstelement_class, &amp;sinktemplate);

  gst_element_class_set_static_metadata (gstelement_class,
      "Sink name",
      "Sink",
      "My Sink element",
      "The author &lt;my.sink@my.email&gt;");
}
]|

#GstBaseSink will handle the prerolling correctly. This means that it will
return %GST_STATE_CHANGE_ASYNC from a state change to PAUSED until the first
buffer arrives in this element. The base class will call the
#GstBaseSinkClass::preroll vmethod with this preroll buffer and will then
commit the state change to the next asynchronously pending state.

When the element is set to PLAYING, #GstBaseSink will synchronise on the
clock using the times returned from #GstBaseSinkClass::get_times. If this
function returns %GST_CLOCK_TIME_NONE for the start time, no synchronisation
will be done. Synchronisation can be disabled entirely by setting the object
#GstBaseSink:sync property to %FALSE.

After synchronisation the virtual method #GstBaseSinkClass::render will be
called. Subclasses should minimally implement this method.

Subclasses that synchronise on the clock in the #GstBaseSinkClass::render
method are supported as well. These classes typically receive a buffer in
the render method and can then potentially block on the clock while
rendering. A typical example is an audiosink.
These subclasses can use gst_base_sink_wait_preroll() to perform the
blocking wait.

Upon receiving the EOS event in the PLAYING state, #GstBaseSink will wait
for the clock to reach the time indicated by the stop time of the last
#GstBaseSinkClass::get_times call before posting an EOS message. When the
element receives EOS in PAUSED, preroll completes, the event is queued and an
EOS message is posted when going to PLAYING.

#GstBaseSink will internally use the %GST_EVENT_SEGMENT events to schedule
synchronisation and clipping of buffers. Buffers that fall completely outside
of the current segment are dropped. Buffers that fall partially in the
segment are rendered (and prerolled). Subclasses should do any subbuffer
clipping themselves when needed.

#GstBaseSink will by default report the current playback position in
%GST_FORMAT_TIME based on the current clock time and segment information.
If no clock has been set on the element, the query will be forwarded
upstream.

The #GstBaseSinkClass::set_caps function will be called when the subclass
should configure itself to process a specific media type.

The #GstBaseSinkClass::start and #GstBaseSinkClass::stop virtual methods
will be called when resources should be allocated. Any
#GstBaseSinkClass::preroll, #GstBaseSinkClass::render and
#GstBaseSinkClass::set_caps function will be called between the
#GstBaseSinkClass::start and #GstBaseSinkClass::stop calls.

The #GstBaseSinkClass::event virtual method will be called when an event is
received by #GstBaseSink. Normally this method should only be overridden by
very specific elements (such as file sinks) which need to handle the
newsegment event specially.

The #GstBaseSinkClass::unlock method is called when the elements should
unblock any blocking operations they perform in the
#GstBaseSinkClass::render method. This is mostly useful when the
#GstBaseSinkClass::render method performs a blocking write on a file
descriptor, for example.

The #GstBaseSink:max-lateness property affects how the sink deals with
buffers that arrive too late in the sink. A buffer arrives too late in the
sink when the presentation time (as a combination of the last segment, buffer
timestamp and element base_time) plus the duration is before the current
time of the clock.
If the frame is later than max-lateness, the sink will drop the buffer
without calling the render method.
This feature is disabled if sync is disabled, the
#GstBaseSinkClass::get_times method does not return a valid start time or
max-lateness is set to -1 (the default).
Subclasses can use gst_base_sink_set_max_lateness() to configure the
max-lateness value.

The #GstBaseSink:qos property will enable the quality-of-service features of
the basesink which gather statistics about the real-time performance of the
clock synchronisation. For each buffer received in the sink, statistics are
gathered and a QOS event is sent upstream with these numbers. This
information can then be used by upstream elements to reduce their processing
rate, for example.

The #GstBaseSink:async property can be used to instruct the sink to never
perform an ASYNC state change. This feature is mostly usable when dealing
with non-synchronized streams or sparse streams.</doc>
      <source-position filename="libs/gst/base/gstbasesink.h" line="214"/>
      <virtual-method name="activate_pull">
        <source-position filename="libs/gst/base/gstbasesink.h" line="167"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="active" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <source-position filename="libs/gst/base/gstbasesink.h" line="198"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <source-position filename="libs/gst/base/gstbasesink.h" line="165"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.h"
             line="154">Called to get sink pad caps from the subclass.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="160"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_times">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.h"
             line="169">Get the start and end times for syncing on this buffer.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="176"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.h"
                 line="171">the start #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.h"
                 line="172">the end #GstClockTime</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare">
        <source-position filename="libs/gst/base/gstbasesink.h" line="203"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_list">
        <source-position filename="libs/gst/base/gstbasesink.h" line="204"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer_list" transfer-ownership="none">
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="preroll">
        <source-position filename="libs/gst/base/gstbasesink.h" line="207"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <source-position filename="libs/gst/base/gstbasesink.h" line="180"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query">
        <source-position filename="libs/gst/base/gstbasesink.h" line="195"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render">
        <source-position filename="libs/gst/base/gstbasesink.h" line="208"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="render_list">
        <source-position filename="libs/gst/base/gstbasesink.h" line="210"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="buffer_list" transfer-ownership="none">
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <source-position filename="libs/gst/base/gstbasesink.h" line="162"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <source-position filename="libs/gst/base/gstbasesink.h" line="183"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <source-position filename="libs/gst/base/gstbasesink.h" line="184"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unlock">
        <source-position filename="libs/gst/base/gstbasesink.h" line="188"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <source-position filename="libs/gst/base/gstbasesink.h" line="192"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="wait_event">
        <source-position filename="libs/gst/base/gstbasesink.h" line="200"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="do_preroll" c:identifier="gst_base_sink_do_preroll">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="2461">If the @sink spawns its own thread for pulling buffers from upstream it
should call this method after it has pulled a buffer. If the element needed
to preroll, this function will perform the preroll and will then block
until the element state is changed.

This function should be called with the PREROLL_LOCK held.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="220"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="2473">%GST_FLOW_OK if the preroll completed and processing can
continue. Any other return value should be returned from the render vmethod.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2463">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="obj" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2464">the mini object that caused the preroll</doc>
            <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_blocksize"
              c:identifier="gst_base_sink_get_blocksize"
              glib:get-property="blocksize">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1389">Get the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="306"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1396">the number of bytes @sink will pull in pull mode.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1391">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_drop_out_of_segment"
              c:identifier="gst_base_sink_get_drop_out_of_segment"
              version="1.12">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="810">Checks if @sink is currently configured to drop buffers which are outside
the current segment</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="239"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="817">%TRUE if the sink is configured to drop buffers outside the
current segment.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="812">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_last_sample"
              c:identifier="gst_base_sink_get_last_sample"
              glib:get-property="last-sample">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1003">Get the last sample that arrived in the sink and was used for preroll or for
rendering. This property can be used to generate thumbnails.

The #GstCaps on the sample can be used to determine the type of the buffer.

Free-function: gst_sample_unref</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="276"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1014">a #GstSample. gst_sample_unref() after
    usage.  This function returns %NULL when no buffer has arrived in the
    sink yet or when the sink is not in PAUSED or PLAYING.</doc>
          <type name="Gst.Sample" c:type="GstSample*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1005">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_latency" c:identifier="gst_base_sink_get_latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1162">Get the currently configured latency.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="290"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1168">The configured latency.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1164">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_bitrate"
              c:identifier="gst_base_sink_get_max_bitrate"
              glib:get-property="max-bitrate"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1476">Get the maximum amount of bits per second that the sink will render.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="322"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1482">the maximum number of bits per second @sink will render.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1478">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_max_lateness"
              c:identifier="gst_base_sink_get_max_lateness"
              glib:get-property="max-lateness">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="856">Gets the max lateness value. See gst_base_sink_set_max_lateness() for
more details.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="247"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="863">The maximum time in nanoseconds that a buffer can be late
before it is dropped and not rendered. A value of -1 means an
unlimited time.</doc>
          <type name="gint64" c:type="gint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="858">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_processing_deadline"
              c:identifier="gst_base_sink_get_processing_deadline"
              glib:get-property="processing-deadline"
              version="1.16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1535">Get the processing deadline of @sink. see
gst_base_sink_set_processing_deadline() for more information about
the processing deadline.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="329"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1543">the processing deadline</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1537">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_render_delay"
              c:identifier="gst_base_sink_get_render_delay"
              glib:get-property="render-delay">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1346">Get the render delay of @sink. see gst_base_sink_set_render_delay() for more
information about the render delay.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="298"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1353">the render delay of @sink.</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1348">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_stats"
              c:identifier="gst_base_sink_get_stats"
              glib:get-property="stats"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="5890">Return various #GstBaseSink statistics. This function returns a #GstStructure
with name `application/x-gst-base-sink-stats` with the following fields:

- "average-rate" G_TYPE_DOUBLE   average frame rate
- "dropped" G_TYPE_UINT64   Number of dropped frames
- "rendered" G_TYPE_UINT64   Number of rendered frames</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="339"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="5901">pointer to #GstStructure</doc>
          <type name="Gst.Structure" c:type="GstStructure*"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="5892">#GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_sync"
              c:identifier="gst_base_sink_get_sync"
              glib:get-property="sync">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="766">Checks if @sink is currently configured to synchronize against the
clock.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="773">%TRUE if the sink is configured to synchronize against the clock.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="768">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_throttle_time"
              c:identifier="gst_base_sink_get_throttle_time"
              glib:get-property="throttle-time">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1433">Get the time that will be inserted between frames to control the
maximum buffers per second.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="314"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1440">the number of nanoseconds @sink will put between frames.</doc>
          <type name="guint64" c:type="guint64"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1435">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_ts_offset"
              c:identifier="gst_base_sink_get_ts_offset"
              glib:get-property="ts-offset">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="981">Get the synchronisation offset of @sink.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="271"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="987">The synchronisation offset.</doc>
          <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="983">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_async_enabled"
              c:identifier="gst_base_sink_is_async_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="938">Checks if @sink is currently configured to perform asynchronous state
changes to PAUSED.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="263"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="945">%TRUE if the sink is configured to perform asynchronous state
changes.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="940">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_last_sample_enabled"
              c:identifier="gst_base_sink_is_last_sample_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1145">Checks if @sink is currently configured to store the last received sample in
the last-sample property.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="282"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1152">%TRUE if the sink is configured to store the last received sample.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1147">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_sink_is_qos_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="896">Checks if @sink is currently configured to send Quality-of-Service events
upstream.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="255"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="903">%TRUE if the sink is configured to perform Quality-of-Service.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="898">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="query_latency" c:identifier="gst_base_sink_query_latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1182">Query the sink for the latency parameters. The latency will be queried from
the upstream elements. @live will be %TRUE if @sink is configured to
synchronize against the clock. @upstream_live will be %TRUE if an upstream
element is live.

If both @live and @upstream_live are %TRUE, the sink will want to compensate
for the latency introduced by the upstream elements by setting the
@min_latency to a strictly positive value.

This function is mostly used by subclasses.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="287"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="1201">%TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1184">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1185">if the sink is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="upstream_live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1186">if an upstream element is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1187">the min latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1188">the max latency of the upstream elements</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_async_enabled"
              c:identifier="gst_base_sink_set_async_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="917">Configures @sink to perform all state changes asynchronously. When async is
disabled, the sink will immediately go to PAUSED instead of waiting for a
preroll buffer. This feature is useful if the sink does not synchronize
against the clock or when it is dealing with sparse streams.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="260"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="919">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="920">the new async value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_sink_set_blocksize"
              glib:set-property="blocksize">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1369">Set the number of bytes that the sink will pull when it is operating in pull
mode.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="303"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1371">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1372">the blocksize in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_drop_out_of_segment"
              c:identifier="gst_base_sink_set_drop_out_of_segment"
              version="1.12">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="789">Configure @sink to drop buffers which are outside the current segment</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="236"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="791">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="drop_out_of_segment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="792">drop buffers outside the segment</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_last_sample_enabled"
              c:identifier="gst_base_sink_set_last_sample_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1122">Configures @sink to store the last received sample in the last-sample
property.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="279"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1124">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1125">the new enable-last-sample value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_bitrate"
              c:identifier="gst_base_sink_set_max_bitrate"
              glib:set-property="max-bitrate"
              version="1.2">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1456">Set the maximum amount of bits per second that the sink will render.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="319"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1458">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="max_bitrate" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1459">the max_bitrate in bits per second</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_max_lateness"
              c:identifier="gst_base_sink_set_max_lateness"
              glib:set-property="max-lateness">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="836">Sets the new max lateness value to @max_lateness. This value is
used to decide if a buffer should be dropped or not based on the
buffer timestamp and the current clock time. A value of -1 means
an unlimited time.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="244"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="838">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="max_lateness" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="839">the new max lateness value.</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_processing_deadline"
              c:identifier="gst_base_sink_set_processing_deadline"
              glib:set-property="processing-deadline"
              version="1.16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1500">Maximum amount of time (in nanoseconds) that the pipeline can take
for processing the buffer. This is added to the latency of live
pipelines.

This function is usually called by subclasses.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="326"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1502">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="processing_deadline" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1503">the new processing deadline in nanoseconds.</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_sink_set_qos_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="881">Configures @sink to send Quality-of-Service events upstream.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="252"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="883">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="884">the new qos value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_render_delay"
              c:identifier="gst_base_sink_set_render_delay"
              glib:set-property="render-delay">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1309">Set the render delay in @sink to @delay. The render delay is the time
between actual rendering of a buffer and its synchronisation time. Some
devices might delay media rendering which can be compensated for with this
function.

After calling this function, this sink will report additional latency and
other sinks will adjust their latency to delay the rendering of their media.

This function is usually called by subclasses.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="295"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1311">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="delay" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1312">the new delay</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_sync"
              c:identifier="gst_base_sink_set_sync"
              glib:set-property="sync">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="745">Configures @sink to synchronize on the clock or not. When
@sync is %FALSE, incoming samples will be played as fast as
possible. If @sync is %TRUE, the timestamps of the incoming
buffers will be used to schedule the exact render time of its
contents.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="228"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="747">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="sync" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="748">the new sync value.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_throttle_time"
              c:identifier="gst_base_sink_set_throttle_time"
              glib:set-property="throttle-time">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="1413">Set the time that will be inserted between rendered buffers. This
can be used to control the maximum buffers per second that the sink
will render.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="311"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1415">a #GstBaseSink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="throttle" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="1416">the throttle time in nanoseconds</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_ts_offset"
              c:identifier="gst_base_sink_set_ts_offset"
              glib:set-property="ts-offset">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="960">Adjust the synchronisation of @sink with @offset. A negative value will
render buffers earlier than their timestamp. A positive value will delay
rendering. This function can be used to fix playback of badly timestamped
buffers.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="268"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="962">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="963">the new offset</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait" c:identifier="gst_base_sink_wait">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="2563">This function will wait for preroll to complete and will then block until @time
is reached. It is usually called by subclasses that use their own internal
synchronisation but want to let some synchronization (like EOS) be handled
by the base class.

This function should only be called with the PREROLL_LOCK held (like when
receiving an EOS event in the ::event vmethod or when handling buffers in
::render).

The @time argument should be the running_time of when the timeout should happen
and will be adjusted with any latency and offset configured in the sink.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="335"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="2581">#GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2565">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2566">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2567">the jitter to be filled with time diff, or %NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_clock" c:identifier="gst_base_sink_wait_clock">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="2305">This function will block until @time is reached. It is usually called by
subclasses that use their own internal synchronisation.

If @time is not valid, no synchronisation is done and %GST_CLOCK_BADTIME is
returned. Likewise, if synchronisation is disabled in the element or there
is no clock, no synchronisation is done and %GST_CLOCK_BADTIME is returned.

This function should only be called with the PREROLL_LOCK held, like when
receiving an EOS event in the #GstBaseSinkClass::event vmethod or when
receiving a buffer in
the #GstBaseSinkClass::render vmethod.

The @time argument should be the running_time of when this method should
return and is not adjusted with any latency or offset configured in the
sink.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="332"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="2327">#GstClockReturn</doc>
          <type name="Gst.ClockReturn" c:type="GstClockReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2307">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2308">the running_time to be reached</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
          <parameter name="jitter"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2309">the jitter to be filled with time diff, or %NULL</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_preroll" c:identifier="gst_base_sink_wait_preroll">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="2405">If the #GstBaseSinkClass::render method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to render the remaining data.

If the #GstBaseSinkClass::render method can block on something else than
the clock, it must also be ready to unblock immediately on
the #GstBaseSinkClass::unlock method and cause the
#GstBaseSinkClass::render method to immediately call this function.
In this case, the subclass must be prepared to continue rendering where it
left off if this function returns %GST_FLOW_OK.

This function will block until a state change to PLAYING happens (in which
case this function returns %GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns %GST_FLOW_FLUSHING).

This function should only be called with the PREROLL_LOCK held, like in the
render function.</doc>
        <source-position filename="libs/gst/base/gstbasesink.h" line="223"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesink.c"
               line="2428">%GST_FLOW_OK if the preroll completed and processing can
continue. Any other return value should be returned from the render vmethod.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="sink" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesink.c"
                 line="2407">the sink</doc>
            <type name="BaseSink" c:type="GstBaseSink*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="async"
                writable="1"
                transfer-ownership="none"
                default-value="TRUE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="467">If set to %TRUE, the basesink will perform asynchronous state changes.
When set to %FALSE, the sink will not signal the parent when it prerolls.
Use this option when dealing with sparse streams or when synchronisation is
not required.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="blocksize"
                writable="1"
                transfer-ownership="none"
                setter="set_blocksize"
                getter="get_blocksize"
                default-value="4096">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="515">The amount of bytes to pull when operating in pull mode.</doc>
        <type name="guint" c:type="guint"/>
      </property>
      <property name="enable-last-sample"
                writable="1"
                transfer-ownership="none"
                default-value="TRUE">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="491">Enable the last-sample property. If %FALSE, basesink doesn't keep a
reference to the last buffer arrived and the last-sample property is always
set to %NULL. This can be useful if you need buffers to be released as soon
as possible, eg. if you're using a buffer pool.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="last-sample"
                transfer-ownership="none"
                getter="get_last_sample">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="504">The last buffer that arrived in the sink and was used for preroll or for
rendering. This property can be used to generate thumbnails. This property
can be %NULL when the sink has not yet received a buffer.</doc>
        <type name="Gst.Sample"/>
      </property>
      <property name="max-bitrate"
                version="1.2"
                writable="1"
                transfer-ownership="none"
                setter="set_max_bitrate"
                getter="get_max_bitrate"
                default-value="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="548">Control the maximum amount of bits that will be rendered per second.
Setting this property to a value bigger than 0 will make the sink delay
rendering of the buffers when it would exceed to max-bitrate.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="max-lateness"
                writable="1"
                transfer-ownership="none"
                setter="set_max_lateness"
                getter="get_max_lateness"
                default-value="-1">
        <type name="gint64" c:type="gint64"/>
      </property>
      <property name="processing-deadline"
                version="1.16"
                writable="1"
                transfer-ownership="none"
                setter="set_processing_deadline"
                getter="get_processing_deadline"
                default-value="20000000">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="562">Maximum amount of time (in nanoseconds) that the pipeline can take
for processing the buffer. This is added to the latency of live
pipelines.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="qos"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="render-delay"
                writable="1"
                transfer-ownership="none"
                setter="set_render_delay"
                getter="get_render_delay"
                default-value="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="525">The additional delay between synchronisation and actual rendering of the
media. This property will add additional latency to the device in order to
make other sinks compensate for the delay.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="stats"
                version="1.18"
                transfer-ownership="none"
                getter="get_stats">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="578">Various #GstBaseSink statistics. This property returns a #GstStructure
with name `application/x-gst-base-sink-stats` with the following fields:

- "average-rate"  G_TYPE_DOUBLE   average frame rate
- "dropped" G_TYPE_UINT64   Number of dropped frames
- "rendered" G_TYPE_UINT64   Number of rendered frames</doc>
        <type name="Gst.Structure"/>
      </property>
      <property name="sync"
                writable="1"
                transfer-ownership="none"
                setter="set_sync"
                getter="get_sync"
                default-value="TRUE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="throttle-time"
                writable="1"
                transfer-ownership="none"
                setter="set_throttle_time"
                getter="get_throttle_time"
                default-value="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="536">The time to insert between buffers. This property can be used to control
the maximum amount of buffers per second to render. Setting this property
to a value bigger than 0 will make the sink create THROTTLE QoS events.</doc>
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="ts-offset"
                writable="1"
                transfer-ownership="none"
                setter="set_ts_offset"
                getter="get_ts_offset"
                default-value="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.c"
             line="479">Controls the final synchronisation, a negative value will render the buffer
earlier while a positive value delays playback. This property can be
used to fix synchronisation in bad files.</doc>
        <type name="gint64" c:type="gint64"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="pad_mode">
        <type name="Gst.PadMode" c:type="GstPadMode"/>
      </field>
      <field name="offset">
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="can_activate_pull">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="preroll_lock">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="preroll_cond">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="eos">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="need_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_preroll">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="playing_async">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="have_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="clock_id" readable="0" private="1">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="sync" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="flushing" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="running" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="max_lateness" readable="0" private="1">
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseSinkPrivate" c:type="GstBaseSinkPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseSinkClass"
            c:type="GstBaseSinkClass"
            glib:is-gtype-struct-for="BaseSink">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesink.h"
           line="108">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @render method should be overridden to
output/present buffers.</doc>
      <source-position filename="libs/gst/base/gstbasesink.h" line="214"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesink.h"
             line="110">Element parent class</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <source-position filename="libs/gst/base/gstbasesink.h" line="160"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="filter"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <source-position filename="libs/gst/base/gstbasesink.h" line="162"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <source-position filename="libs/gst/base/gstbasesink.h" line="165"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="activate_pull">
        <callback name="activate_pull">
          <source-position filename="libs/gst/base/gstbasesink.h" line="167"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="active" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <source-position filename="libs/gst/base/gstbasesink.h" line="176"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstbasesink.h"
                   line="171">the start #GstClockTime</doc>
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstbasesink.h"
                   line="172">the end #GstClockTime</doc>
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <source-position filename="libs/gst/base/gstbasesink.h" line="180"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <source-position filename="libs/gst/base/gstbasesink.h" line="183"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <source-position filename="libs/gst/base/gstbasesink.h" line="184"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <source-position filename="libs/gst/base/gstbasesink.h" line="188"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <source-position filename="libs/gst/base/gstbasesink.h" line="192"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <source-position filename="libs/gst/base/gstbasesink.h" line="195"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <source-position filename="libs/gst/base/gstbasesink.h" line="198"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="wait_event">
        <callback name="wait_event">
          <source-position filename="libs/gst/base/gstbasesink.h" line="200"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare">
        <callback name="prepare">
          <source-position filename="libs/gst/base/gstbasesink.h" line="203"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_list">
        <callback name="prepare_list">
          <source-position filename="libs/gst/base/gstbasesink.h" line="204"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer_list" transfer-ownership="none">
              <type name="Gst.BufferList" c:type="GstBufferList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="preroll">
        <callback name="preroll">
          <source-position filename="libs/gst/base/gstbasesink.h" line="207"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render">
        <callback name="render">
          <source-position filename="libs/gst/base/gstbasesink.h" line="208"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="render_list">
        <callback name="render_list">
          <source-position filename="libs/gst/base/gstbasesink.h" line="210"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="sink" transfer-ownership="none">
              <type name="BaseSink" c:type="GstBaseSink*"/>
            </parameter>
            <parameter name="buffer_list" transfer-ownership="none">
              <type name="Gst.BufferList" c:type="GstBufferList*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseSinkPrivate"
            c:type="GstBaseSinkPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstbasesink.h" line="63"/>
    </record>
    <class name="BaseSrc"
           c:symbol-prefix="base_src"
           c:type="GstBaseSrc"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseSrc"
           glib:get-type="gst_base_src_get_type"
           glib:type-struct="BaseSrcClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesrc.c"
           line="23">This is a generic base class for source elements. The following
types of sources are supported:

  * random access sources like files
  * seekable sources
  * live sources

The source can be configured to operate in any #GstFormat with the
gst_base_src_set_format() method. The currently set format determines
the format of the internal #GstSegment and any %GST_EVENT_SEGMENT
events. The default format for #GstBaseSrc is %GST_FORMAT_BYTES.

#GstBaseSrc always supports push mode scheduling. If the following
conditions are met, it also supports pull mode scheduling:

  * The format is set to %GST_FORMAT_BYTES (default).
  * #GstBaseSrcClass::is_seekable returns %TRUE.

If all the conditions are met for operating in pull mode, #GstBaseSrc is
automatically seekable in push mode as well. The following conditions must
be met to make the element seekable in push mode when the format is not
%GST_FORMAT_BYTES:

* #GstBaseSrcClass::is_seekable returns %TRUE.
* #GstBaseSrcClass::query can convert all supported seek formats to the
  internal format as set with gst_base_src_set_format().
* #GstBaseSrcClass::do_seek is implemented, performs the seek and returns
   %TRUE.

When the element does not meet the requirements to operate in pull mode, the
offset and length in the #GstBaseSrcClass::create method should be ignored.
It is recommended to subclass #GstPushSrc instead, in this situation. If the
element can operate in pull mode but only with specific offsets and
lengths, it is allowed to generate an error when the wrong values are passed
to the #GstBaseSrcClass::create function.

#GstBaseSrc has support for live sources. Live sources are sources that when
paused discard data, such as audio or video capture devices. A typical live
source also produces data at a fixed rate and thus provides a clock to publish
this rate.
Use gst_base_src_set_live() to activate the live source mode.

A live source does not produce data in the PAUSED state. This means that the
#GstBaseSrcClass::create method will not be called in PAUSED but only in
PLAYING. To signal the pipeline that the element will not produce data, the
return value from the READY to PAUSED state will be
%GST_STATE_CHANGE_NO_PREROLL.

A typical live source will timestamp the buffers it creates with the
current running time of the pipeline. This is one reason why a live source
can only produce data in the PLAYING state, when the clock is actually
distributed and running.

Live sources that synchronize and block on the clock (an audio source, for
example) can use gst_base_src_wait_playing() when the
#GstBaseSrcClass::create function was interrupted by a state change to
PAUSED.

The #GstBaseSrcClass::get_times method can be used to implement pseudo-live
sources. It only makes sense to implement the #GstBaseSrcClass::get_times
function if the source is a live source. The #GstBaseSrcClass::get_times
function should return timestamps starting from 0, as if it were a non-live
source. The base class will make sure that the timestamps are transformed
into the current running_time. The base source will then wait for the
calculated running_time before pushing out the buffer.

For live sources, the base class will by default report a latency of 0.
For pseudo live sources, the base class will by default measure the difference
between the first buffer timestamp and the start time of get_times and will
report this value as the latency.
Subclasses should override the query function when this behaviour is not
acceptable.

There is only support in #GstBaseSrc for exactly one source pad, which
should be named "src". A source implementation (subclass of #GstBaseSrc)
should install a pad template in its class_init function, like so:
|[&lt;!-- language="C" --&gt;
static void
my_element_class_init (GstMyElementClass *klass)
{
  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
  // srctemplate should be a #GstStaticPadTemplate with direction
  // %GST_PAD_SRC and name "src"
  gst_element_class_add_static_pad_template (gstelement_class, &amp;srctemplate);

  gst_element_class_set_static_metadata (gstelement_class,
     "Source name",
     "Source",
     "My Source element",
     "The author &lt;my.sink@my.email&gt;");
}
]|

## Controlled shutdown of live sources in applications

Applications that record from a live source may want to stop recording
in a controlled way, so that the recording is stopped, but the data
already in the pipeline is processed to the end (remember that many live
sources would go on recording forever otherwise). For that to happen the
application needs to make the source stop recording and send an EOS
event down the pipeline. The application would then wait for an
EOS message posted on the pipeline's bus to know when all data has
been processed and the pipeline can safely be stopped.

An application may send an EOS event to a source element to make it
perform the EOS logic (send EOS event downstream or post a
%GST_MESSAGE_SEGMENT_DONE on the bus). This can typically be done
with the gst_element_send_event() function on the element or its parent bin.

After the EOS has been sent to the element, the application should wait for
an EOS message to be posted on the pipeline's bus. Once this EOS message is
received, it may safely shut down the entire pipeline.</doc>
      <source-position filename="libs/gst/base/gstbasesrc.h" line="274"/>
      <virtual-method name="alloc">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="259">Ask the subclass to allocate an output buffer with @offset and @size, the default
implementation will use the negotiated allocator.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="266"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="250">Ask the subclass to create a buffer with @offset and @size, the default
implementation will call alloc if no allocated @buf is provided and then call fill.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="257"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="200"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="do_seek">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="236"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="event">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="248"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="269"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="offset" transfer-ownership="none">
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="187">Called if, in negotiation, caps need fixating.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="195"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.h"
               line="193">the fixated caps</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="177">Called to get the caps to report.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="183"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="filter"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="217">Get the total size of the resource in the format set by
gst_base_src_set_format().</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="226"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.h"
               line="224">%TRUE if the size is available and has been set.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_times">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="206">Given @buffer, return @start and @end time when it should be pushed
out. The base class will sync on the clock using these times.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="214"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="start"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="end"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="is_seekable">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="229"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="negotiate" invoker="negotiate" version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="3464">Negotiates src pad caps with downstream elements.
Unmarks GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again
if #GstBaseSrcClass::negotiate fails.

Do not call this in the #GstBaseSrcClass::fill vmethod. Call this in
#GstBaseSrcClass::create or in #GstBaseSrcClass::alloc, _before_ any
buffer is allocated.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="185"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="3476">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3466">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_seek_segment">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="233"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="seek" transfer-ownership="none">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
          <parameter name="segment" transfer-ownership="none">
            <type name="Gst.Segment" c:type="GstSegment*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="245"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps" invoker="set_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="981">Set new caps on the basesrc source pad.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="197"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="988">%TRUE if the caps could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="983">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="984">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="203"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="204"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unlock">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="240"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unlock_stop">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="242"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="get_allocator" c:identifier="gst_base_src_get_allocator">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="4080">Lets #GstBaseSrc sub-classes to know the memory @allocator
used by the base class and its @params.

Unref the @allocator after usage.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="342"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4082">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4083">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4085">the #GstAllocationParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_blocksize"
              c:identifier="gst_base_src_get_blocksize"
              glib:get-property="blocksize">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="785">Get the number of bytes that @src will push out with each buffer.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="320"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="791">the number of bytes pushed with each buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="787">the source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_buffer_pool"
              c:identifier="gst_base_src_get_buffer_pool">
        <source-position filename="libs/gst/base/gstbasesrc.h" line="339"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="4062">the instance of the #GstBufferPool used
by the src; unref it after usage.</doc>
          <type name="Gst.BufferPool" c:type="GstBufferPool*"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4060">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_do_timestamp"
              c:identifier="gst_base_src_get_do_timestamp"
              glib:get-property="do-timestamp">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="829">Query if @src timestamps outgoing buffers based on the current running_time.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="326"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="835">%TRUE if the base class will automatically timestamp outgoing buffers.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="831">the source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_async" c:identifier="gst_base_src_is_async">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="695">Get the current async behaviour of @src. See also gst_base_src_set_async().</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="301"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="701">%TRUE if @src is operating in async mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="697">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_live" c:identifier="gst_base_src_is_live">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="586">Check if an element is in live mode.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="286"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="592">%TRUE if element is in live mode.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="588">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="negotiate"
              c:identifier="gst_base_src_negotiate"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="3464">Negotiates src pad caps with downstream elements.
Unmarks GST_PAD_FLAG_NEED_RECONFIGURE in any case. But marks it again
if #GstBaseSrcClass::negotiate fails.

Do not call this in the #GstBaseSrcClass::fill vmethod. Call this in
#GstBaseSrcClass::create or in #GstBaseSrcClass::alloc, _before_ any
buffer is allocated.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="304"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="3476">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3466">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="new_seamless_segment"
              c:identifier="gst_base_src_new_seamless_segment"
              deprecated="1"
              deprecated-version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="851">Prepare a new seamless segment for emission downstream. This function must
only be called by derived sub-classes, and only from the #GstBaseSrcClass::create function,
as the stream-lock needs to be held.

The format for the new segment will be the current format of the source, as
configured with gst_base_src_set_format()</doc>
        <doc-deprecated xml:space="preserve">Use gst_base_src_new_segment()</doc-deprecated>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="329"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="865">%TRUE if preparation of the seamless segment succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="853">The source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="start" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="854">The new start value for the segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="stop" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="855">Stop value for the new segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
          <parameter name="time" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="856">The new time value for the start of the new segment</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="new_segment"
              c:identifier="gst_base_src_new_segment"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="901">Prepare a new segment for emission downstream. This function must
only be called by derived sub-classes, and only from the #GstBaseSrcClass::create function,
as the stream-lock needs to be held.

The format for the @segment must be identical with the current format
of the source, as configured with gst_base_src_set_format().

The format of @src must not be %GST_FORMAT_UNDEFINED and the format
should be configured via gst_base_src_set_format() before calling this method.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="332"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="916">%TRUE if preparation of new segment succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="903">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="segment" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="904">a pointer to a #GstSegment</doc>
            <type name="Gst.Segment" c:type="const GstSegment*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_latency" c:identifier="gst_base_src_query_latency">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="718">Query the source for the latency parameters. @live will be %TRUE when @src is
configured as a live source. @min_latency and @max_latency will be set
to the difference between the running time and the timestamp of the first
buffer.

This function is mostly used by subclasses.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="313"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="732">%TRUE if the query succeeded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="720">the source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="live"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="721">if the source is live</doc>
            <type name="gboolean" c:type="gboolean*"/>
          </parameter>
          <parameter name="min_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="722">the min latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
          <parameter name="max_latency"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="723">the max latency of the source</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_async" c:identifier="gst_base_src_set_async">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="675">Configure async behaviour in @src, no state change will block. The open,
close, start, stop, play and pause virtual methods will be executed in a
different thread and are thus allowed to perform blocking operations. Any
blocking operation should be unblocked with the unlock vmethod.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="298"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="677">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="async" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="678">new async mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_automatic_eos"
              c:identifier="gst_base_src_set_automatic_eos"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="649">If @automatic_eos is %TRUE, @src will automatically go EOS if a buffer
after the total size is returned. By default this is %TRUE but sources
that can't return an authoritative size and only know that they're EOS
when trying to read more should set this to %FALSE.

When @src operates in %GST_FORMAT_TIME, #GstBaseSrc will send an EOS
when a buffer outside of the currently configured segment is pushed if
@automatic_eos is %TRUE. Since 1.16, if @automatic_eos is %FALSE an
EOS will be pushed only when the #GstBaseSrcClass::create implementation
returns %GST_FLOW_EOS.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="295"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="651">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="automatic_eos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="652">automatic eos</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_blocksize"
              c:identifier="gst_base_src_set_blocksize"
              glib:set-property="blocksize">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="767">Set the number of bytes that @src will push out with each buffer. When
@blocksize is set to -1, a default length will be used.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="317"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="769">the source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="blocksize" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="770">the new blocksize in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_caps" c:identifier="gst_base_src_set_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="981">Set new caps on the basesrc source pad.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="336"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="988">%TRUE if the caps could be set</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="983">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="984">a #GstCaps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_do_timestamp"
              c:identifier="gst_base_src_set_do_timestamp"
              glib:set-property="do-timestamp">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="808">Configure @src to automatically timestamp outgoing buffers based on the
current running_time of the pipeline. This property is mostly useful for live
sources.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="323"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="810">the source</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="811">enable or disable timestamping</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_dynamic_size"
              c:identifier="gst_base_src_set_dynamic_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="632">If not @dynamic, size is only updated when needed, such as when trying to
read past current tracked size.  Otherwise, size is checked for upon each
read.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="292"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="634">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="dynamic" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="635">new dynamic size mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_format" c:identifier="gst_base_src_set_format">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="608">Sets the default format of the source. This will be the format used
for sending SEGMENT events and for performing seeks.

If a format of GST_FORMAT_BYTES is set, the element will be able to
operate in pull mode if the #GstBaseSrcClass::is_seekable returns %TRUE.

This function must only be called in states &lt; %GST_STATE_PAUSED.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="289"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="610">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="format" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="611">the format to use</doc>
            <type name="Gst.Format" c:type="GstFormat"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_live" c:identifier="gst_base_src_set_live">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="562">If the element listens to a live source, @live should
be set to %TRUE.

A live source will not produce data in the PAUSED state and
will therefore not be able to participate in the PREROLL phase
of a pipeline. To signal this fact to the application and the
pipeline, the state change return value of the live source will
be GST_STATE_CHANGE_NO_PREROLL.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="283"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="564">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="live" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="565">new live-mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_complete" c:identifier="gst_base_src_start_complete">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="3568">Complete an asynchronous start operation. When the subclass overrides the
start method, it should call gst_base_src_start_complete() when the start
operation completes either from the same thread or from an asynchronous
helper thread.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="307"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="basesrc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3570">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="ret" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3571">a #GstFlowReturn</doc>
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </parameter>
        </parameters>
      </method>
      <method name="start_wait" c:identifier="gst_base_src_start_wait">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="3708">Wait until the start operation completes.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="310"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="3714">a #GstFlowReturn.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="basesrc" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3710">base source instance</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="submit_buffer_list"
              c:identifier="gst_base_src_submit_buffer_list"
              version="1.14">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="4108">Subclasses can call this from their create virtual method implementation
to submit a buffer list to be pushed out later. This is useful in
cases where the create function wants to produce multiple buffers to be
pushed out in one go in form of a #GstBufferList, which can reduce overhead
drastically, especially for packetised inputs (for data streams where
the packetisation/chunking is not important it is usually more efficient
to return larger buffers instead).

Subclasses that use this function from their create function must return
%GST_FLOW_OK and no buffer from their create virtual method implementation.
If a buffer is returned after a buffer list has also been submitted via this
function the behaviour is undefined.

Subclasses must only call this function once per create function call and
subclasses must only call this function when the source operates in push
mode.</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="347"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4110">a #GstBaseSrc</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
          <parameter name="buffer_list" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="4111">a #GstBufferList</doc>
            <type name="Gst.BufferList" c:type="GstBufferList*"/>
          </parameter>
        </parameters>
      </method>
      <method name="wait_playing" c:identifier="gst_base_src_wait_playing">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.c"
             line="532">If the #GstBaseSrcClass::create method performs its own synchronisation
against the clock it must unblock when going from PLAYING to the PAUSED state
and call this method before continuing to produce the remaining data.

This function will block until a state change to PLAYING happens (in which
case this function returns %GST_FLOW_OK) or the processing must be stopped due
to a state change to READY or a FLUSH event (in which case this function
returns %GST_FLOW_FLUSHING).</doc>
        <source-position filename="libs/gst/base/gstbasesrc.h" line="280"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasesrc.c"
               line="545">%GST_FLOW_OK if @src is PLAYING and processing can
continue. Any other return value should be returned from the create vmethod.</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="534">the src</doc>
            <type name="BaseSrc" c:type="GstBaseSrc*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="blocksize"
                writable="1"
                transfer-ownership="none"
                setter="set_blocksize"
                getter="get_blocksize"
                default-value="4096">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="do-timestamp"
                writable="1"
                transfer-ownership="none"
                setter="set_do_timestamp"
                getter="get_do_timestamp"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="num-buffers"
                writable="1"
                transfer-ownership="none"
                default-value="-1">
        <type name="gint" c:type="gint"/>
      </property>
      <property name="typefind"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="live_lock">
        <type name="GLib.Mutex" c:type="GMutex"/>
      </field>
      <field name="live_cond">
        <type name="GLib.Cond" c:type="GCond"/>
      </field>
      <field name="is_live">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="live_running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="blocksize">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="can_activate_push">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="random_access">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="clock_id">
        <type name="Gst.ClockID" c:type="GstClockID"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="need_newsegment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="num_buffers">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="num_buffers_left">
        <type name="gint" c:type="gint"/>
      </field>
      <field name="typefind">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="running">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="pending_seek">
        <type name="Gst.Event" c:type="GstEvent*"/>
      </field>
      <field name="priv">
        <type name="BaseSrcPrivate" c:type="GstBaseSrcPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseSrcClass"
            c:type="GstBaseSrcClass"
            glib:is-gtype-struct-for="BaseSrc">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesrc.h"
           line="117">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @create method should be overridden to produce
buffers.</doc>
      <source-position filename="libs/gst/base/gstbasesrc.h" line="274"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="119">Element parent class</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="get_caps">
        <callback name="get_caps">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="183"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="filter"
                       transfer-ownership="none"
                       nullable="1"
                       allow-none="1">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="negotiate">
        <callback name="negotiate">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="185"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="3476">%TRUE if the negotiation succeeded, else %FALSE.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstbasesrc.c"
                   line="3466">base source instance</doc>
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate">
        <callback name="fixate">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="195"/>
          <return-value transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.h"
                 line="193">the fixated caps</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="full">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="197"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.c"
                 line="988">%TRUE if the caps could be set</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstbasesrc.c"
                   line="983">a #GstBaseSrc</doc>
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <doc xml:space="preserve"
                   filename="libs/gst/base/gstbasesrc.c"
                   line="984">a #GstCaps</doc>
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="200"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="203"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="204"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_times">
        <callback name="get_times">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="214"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="start"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
            <parameter name="end"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="Gst.ClockTime" c:type="GstClockTime*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_size">
        <callback name="get_size">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="226"/>
          <return-value transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasesrc.h"
                 line="224">%TRUE if the size is available and has been set.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="size"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="guint64" c:type="guint64*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="is_seekable">
        <callback name="is_seekable">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="229"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_seek_segment">
        <callback name="prepare_seek_segment">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="233"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="seek" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="do_seek">
        <callback name="do_seek">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="236"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="segment" transfer-ownership="none">
              <type name="Gst.Segment" c:type="GstSegment*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock">
        <callback name="unlock">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="240"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unlock_stop">
        <callback name="unlock_stop">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="242"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="245"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="event">
        <callback name="event">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="248"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="event" transfer-ownership="none">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="create">
        <callback name="create">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="257"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="buf"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="alloc">
        <callback name="alloc">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="266"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="buf"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       nullable="1">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill">
        <callback name="fill">
          <source-position filename="libs/gst/base/gstbasesrc.h" line="269"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="BaseSrc" c:type="GstBaseSrc*"/>
            </parameter>
            <parameter name="offset" transfer-ownership="none">
              <type name="guint64" c:type="guint64"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="guint" c:type="guint"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="20">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <bitfield name="BaseSrcFlags" c:type="GstBaseSrcFlags">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasesrc.h"
           line="40">The #GstElement flags that a basesrc element may have.</doc>
      <source-position filename="libs/gst/base/gstbasesrc.h" line="53"/>
      <member name="starting"
              value="16384"
              c:identifier="GST_BASE_SRC_FLAG_STARTING">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="42">has source is starting</doc>
      </member>
      <member name="started"
              value="32768"
              c:identifier="GST_BASE_SRC_FLAG_STARTED">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="43">has source been started</doc>
      </member>
      <member name="last"
              value="1048576"
              c:identifier="GST_BASE_SRC_FLAG_LAST">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasesrc.h"
             line="44">offset to define more flags</doc>
      </member>
    </bitfield>
    <record name="BaseSrcPrivate"
            c:type="GstBaseSrcPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="60"/>
    </record>
    <class name="BaseTransform"
           c:symbol-prefix="base_transform"
           c:type="GstBaseTransform"
           parent="Gst.Element"
           abstract="1"
           glib:type-name="GstBaseTransform"
           glib:get-type="gst_base_transform_get_type"
           glib:type-struct="BaseTransformClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.c"
           line="24">This base class is for filter elements that process data. Elements
that are suitable for implementation using #GstBaseTransform are ones
where the size and caps of the output is known entirely from the input
caps and buffer sizes. These include elements that directly transform
one buffer into another, modify the contents of a buffer in-place, as
well as elements that collate multiple input buffers into one output buffer,
or that expand one input buffer into multiple output buffers. See below
for more concrete use cases.

It provides for:

* one sinkpad and one srcpad
* Possible formats on sink and source pad implemented
  with custom transform_caps function. By default uses
  same format on sink and source.

* Handles state changes
* Does flushing
* Push mode
* Pull mode if the sub-class transform can operate on arbitrary data

# Use Cases

## Passthrough mode

  * Element has no interest in modifying the buffer. It may want to inspect it,
    in which case the element should have a transform_ip function. If there
    is no transform_ip function in passthrough mode, the buffer is pushed
    intact.

  * The #GstBaseTransformClass.passthrough_on_same_caps variable
    will automatically set/unset passthrough based on whether the
    element negotiates the same caps on both pads.

  * #GstBaseTransformClass.passthrough_on_same_caps on an element that
    doesn't implement a transform_caps function is useful for elements that
    only inspect data (such as level)

  * Example elements

    * Level
    * Videoscale, audioconvert, videoconvert, audioresample in certain modes.

## Modifications in-place - input buffer and output buffer are the same thing.

* The element must implement a transform_ip function.
* Output buffer size must &lt;= input buffer size
* If the always_in_place flag is set, non-writable buffers will be copied
  and passed to the transform_ip function, otherwise a new buffer will be
  created and the transform function called.

* Incoming writable buffers will be passed to the transform_ip function
  immediately.
* only implementing transform_ip and not transform implies always_in_place = %TRUE

  * Example elements:
    * Volume
    * Audioconvert in certain modes (signed/unsigned conversion)
    * videoconvert in certain modes (endianness swapping)

## Modifications only to the caps/metadata of a buffer

* The element does not require writable data, but non-writable buffers
  should be subbuffered so that the meta-information can be replaced.

* Elements wishing to operate in this mode should replace the
  prepare_output_buffer method to create subbuffers of the input buffer
  and set always_in_place to %TRUE

* Example elements
  * Capsfilter when setting caps on outgoing buffers that have
    none.
  * identity when it is going to re-timestamp buffers by
    datarate.

## Normal mode
  * always_in_place flag is not set, or there is no transform_ip function
  * Element will receive an input buffer and output buffer to operate on.
  * Output buffer is allocated by calling the prepare_output_buffer function.
  * Example elements:
    * Videoscale, videoconvert, audioconvert when doing
    scaling/conversions

## Special output buffer allocations
  * Elements which need to do special allocation of their output buffers
    beyond allocating output buffers via the negotiated allocator or
    buffer pool should implement the prepare_output_buffer method.

  * Example elements:
    * efence

# Sub-class settable flags on GstBaseTransform

* passthrough

  * Implies that in the current configuration, the sub-class is not interested in modifying the buffers.
  * Elements which are always in passthrough mode whenever the same caps has been negotiated on both pads can set the class variable passthrough_on_same_caps to have this behaviour automatically.

* always_in_place
  * Determines whether a non-writable buffer will be copied before passing
    to the transform_ip function.

  * Implied %TRUE if no transform function is implemented.
  * Implied %FALSE if ONLY transform function is implemented.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="314"/>
      <virtual-method name="accept_caps">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="236"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="before_transform">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="297"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="copy_metadata">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="292"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="decide_allocation">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="244"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="filter_meta">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="245"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
          <parameter name="api" transfer-ownership="none">
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="params" transfer-ownership="none">
            <type name="Gst.Structure" c:type="const GstStructure*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fixate_caps">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="233"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="generate_output">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="310"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="outbuf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="get_unit_size">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="265"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="prepare_output_buffer">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="288"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="input" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="propose_allocation">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="249"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="decide_query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="query">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="240"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="set_caps">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="238"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="incaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="outcaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="sink_event">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="277"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="full">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="src_event">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="282"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="event" transfer-ownership="full">
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="start">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="269"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="stop">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="270"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="submit_input_buffer">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="304"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="is_discont" transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="input" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="300"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_caps">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="226"/>
        <return-value transfer-ownership="full">
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="filter" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_ip">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="302"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_meta">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="294"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="outbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="meta" transfer-ownership="none">
            <type name="Gst.Meta" c:type="GstMeta*"/>
          </parameter>
          <parameter name="inbuf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="transform_size">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="256"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="direction" transfer-ownership="none">
            <type name="Gst.PadDirection" c:type="GstPadDirection"/>
          </parameter>
          <parameter name="caps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="othercaps" transfer-ownership="none">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
          <parameter name="othersize"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <type name="gsize" c:type="gsize*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="get_allocator"
              c:identifier="gst_base_transform_get_allocator">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2879">Lets #GstBaseTransform sub-classes know the memory @allocator
used by the base class and its @params.

Unref the @allocator after use.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="352"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2881">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="allocator"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2882">the #GstAllocator
used</doc>
            <type name="Gst.Allocator" c:type="GstAllocator**"/>
          </parameter>
          <parameter name="params"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2884">the #GstAllocationParams of @allocator</doc>
            <type name="Gst.AllocationParams" c:type="GstAllocationParams*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_buffer_pool"
              c:identifier="gst_base_transform_get_buffer_pool">
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="349"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="2865">the instance of the #GstBufferPool used
by @trans; free it after use</doc>
          <type name="Gst.BufferPool" c:type="GstBufferPool*"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2863">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_in_place" c:identifier="gst_base_transform_is_in_place">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2670">See if @trans is configured as a in_place transform.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="329"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="2676">%TRUE if the transform is configured in in_place mode.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2672">the #GstBaseTransform to query</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_passthrough"
              c:identifier="gst_base_transform_is_passthrough">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2606">See if @trans is configured as a passthrough transform.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="323"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="2612">%TRUE if the transform is configured in passthrough mode.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2608">the #GstBaseTransform to query</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_qos_enabled"
              c:identifier="gst_base_transform_is_qos_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2746">Queries if the transform will handle QoS.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="340"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="2752">%TRUE if QoS is enabled.

MT safe.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2748">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reconfigure"
              c:identifier="gst_base_transform_reconfigure"
              version="1.18">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="1448">Negotiates src pad caps with downstream elements if the source pad is
marked as needing reconfiguring. Unmarks GST_PAD_FLAG_NEED_RECONFIGURE in
any case. But marks it again if negotiation fails.

Do not call this in the #GstBaseTransformClass::transform or
#GstBaseTransformClass::transform_ip vmethod. Call this in
#GstBaseTransformClass::submit_input_buffer,
#GstBaseTransformClass::prepare_output_buffer or in
#GstBaseTransformClass::generate_output _before_ any output buffer is
allocated.

It will be default be called when handling an ALLOCATION query or at the
very beginning of the default #GstBaseTransformClass::submit_input_buffer
implementation.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="366"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="1467">%TRUE if the negotiation succeeded, else %FALSE.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="1450">the #GstBaseTransform to set</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reconfigure_sink"
              c:identifier="gst_base_transform_reconfigure_sink">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2826">Instructs @trans to request renegotiation upstream. This function is
typically called after properties on the transform were set that
influence the input format.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="356"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2828">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reconfigure_src"
              c:identifier="gst_base_transform_reconfigure_src">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2845">Instructs @trans to renegotiate a new downstream transform on the next
buffer. This function is typically called after properties on the transform
were set that influence the output format.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="359"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2847">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_gap_aware"
              c:identifier="gst_base_transform_set_gap_aware">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2770">If @gap_aware is %FALSE (the default), output buffers will have the
%GST_BUFFER_FLAG_GAP flag unset.

If set to %TRUE, the element must handle output buffers with this flag set
correctly, i.e. it can assume that the buffer contains neutral data but must
unset the flag if the output is no neutral data.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="343"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2772">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="gap_aware" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2773">New state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_in_place"
              c:identifier="gst_base_transform_set_in_place">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2630">Determines whether a non-writable buffer will be copied before passing
to the transform_ip function.

  * Always %TRUE if no transform function is implemented.
  * Always %FALSE if ONLY transform function is implemented.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="326"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2632">the #GstBaseTransform to modify</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="in_place" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2633">Boolean value indicating that we would like to operate
on in_place buffers.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_passthrough"
              c:identifier="gst_base_transform_set_passthrough">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2570">Set passthrough mode for this filter by default. This is mostly
useful for filters that do not care about negotiation.

Always %TRUE for filters which don't implement either a transform
or transform_ip or generate_output method.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="320"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2572">the #GstBaseTransform to set</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="passthrough" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2573">boolean indicating passthrough mode.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_prefer_passthrough"
              c:identifier="gst_base_transform_set_prefer_passthrough"
              version="1.0.1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2795">If @prefer_passthrough is %TRUE (the default), @trans will check and
prefer passthrough caps from the list of caps returned by the
transform_caps vmethod.

If set to %FALSE, the element must order the caps returned from the
transform_caps function in such a way that the preferred format is
first in the list. This can be interesting for transforms that can do
passthrough transforms but prefer to do something else, like a
capsfilter.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="346"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2797">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="prefer_passthrough" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2798">New state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_qos_enabled"
              c:identifier="gst_base_transform_set_qos_enabled">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2725">Enable or disable QoS handling in the transform.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="337"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2727">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="enabled" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2728">new state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_qos" c:identifier="gst_base_transform_update_qos">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2694">Set the QoS parameters in the transform. This function is called internally
when a QOS event is received but subclasses can provide custom information
when needed.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="332"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2696">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="proportion" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2697">the proportion</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
          <parameter name="diff" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2698">the diff against the clock</doc>
            <type name="Gst.ClockTimeDiff" c:type="GstClockTimeDiff"/>
          </parameter>
          <parameter name="timestamp" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2699">the timestamp of the buffer generating the QoS expressed in
running_time.</doc>
            <type name="Gst.ClockTime" c:type="GstClockTime"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_src_caps"
              c:identifier="gst_base_transform_update_src_caps"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.c"
             line="2905">Updates the srcpad caps and sends the caps downstream. This function
can be used by subclasses when they have already negotiated their caps
but found a change in them (or computed new information). This way,
they can notify downstream about that change without losing any
buffer.</doc>
        <source-position filename="libs/gst/base/gstbasetransform.h"
                         line="362"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbasetransform.c"
               line="2917">%TRUE if the caps could be sent downstream %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="trans" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2907">a #GstBaseTransform</doc>
            <type name="BaseTransform" c:type="GstBaseTransform*"/>
          </instance-parameter>
          <parameter name="updated_caps" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbasetransform.c"
                 line="2908">An updated version of the srcpad caps to be pushed
downstream</doc>
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </parameter>
        </parameters>
      </method>
      <property name="qos"
                writable="1"
                transfer-ownership="none"
                default-value="FALSE">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <field name="element">
        <type name="Gst.Element" c:type="GstElement"/>
      </field>
      <field name="sinkpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="srcpad">
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="have_segment">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="segment">
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="queued_buf">
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="BaseTransformPrivate" c:type="GstBaseTransformPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="19">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="BaseTransformClass"
            c:type="GstBaseTransformClass"
            glib:is-gtype-struct-for="BaseTransform">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbasetransform.h"
           line="104">Subclasses can override any of the available virtual methods or not, as
needed. At minimum either @transform or @transform_ip need to be overridden.
If the element can overwrite the input data with the results (data is of the
same type and quantity) it should provide @transform_ip.</doc>
      <source-position filename="libs/gst/base/gstbasetransform.h" line="314"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.h"
             line="106">Element parent class</doc>
        <type name="Gst.ElementClass" c:type="GstElementClass"/>
      </field>
      <field name="passthrough_on_same_caps">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.h"
             line="107">If set to %TRUE, passthrough mode will be
                           automatically enabled if the caps are the same.
                           Set to %FALSE by default.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="transform_ip_on_passthrough">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbasetransform.h"
             line="110">If set to %TRUE, @transform_ip will be called in
                          passthrough mode. The passed buffer might not be
                          writable. When %FALSE, neither @transform nor
                          @transform_ip will be called in passthrough mode.
                          Set to %TRUE by default.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="transform_caps">
        <callback name="transform_caps">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="226"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="filter" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fixate_caps">
        <callback name="fixate_caps">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="233"/>
          <return-value transfer-ownership="full">
            <type name="Gst.Caps" c:type="GstCaps*"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="full">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="accept_caps">
        <callback name="accept_caps">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="236"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="set_caps">
        <callback name="set_caps">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="238"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="incaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="outcaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="query">
        <callback name="query">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="240"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="decide_allocation">
        <callback name="decide_allocation">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="244"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="filter_meta">
        <callback name="filter_meta">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="245"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
            <parameter name="api" transfer-ownership="none">
              <type name="GType" c:type="GType"/>
            </parameter>
            <parameter name="params" transfer-ownership="none">
              <type name="Gst.Structure" c:type="const GstStructure*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="propose_allocation">
        <callback name="propose_allocation">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="249"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="decide_query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
            <parameter name="query" transfer-ownership="none">
              <type name="Gst.Query" c:type="GstQuery*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_size">
        <callback name="transform_size">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="256"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="direction" transfer-ownership="none">
              <type name="Gst.PadDirection" c:type="GstPadDirection"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size" transfer-ownership="none">
              <type name="gsize" c:type="gsize"/>
            </parameter>
            <parameter name="othercaps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="othersize"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="get_unit_size">
        <callback name="get_unit_size">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="265"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="caps" transfer-ownership="none">
              <type name="Gst.Caps" c:type="GstCaps*"/>
            </parameter>
            <parameter name="size"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="gsize" c:type="gsize*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="start">
        <callback name="start">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="269"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="stop">
        <callback name="stop">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="270"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="sink_event">
        <callback name="sink_event">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="277"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="full">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="src_event">
        <callback name="src_event">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="282"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="event" transfer-ownership="full">
              <type name="Gst.Event" c:type="GstEvent*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="prepare_output_buffer">
        <callback name="prepare_output_buffer">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="288"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="copy_metadata">
        <callback name="copy_metadata">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="292"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_meta">
        <callback name="transform_meta">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="294"/>
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="meta" transfer-ownership="none">
              <type name="Gst.Meta" c:type="GstMeta*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="before_transform">
        <callback name="before_transform">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="297"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buffer" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform">
        <callback name="transform">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="300"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="inbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
            <parameter name="outbuf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="transform_ip">
        <callback name="transform_ip">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="302"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="submit_input_buffer">
        <callback name="submit_input_buffer">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="304"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="is_discont" transfer-ownership="none">
              <type name="gboolean" c:type="gboolean"/>
            </parameter>
            <parameter name="input" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="generate_output">
        <callback name="generate_output">
          <source-position filename="libs/gst/base/gstbasetransform.h"
                           line="310"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="trans" transfer-ownership="none">
              <type name="BaseTransform" c:type="GstBaseTransform*"/>
            </parameter>
            <parameter name="outbuf"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="18">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="BaseTransformPrivate"
            c:type="GstBaseTransformPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="76"/>
    </record>
    <record name="BitReader" c:type="GstBitReader">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitreader.c"
           line="30">#GstBitReader provides a bit reader that can read any number of bits
from a memory buffer. It provides functions for reading any number of bits
into 8, 16, 32 and 64 bit variables.</doc>
      <source-position filename="libs/gst/base/gstbitreader.h" line="52"/>
      <field name="data" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.h"
             line="35">Data from which the bit reader will
  read</doc>
        <array length="1" zero-terminated="0" c:type="const guint8*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.h"
             line="37">Size of @data in bytes</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.h"
             line="38">Current byte position</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bit" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.h"
             line="39">Bit position in the current byte</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="free" c:identifier="gst_bit_reader_free">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="74">Frees a #GstBitReader instance, which was previously allocated by
gst_bit_reader_new().</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="76">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_bits_uint16"
              c:identifier="gst_bit_reader_get_bits_uint16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="214">Read @nbits bits into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="85"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="222">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="216">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="217">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="218">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint32"
              c:identifier="gst_bit_reader_get_bits_uint32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="225">Read @nbits bits into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="88"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="233">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="227">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="228">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="229">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint64"
              c:identifier="gst_bit_reader_get_bits_uint64">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="236">Read @nbits bits into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="91"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="244">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="238">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="239">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="240">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_bits_uint8"
              c:identifier="gst_bit_reader_get_bits_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="203">Read @nbits bits into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="82"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="211">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="205">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="206">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="207">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="gst_bit_reader_get_pos">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="132">Returns the current position of a #GstBitReader instance in bits.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="67"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="138">The current position of @reader in bits.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="134">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remaining" c:identifier="gst_bit_reader_get_remaining">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="146">Returns the remaining number of bits of a #GstBitReader instance.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="70"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="152">The remaining number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="148">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="gst_bit_reader_get_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="160">Returns the total number of bits of a #GstBitReader instance.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="73"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="166">The total number of bits of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="162">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_bit_reader_init">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="89">Initializes a #GstBitReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="61"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="91">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="92">data from which the bit reader should read</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="93">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint16"
              c:identifier="gst_bit_reader_peek_bits_uint16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="258">Read @nbits bits into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="97"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="266">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="260">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="261">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="262">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint32"
              c:identifier="gst_bit_reader_peek_bits_uint32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="269">Read @nbits bits into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="100"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="277">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="271">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="272">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="273">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint64"
              c:identifier="gst_bit_reader_peek_bits_uint64">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="280">Read @nbits bits into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="288">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="282">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="283">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="284">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_bits_uint8"
              c:identifier="gst_bit_reader_peek_bits_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="247">Read @nbits bits into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="94"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="255">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="249">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="const GstBitReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="250">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="251">number of bits to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="gst_bit_reader_set_pos">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="108">Sets the new position of a #GstBitReader instance to @pos in bits.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="64"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="115">%TRUE if the position could be set successfully, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="110">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="111">The new position in bits</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip" c:identifier="gst_bit_reader_skip">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="174">Skips @nbits bits of the #GstBitReader instance.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="76"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="181">%TRUE if @nbits bits could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="176">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="177">the number of bits to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_to_byte" c:identifier="gst_bit_reader_skip_to_byte">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="189">Skips until the next byte.</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="79"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="195">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="191">a #GstBitReader instance</doc>
            <type name="BitReader" c:type="GstBitReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_bit_reader_new"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="51">Create a new #GstBitReader instance, which will read from @data.

Free-function: gst_bit_reader_free</doc>
        <source-position filename="libs/gst/base/gstbitreader.h" line="55"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="61">a new #GstBitReader instance</doc>
          <type name="BitReader" c:type="GstBitReader*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="53">Data from which the #GstBitReader
  should read</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitreader.c"
                 line="55">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="BitWriter" c:type="GstBitWriter" version="1.16">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitwriter.c"
           line="32">#GstBitWriter provides a bit writer that can write any number of
bits into a memory buffer. It provides functions for writing any
number of bits into 8, 16, 32 and 64 bit variables.</doc>
      <source-position filename="libs/gst/base/gstbitwriter.h" line="58"/>
      <field name="data" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.h"
             line="41">Allocated @data for bit writer to write</doc>
        <type name="guint8" c:type="guint8*"/>
      </field>
      <field name="bit_size" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.h"
             line="42">Size of written @data in bits</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bit_capacity" readable="0" private="1">
        <type name="guint" c:type="guint"/>
      </field>
      <field name="auto_grow" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="owned" readable="0" private="1">
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="align_bytes" c:identifier="gst_bit_writer_align_bytes">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="435">Write trailing bit to align last byte of @data. @trailing_bit can
only be 1 or 0.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="132"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="443">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="437">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="trailing_bit" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="438">trailing bits of last byte, 0 or 1</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_bit_writer_free">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="251">Frees @bitwriter and the allocated data inside.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="71"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="253">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_and_get_buffer"
              c:identifier="gst_bit_writer_free_and_get_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="291">Frees @bitwriter without destroying the internal data, which is
returned as #GstBuffer.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="77"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="300">a new allocated #GstBuffer wrapping the
    data inside. gst_buffer_unref() after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="293">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_and_get_data"
              c:identifier="gst_bit_writer_free_and_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="266">Frees @bitwriter without destroying the internal data, which is
returned.

Free-function: g_free</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="74"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="275">the current data. g_free() after
    usage.</doc>
          <array zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="268">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="gst_bit_writer_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="330">Get written data pointer</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="103"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="336">data pointer</doc>
          <array zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="332">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="const GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remaining" c:identifier="gst_bit_writer_get_remaining">
        <source-position filename="libs/gst/base/gstbitwriter.h" line="109"/>
        <return-value transfer-ownership="none">
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <type name="BitWriter" c:type="const GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="gst_bit_writer_get_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="316">Get size of written @data</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="100"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="322">size of bits written in @data</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="318">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="const GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init"
              c:identifier="gst_bit_writer_init"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="105">Initializes @bitwriter to an empty instance.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="107">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_with_data"
              c:identifier="gst_bit_writer_init_with_data"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="143">Initializes @bitwriter with the given memory area @data. IF
@initialized is %TRUE it is possible to read @size bits from the
#GstBitWriter from the beginning.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="87"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="145">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="146">Memory area for writing</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="147">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="148">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_size"
              c:identifier="gst_bit_writer_init_with_size"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="121">Initializes a #GstBitWriter instance and allocates the given data
@size.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="83"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="123">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="124">the size on bytes to allocate for data</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="125">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_bits_uint16"
              c:identifier="gst_bit_writer_put_bits_uint16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="370">Write @nbits bits of @value to #GstBitWriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="116"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="378">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="372">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="373">value of #guint16 to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="374">number of bits to write</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_bits_uint32"
              c:identifier="gst_bit_writer_put_bits_uint32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="381">Write @nbits bits of @value to #GstBitWriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="120"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="389">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="383">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="384">value of #guint32 to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="385">number of bits to write</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_bits_uint64"
              c:identifier="gst_bit_writer_put_bits_uint64">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="392">Write @nbits bits of @value to #GstBitWriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="124"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="400">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="394">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="395">value of #guint64 to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="396">number of bits to write</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_bits_uint8"
              c:identifier="gst_bit_writer_put_bits_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="359">Write @nbits bits of @value to #GstBitWriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="112"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="367">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="361">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="362">value of #guint8 to write</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="nbits" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="363">number of bits to write</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_bytes" c:identifier="gst_bit_writer_put_bytes">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="418">Write @nbytes bytes of @data to #GstBitWriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="128"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="426">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="420">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="421">pointer of data to write</doc>
            <array zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="422">number of bytes to write</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_bit_writer_reset">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="169">Resets @bitwriter and frees the data if it's owned by @bitwriter.</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="91"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="171">#GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_and_get_buffer"
              c:identifier="gst_bit_writer_reset_and_get_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="211">Resets @bitwriter and returns the current data as #GstBuffer.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="97"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="219">a new allocated #GstBuffer wrapping the
    current data. gst_buffer_unref() after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="213">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_and_get_data"
              c:identifier="gst_bit_writer_reset_and_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="185">Resets @bitwriter and returns the current data.

Free-function: g_free</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="94"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="193">the current data. g_free() after
    usage.</doc>
          <array zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="187">a #GstBitWriter instance</doc>
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="gst_bit_writer_set_pos">
        <source-position filename="libs/gst/base/gstbitwriter.h" line="106"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="bitwriter" transfer-ownership="none">
            <type name="BitWriter" c:type="GstBitWriter*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_bit_writer_new"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="42">Creates a new, empty #GstBitWriter instance.

Free-function: gst_bit_writer_free</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="61"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="49">a new, empty #GstByteWriter instance</doc>
          <type name="BitWriter" c:type="GstBitWriter*"/>
        </return-value>
      </function>
      <function name="new_with_data"
                c:identifier="gst_bit_writer_new_with_data"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="81">Creates a new #GstBitWriter instance with the given memory area. If
@initialized is %TRUE it is possible to read @size bits from the
#GstBitWriter from the beginning.

Free-function: gst_bit_writer_free</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="67"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="93">a new #GstBitWriter instance</doc>
          <type name="BitWriter" c:type="GstBitWriter*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="83">Memory area for writing</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="84">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="85">if %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_size"
                c:identifier="gst_bit_writer_new_with_size"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="61">Creates a #GstBitWriter instance with the given initial data size.

Free-function: gst_bit_writer_free</doc>
        <source-position filename="libs/gst/base/gstbitwriter.h" line="64"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="70">a new #GstBitWriter instance</doc>
          <type name="BitWriter" c:type="GstBitWriter*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="63">Initial size of data in bytes</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbitwriter.c"
                 line="64">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ByteReader" c:type="GstByteReader">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytereader.c"
           line="32">#GstByteReader provides a byte reader that can read different integer and
floating point types from a memory buffer. It provides functions for reading
signed/unsigned, little/big endian integers of 8, 16, 24, 32 and 64 bits
and functions for reading little/big endian floating points numbers of
32 and 64 bits. It also provides functions to read NUL-terminated strings
in various character encodings.</doc>
      <source-position filename="libs/gst/base/gstbytereader.h" line="49"/>
      <field name="data" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.h"
             line="34">Data from which the bit reader will
  read</doc>
        <array length="1" zero-terminated="0" c:type="const guint8*">
          <type name="guint8" c:type="guint8"/>
        </array>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.h"
             line="36">Size of @data in bytes</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="byte" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.h"
             line="37">Current byte position</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="dup_data" c:identifier="gst_byte_reader_dup_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="844">Free-function: g_free

Returns a newly-allocated copy of the current data
position if at least @size bytes are left and
updates the current position. Free with g_free() when no longer needed.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="857">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="846">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="847">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="848">address of a
    #guint8 pointer variable in which to store the result</doc>
            <array length="0" zero-terminated="0" c:type="guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf16"
              c:identifier="gst_byte_reader_dup_string_utf16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1251">Free-function: g_free

Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-16 string in the data (this could be an empty string
as well), and advances the current position.

No input checking for valid UTF-16 is done. This function is endianness
agnostic - you should not assume the UTF-16 characters are in host
endianness.

This function will fail if no NUL-terminator was found in in the data.

Note: there is no peek or get variant of this function to ensure correct
byte alignment of the UTF-16 string.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="231"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1272">%TRUE if a string could be read, %FALSE otherwise. The
    string put into @str must be freed with g_free() when no longer needed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1253">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1254">address of a
    #guint16 pointer variable in which to store the result</doc>
            <array c:type="guint16**">
              <type name="guint16" c:type="guint16*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf32"
              c:identifier="gst_byte_reader_dup_string_utf32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1277">Free-function: g_free

Returns a newly-allocated copy of the current data position if there is
a NUL-terminated UTF-32 string in the data (this could be an empty string
as well), and advances the current position.

No input checking for valid UTF-32 is done. This function is endianness
agnostic - you should not assume the UTF-32 characters are in host
endianness.

This function will fail if no NUL-terminator was found in in the data.

Note: there is no peek or get variant of this function to ensure correct
byte alignment of the UTF-32 string.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="234"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1298">%TRUE if a string could be read, %FALSE otherwise. The
    string put into @str must be freed with g_free() when no longer needed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1279">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1280">address of a
    #guint32 pointer variable in which to store the result</doc>
            <array c:type="guint32**">
              <type name="guint32" c:type="guint32*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="dup_string_utf8"
              c:identifier="gst_byte_reader_dup_string_utf8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1231">Free-function: g_free

FIXME:Reads (copies) a NUL-terminated string in the #GstByteReader instance,
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="228"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1246">%TRUE if a string could be read into @str, %FALSE otherwise. The
    string put into @str must be freed with g_free() when no longer needed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1233">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1234">address of a
    #gchar pointer variable in which to store the result</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_byte_reader_free">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="110">Frees a #GstByteReader instance, which was previously allocated by
gst_byte_reader_new().</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="55"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="112">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data" c:identifier="gst_byte_reader_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="804">Returns a constant pointer to the current data
position if at least @size bytes are left and
updates the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="219"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="815">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="806">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="807">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="808">address of a
    #guint8 pointer variable in which to store the result</doc>
            <array length="0" zero-terminated="0" c:type="const guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_be"
              c:identifier="gst_byte_reader_get_float32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="731">Read a 32 bit big endian floating point value into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="195"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="739">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="733">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="734">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float32_le"
              c:identifier="gst_byte_reader_get_float32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="709">Read a 32 bit little endian floating point value into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="192"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="717">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="711">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="712">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_be"
              c:identifier="gst_byte_reader_get_float64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="775">Read a 64 bit big endian floating point value into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="201"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="783">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="777">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="778">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_float64_le"
              c:identifier="gst_byte_reader_get_float64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="753">Read a 64 bit little endian floating point value into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="198"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="761">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="755">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="756">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_be" c:identifier="gst_byte_reader_get_int16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="373">Read a signed 16 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="99"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="381">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="375">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="376">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int16_le" c:identifier="gst_byte_reader_get_int16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="329">Read a signed 16 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="93"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="337">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="331">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="332">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_be" c:identifier="gst_byte_reader_get_int24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="461">Read a signed 24 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="111"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="469">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="463">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="464">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int24_le" c:identifier="gst_byte_reader_get_int24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="417">Read a signed 24 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="105"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="425">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="419">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="420">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_be" c:identifier="gst_byte_reader_get_int32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="550">Read a signed 32 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="123"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="558">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="552">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="553">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int32_le" c:identifier="gst_byte_reader_get_int32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="506">Read a signed 32 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="117"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="514">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="508">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="509">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_be" c:identifier="gst_byte_reader_get_int64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="638">Read a signed 64 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="135"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="646">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="640">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="641">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int64_le" c:identifier="gst_byte_reader_get_int64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="594">Read a signed 64 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="129"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="602">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="596">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="597">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_int8" c:identifier="gst_byte_reader_get_int8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="288">Read a signed 8 bit integer into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="87"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="295">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="290">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="291">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_pos" c:identifier="gst_byte_reader_get_pos">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="218">Returns the current position of a #GstByteReader instance in bytes.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="72"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="224">The current position of @reader in bytes.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="220">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_reader_get_remaining">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="232">Returns the remaining number of bytes of a #GstByteReader instance.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="75"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="238">The remaining number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="234">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_size" c:identifier="gst_byte_reader_get_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="246">Returns the total number of bytes of a #GstByteReader instance.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="252">The total number of bytes of @reader instance.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="248">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_string_utf8"
              c:identifier="gst_byte_reader_get_string_utf8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1175">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator),
advancing the current position to the byte after the string. This will work
for any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.

No input checking for valid UTF-8 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="255"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1191">%TRUE if a string could be found, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1177">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1178">address of a
    #gchar pointer variable in which to store the result</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_sub_reader"
              c:identifier="gst_byte_reader_get_sub_reader"
              version="1.6"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="170">Initializes a #GstByteReader sub-reader instance to contain @size bytes of
data from the current position of @reader. This is useful to read chunked
formats and make sure that one doesn't read beyond the size of the sub-chunk.

Unlike gst_byte_reader_peek_sub_reader(), this function also modifies the
position of @reader and moves it forward by @size bytes.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="65"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="183">FALSE on error or if @reader does not contain @size more bytes from
    the current position, and otherwise TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="172">an existing and initialized #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="sub_reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="173">a #GstByteReader instance to initialize as sub-reader</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="174">size of @sub_reader in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_be"
              c:identifier="gst_byte_reader_get_uint16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="362">Read an unsigned 16 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="96"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="370">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="364">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="365">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint16_le"
              c:identifier="gst_byte_reader_get_uint16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="318">Read an unsigned 16 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="90"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="326">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="320">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="321">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_be"
              c:identifier="gst_byte_reader_get_uint24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="450">Read an unsigned 24 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="108"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="458">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="452">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="453">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint24_le"
              c:identifier="gst_byte_reader_get_uint24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="406">Read an unsigned 24 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="102"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="414">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="408">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="409">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_be"
              c:identifier="gst_byte_reader_get_uint32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="539">Read an unsigned 32 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="120"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="547">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="541">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="542">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint32_le"
              c:identifier="gst_byte_reader_get_uint32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="495">Read an unsigned 32 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="114"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="503">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="497">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="498">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_be"
              c:identifier="gst_byte_reader_get_uint64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="627">Read an unsigned 64 bit big endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="132"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="635">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="629">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="630">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint64_le"
              c:identifier="gst_byte_reader_get_uint64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="583">Read an unsigned 64 bit little endian integer into @val
and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="126"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="591">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="585">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="586">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_uint8" c:identifier="gst_byte_reader_get_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="278">Read an unsigned 8 bit integer into @val and update the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="84"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="285">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="280">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="281">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_byte_reader_init">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="125">Initializes a #GstByteReader instance to read from @data. This function
can be called on already initialized instances.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="58"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="127">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="128">data from which
    the #GstByteReader should read</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="130">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32"
              c:identifier="gst_byte_reader_masked_scan_uint32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="942">Scan for pattern @pattern with applied mask @mask in the byte reader data,
starting from offset @offset relative to the current position.

The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
byte reader data for it to match, even if the first or last bytes are masked
out.

It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the byte reader.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="261"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="962">offset of the first match, or -1 if no match was found.

Example:
|[
// Assume the reader contains 0x00 0x01 0x02 ... 0xfe 0xff

gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x00010203, 1, 255);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffffffff, 0x01020304, 1, 255);
// -&gt; returns 1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0001, 0, 256);
// -&gt; returns -1
gst_byte_reader_masked_scan_uint32 (reader, 0xffff, 0x0203, 0, 256);
// -&gt; returns 0
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 256);
// -&gt; returns 2
gst_byte_reader_masked_scan_uint32 (reader, 0xffff0000, 0x02030000, 0, 4);
// -&gt; returns -1
]|</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="944">a #GstByteReader</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="945">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="946">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="947">offset from which to start scanning, relative to the current
    position</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="949">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="masked_scan_uint32_peek"
              c:identifier="gst_byte_reader_masked_scan_uint32_peek"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="991">Scan for pattern @pattern with applied mask @mask in the byte reader data,
starting from offset @offset relative to the current position.

The bytes in @pattern and @mask are interpreted left-to-right, regardless
of endianness.  All four bytes of the pattern must be present in the
byte reader data for it to match, even if the first or last bytes are masked
out.

It is an error to call this function without making sure that there is
enough data (offset+size bytes) in the byte reader.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="267"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1012">offset of the first match, or -1 if no match was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="993">a #GstByteReader</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="mask" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="994">mask to apply to data before matching against @pattern</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="pattern" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="995">pattern to match (after mask is applied)</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="996">offset from which to start scanning, relative to the current
    position</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="998">number of bytes to scan from offset</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="999">pointer to uint32 to return matching data</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_data" c:identifier="gst_byte_reader_peek_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="824">Returns a constant pointer to the current data
position if at least @size bytes are left and
keeps the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="222"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="835">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="826">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="size"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="827">Size in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="828">address of a
    #guint8 pointer variable in which to store the result</doc>
            <array length="0" zero-terminated="0" c:type="const guint8**">
              <type name="guint8" c:type="guint8*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_be"
              c:identifier="gst_byte_reader_peek_float32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="742">Read a 32 bit big endian floating point value into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="207"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="750">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="744">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="745">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float32_le"
              c:identifier="gst_byte_reader_peek_float32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="720">Read a 32 bit little endian floating point value into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="204"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="728">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="722">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="723">Pointer to a #gfloat to store the result</doc>
            <type name="gfloat" c:type="gfloat*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_be"
              c:identifier="gst_byte_reader_peek_float64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="786">Read a 64 bit big endian floating point value into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="213"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="794">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="788">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="789">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_float64_le"
              c:identifier="gst_byte_reader_peek_float64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="764">Read a 64 bit little endian floating point value into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="210"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="772">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="766">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="767">Pointer to a #gdouble to store the result</doc>
            <type name="gdouble" c:type="gdouble*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_be"
              c:identifier="gst_byte_reader_peek_int16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="395">Read a signed 16 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="153"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="403">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="397">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="398">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int16_le"
              c:identifier="gst_byte_reader_peek_int16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="351">Read a signed 16 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="147"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="359">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="353">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="354">Pointer to a #gint16 to store the result</doc>
            <type name="gint16" c:type="gint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_be"
              c:identifier="gst_byte_reader_peek_int24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="483">Read a signed 24 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="165"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="491">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="485">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="486">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int24_le"
              c:identifier="gst_byte_reader_peek_int24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="439">Read a signed 24 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="159"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="447">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="441">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="442">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_be"
              c:identifier="gst_byte_reader_peek_int32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="572">Read a signed 32 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="177"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="580">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="574">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="575">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int32_le"
              c:identifier="gst_byte_reader_peek_int32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="528">Read a signed 32 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="171"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="536">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="530">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="531">Pointer to a #gint32 to store the result</doc>
            <type name="gint32" c:type="gint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_be"
              c:identifier="gst_byte_reader_peek_int64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="660">Read a signed 64 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="189"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="668">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="662">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="663">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int64_le"
              c:identifier="gst_byte_reader_peek_int64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="616">Read a signed 64 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="183"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="624">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="618">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="619">Pointer to a #gint64 to store the result</doc>
            <type name="gint64" c:type="gint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_int8" c:identifier="gst_byte_reader_peek_int8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="308">Read a signed 8 bit integer into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="141"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="315">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="310">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="311">Pointer to a #gint8 to store the result</doc>
            <type name="gint8" c:type="gint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_string_utf8"
              c:identifier="gst_byte_reader_peek_string_utf8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1142">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator).
The current position will be maintained. This will work for any
NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.

No input checking for valid UTF-8 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="258"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1158">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1144">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="str"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1145">address of a
    #gchar pointer variable in which to store the result</doc>
            <array c:type="const gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="peek_sub_reader"
              c:identifier="gst_byte_reader_peek_sub_reader"
              version="1.6"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="145">Initializes a #GstByteReader sub-reader instance to contain @size bytes of
data from the current position of @reader. This is useful to read chunked
formats and make sure that one doesn't read beyond the size of the sub-chunk.

Unlike gst_byte_reader_get_sub_reader(), this function does not modify the
current position of @reader.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="61"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="158">FALSE on error or if @reader does not contain @size more bytes from
    the current position, and otherwise TRUE</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="147">an existing and initialized #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="sub_reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="148">a #GstByteReader instance to initialize as sub-reader</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="149">size of @sub_reader in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_be"
              c:identifier="gst_byte_reader_peek_uint16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="384">Read an unsigned 16 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="150"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="392">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="386">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="387">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint16_le"
              c:identifier="gst_byte_reader_peek_uint16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="340">Read an unsigned 16 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="144"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="348">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="342">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="343">Pointer to a #guint16 to store the result</doc>
            <type name="guint16" c:type="guint16*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_be"
              c:identifier="gst_byte_reader_peek_uint24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="472">Read an unsigned 24 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="162"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="480">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="474">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="475">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint24_le"
              c:identifier="gst_byte_reader_peek_uint24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="428">Read an unsigned 24 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="156"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="436">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="430">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="431">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_be"
              c:identifier="gst_byte_reader_peek_uint32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="561">Read an unsigned 32 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="174"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="569">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="563">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="564">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint32_le"
              c:identifier="gst_byte_reader_peek_uint32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="517">Read an unsigned 32 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="168"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="525">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="519">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="520">Pointer to a #guint32 to store the result</doc>
            <type name="guint32" c:type="guint32*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_be"
              c:identifier="gst_byte_reader_peek_uint64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="649">Read an unsigned 64 bit big endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="186"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="657">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="651">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="652">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint64_le"
              c:identifier="gst_byte_reader_peek_uint64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="605">Read an unsigned 64 bit little endian integer into @val
but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="180"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="613">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="607">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="608">Pointer to a #guint64 to store the result</doc>
            <type name="guint64" c:type="guint64*"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_uint8" c:identifier="gst_byte_reader_peek_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="298">Read an unsigned 8 bit integer into @val but keep the current position.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="138"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="305">%TRUE if successful, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="300">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="const GstByteReader*"/>
          </instance-parameter>
          <parameter name="val"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="301">Pointer to a #guint8 to store the result</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_pos" c:identifier="gst_byte_reader_set_pos">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="195">Sets the new position of a #GstByteReader instance to @pos in bytes.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="69"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="202">%TRUE if the position could be set successfully, %FALSE
otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="197">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="pos" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="198">The new position in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip" c:identifier="gst_byte_reader_skip">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="263">Skips @nbytes bytes of the #GstByteReader instance.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="81"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="270">%TRUE if @nbytes bytes could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="265">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
          <parameter name="nbytes" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="266">the number of bytes to skip</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="skip_string_utf16"
              c:identifier="gst_byte_reader_skip_string_utf16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1096">Skips a NUL-terminated UTF-16 string in the #GstByteReader instance,
advancing the current position to the byte after the string.

No input checking for valid UTF-16 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="243"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1107">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1098">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="skip_string_utf32"
              c:identifier="gst_byte_reader_skip_string_utf32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1111">Skips a NUL-terminated UTF-32 string in the #GstByteReader instance,
advancing the current position to the byte after the string.

No input checking for valid UTF-32 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="246"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1122">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1113">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="skip_string_utf8"
              c:identifier="gst_byte_reader_skip_string_utf8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="1081">Skips a NUL-terminated string in the #GstByteReader instance, advancing
the current position to the byte after the string. This will work for
any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc. No input checking for valid UTF-8 is done.

This function will fail if no NUL-terminator was found in in the data.</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="240"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1092">%TRUE if a string could be skipped, %FALSE otherwise.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="reader" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="1083">a #GstByteReader instance</doc>
            <type name="ByteReader" c:type="GstByteReader*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_byte_reader_new"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="87">Create a new #GstByteReader instance, which will read from @data.

Free-function: gst_byte_reader_free</doc>
        <source-position filename="libs/gst/base/gstbytereader.h" line="52"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="97">a new #GstByteReader instance</doc>
          <type name="ByteReader" c:type="GstByteReader*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="89">data from which the
    #GstByteReader should read</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytereader.c"
                 line="91">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="ByteWriter" c:type="GstByteWriter">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytewriter.c"
           line="30">#GstByteWriter provides a byte writer and reader that can write/read different
integer and floating point types to/from a memory buffer. It provides functions
for writing/reading signed/unsigned, little/big endian integers of 8, 16, 24,
32 and 64 bits and functions for reading little/big endian floating points numbers of
32 and 64 bits. It also provides functions to write/read NUL-terminated strings
in various character encodings.</doc>
      <source-position filename="libs/gst/base/gstbytewriter.h" line="52"/>
      <field name="parent" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.h"
             line="35">#GstByteReader parent</doc>
        <type name="ByteReader" c:type="GstByteReader"/>
      </field>
      <field name="alloc_size" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.h"
             line="36">Allocation size of the data</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="fixed" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.h"
             line="37">If %TRUE no reallocations are allowed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="owned" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.h"
             line="38">If %FALSE no reallocations are allowed and copies of data are returned</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="ensure_free_space"
              c:identifier="gst_byte_writer_ensure_free_space">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="364">Checks if enough free space from the current write cursor is
available and reallocates if necessary.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="134"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="372">%TRUE if at least @size bytes are still available</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="366">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="367">Number of bytes that should be available</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="fill" c:identifier="gst_byte_writer_fill">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="688">Writes @size bytes containing @value to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="206"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="696">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="690">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="value" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="691">Value to be written</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="692">Number of bytes to be written</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_byte_writer_free">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="280">Frees @writer and all memory allocated by it.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="282">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_and_get_buffer"
              c:identifier="gst_byte_writer_free_and_get_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="319">Frees @writer and all memory allocated by it except
the current data, which is returned as #GstBuffer.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="79"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="328">the current data as buffer. gst_buffer_unref()
    after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="321">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free_and_get_data"
              c:identifier="gst_byte_writer_free_and_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="295">Frees @writer and all memory allocated by it except
the current data, which is returned.

Free-function: g_free</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="76"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="304">the current data. g_free() after usage.</doc>
          <type name="guint8" c:type="guint8*"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="297">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_remaining"
              c:identifier="gst_byte_writer_get_remaining">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="344">Returns the remaining size of data that can still be written. If
-1 is returned the remaining size is only limited by system resources.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="131"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="351">the remaining size of data that can still be written</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="346">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="const GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init" c:identifier="gst_byte_writer_init">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="140">Initializes @writer to an empty instance</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="142">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="init_with_data"
              c:identifier="gst_byte_writer_init_with_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="178">Initializes @writer with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="180">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="181">Memory area for writing</doc>
            <array length="1" zero-terminated="0" c:type="guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="182">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="183">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="init_with_size"
              c:identifier="gst_byte_writer_init_with_size">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="156">Initializes @writer with the given initial data size.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="158">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="159">Initial size of data</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="160">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_buffer" c:identifier="gst_byte_writer_put_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="699">Writes @size bytes of @data to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="216"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="708">%TRUE if the data could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="701">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="buffer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="702">source #GstBuffer</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="offset" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="703">offset to copy from</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="704">total size to copy. If -1, all data is copied</doc>
            <type name="gssize" c:type="gssize"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_data" c:identifier="gst_byte_writer_put_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="678">Writes @size bytes of @data to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="203"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="686">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="680">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="681">Data to write</doc>
            <array length="1" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="682">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_be"
              c:identifier="gst_byte_writer_put_float32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="615">Writes a big endian 32 bit float to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="191"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="622">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="617">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="618">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float32_le"
              c:identifier="gst_byte_writer_put_float32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="633">Writes a little endian 32 bit float to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="194"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="640">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="635">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="636">Value to write</doc>
            <type name="gfloat" c:type="gfloat"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_be"
              c:identifier="gst_byte_writer_put_float64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="624">Writes a big endian 64 bit float to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="197"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="631">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="626">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="627">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_float64_le"
              c:identifier="gst_byte_writer_put_float64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="642">Writes a little endian 64 bit float to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="200"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="649">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="644">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="645">Value to write</doc>
            <type name="gdouble" c:type="gdouble"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_be" c:identifier="gst_byte_writer_put_int16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="543">Writes a signed big endian 16 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="149"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="550">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="545">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="546">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int16_le" c:identifier="gst_byte_writer_put_int16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="579">Writes a signed little endian 16 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="152"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="586">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="581">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="582">Value to write</doc>
            <type name="gint16" c:type="gint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_be" c:identifier="gst_byte_writer_put_int24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="552">Writes a signed big endian 24 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="161"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="559">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="554">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="555">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int24_le" c:identifier="gst_byte_writer_put_int24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="588">Writes a signed little endian 24 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="164"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="595">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="590">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="591">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_be" c:identifier="gst_byte_writer_put_int32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="561">Writes a signed big endian 32 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="173"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="568">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="563">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="564">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int32_le" c:identifier="gst_byte_writer_put_int32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="597">Writes a signed little endian 32 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="176"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="604">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="599">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="600">Value to write</doc>
            <type name="gint32" c:type="gint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_be" c:identifier="gst_byte_writer_put_int64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="570">Writes a signed big endian 64 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="185"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="577">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="572">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="573">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int64_le" c:identifier="gst_byte_writer_put_int64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="606">Writes a signed little endian 64 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="188"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="613">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="608">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="609">Value to write</doc>
            <type name="gint64" c:type="gint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_int8" c:identifier="gst_byte_writer_put_int8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="534">Writes a signed 8 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="140"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="541">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="536">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="537">Value to write</doc>
            <type name="gint8" c:type="gint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf16"
              c:identifier="gst_byte_writer_put_string_utf16">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="660">Writes a NUL-terminated UTF16 string to @writer (including the terminator).</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="212"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="667">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="662">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="663">UTF16 string to write</doc>
            <array c:type="const guint16*">
              <type name="guint16" c:type="guint16"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf32"
              c:identifier="gst_byte_writer_put_string_utf32">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="669">Writes a NUL-terminated UTF32 string to @writer (including the terminator).</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="215"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="676">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="671">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="672">UTF32 string to write</doc>
            <array c:type="const guint32*">
              <type name="guint32" c:type="guint32"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="put_string_utf8"
              c:identifier="gst_byte_writer_put_string_utf8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="651">Writes a NUL-terminated UTF8 string to @writer (including the terminator).</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="209"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="658">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="653">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="654">UTF8 string to write</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_be"
              c:identifier="gst_byte_writer_put_uint16_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="462">Writes a unsigned big endian 16 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="143"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="469">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="464">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="465">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint16_le"
              c:identifier="gst_byte_writer_put_uint16_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="498">Writes a unsigned little endian 16 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="146"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="505">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="500">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="501">Value to write</doc>
            <type name="guint16" c:type="guint16"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_be"
              c:identifier="gst_byte_writer_put_uint24_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="471">Writes a unsigned big endian 24 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="155"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="478">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="473">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="474">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint24_le"
              c:identifier="gst_byte_writer_put_uint24_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="507">Writes a unsigned little endian 24 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="158"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="514">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="509">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="510">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_be"
              c:identifier="gst_byte_writer_put_uint32_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="480">Writes a unsigned big endian 32 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="167"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="487">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="482">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="483">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint32_le"
              c:identifier="gst_byte_writer_put_uint32_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="516">Writes a unsigned little endian 32 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="170"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="523">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="518">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="519">Value to write</doc>
            <type name="guint32" c:type="guint32"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_be"
              c:identifier="gst_byte_writer_put_uint64_be">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="489">Writes a unsigned big endian 64 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="179"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="496">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="491">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="492">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint64_le"
              c:identifier="gst_byte_writer_put_uint64_le">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="525">Writes a unsigned little endian 64 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="182"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="532">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="527">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="528">Value to write</doc>
            <type name="guint64" c:type="guint64"/>
          </parameter>
        </parameters>
      </method>
      <method name="put_uint8" c:identifier="gst_byte_writer_put_uint8">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="453">Writes a unsigned 8 bit integer to @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="137"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="460">%TRUE if the value could be written</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="455">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
          <parameter name="val" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="456">Value to write</doc>
            <type name="guint8" c:type="guint8"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset" c:identifier="gst_byte_writer_reset">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="204">Resets @writer and frees the data if it's
owned by @writer.</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="82"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="206">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_and_get_buffer"
              c:identifier="gst_byte_writer_reset_and_get_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="248">Resets @writer and returns the current data as buffer.

Free-function: gst_buffer_unref</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="88"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="256">the current data as buffer. gst_buffer_unref()
    after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="250">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="reset_and_get_data"
              c:identifier="gst_byte_writer_reset_and_get_data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="221">Resets @writer and returns the current data.

Free-function: g_free</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="85"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="229">the current data. g_free() after
usage.</doc>
          <array zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="writer" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="223">#GstByteWriter instance</doc>
            <type name="ByteWriter" c:type="GstByteWriter*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_byte_writer_new"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="69">Creates a new, empty #GstByteWriter instance

Free-function: gst_byte_writer_free</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="55"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="76">a new, empty #GstByteWriter instance</doc>
          <type name="ByteWriter" c:type="GstByteWriter*"/>
        </return-value>
      </function>
      <function name="new_with_data"
                c:identifier="gst_byte_writer_new_with_data"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="112">Creates a new #GstByteWriter instance with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.

Free-function: gst_byte_writer_free</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="61"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="124">a new #GstByteWriter instance</doc>
          <type name="ByteWriter" c:type="GstByteWriter*"/>
        </return-value>
        <parameters>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="114">Memory area for writing</doc>
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="115">Size of @data in bytes</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="initialized" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="116">If %TRUE the complete data can be read from the beginning</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_with_size"
                c:identifier="gst_byte_writer_new_with_size"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="87">Creates a new #GstByteWriter instance with the given
initial data size.

Free-function: gst_byte_writer_free</doc>
        <source-position filename="libs/gst/base/gstbytewriter.h" line="58"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="97">a new #GstByteWriter instance</doc>
          <type name="ByteWriter" c:type="GstByteWriter*"/>
        </return-value>
        <parameters>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="89">Initial size of data</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="fixed" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstbytewriter.c"
                 line="90">If %TRUE the data can't be reallocated</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <function-macro name="COLLECT_PADS"
                    c:identifier="GST_COLLECT_PADS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="32"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_CLASS"
                    c:identifier="GST_COLLECT_PADS_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="33"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_DTS"
                    c:identifier="GST_COLLECT_PADS_DTS"
                    version="1.6"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="107">Returns the DTS that has been converted to running time when using
gst_collect_pads_clip_running_time(). Unlike the value saved into
the buffer, this value is of type gint64 and may be negative. This allow
properly handling streams with frame reordering where the first DTS may
be negative. If the initial DTS was not set, this value will be
set to %G_MININT64.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="120"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="109">A #GstCollectData.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_DTS_IS_VALID"
                    c:identifier="GST_COLLECT_PADS_DTS_IS_VALID"
                    version="1.6"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="122">Check if running DTS value store is valid.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="130"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="124">A #GstCollectData.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_GET_CLASS"
                    c:identifier="GST_COLLECT_PADS_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="34"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_GET_STREAM_LOCK"
                    c:identifier="GST_COLLECT_PADS_GET_STREAM_LOCK"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="291">Get the stream lock of @pads. The stream lock is used to coordinate and
serialize execution among the various streams being collected, and in
protecting the resources used to accomplish this.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="299"/>
      <parameters>
        <parameter name="pads">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="293">a #GstCollectPads</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STATE"
                    c:identifier="GST_COLLECT_PADS_STATE"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="74">A flags word containing #GstCollectPadsStateFlags flags set
on this collected pad.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="81"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="76">a #GstCollectData.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STATE_IS_SET"
                    c:identifier="GST_COLLECT_PADS_STATE_IS_SET"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="82">Gives the status of a specific flag on a collected pad.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="89"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="84">a #GstCollectData.</doc>
        </parameter>
        <parameter name="flag">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="85">the #GstCollectPadsStateFlags to check.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STATE_SET"
                    c:identifier="GST_COLLECT_PADS_STATE_SET"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="90">Sets a state flag on a collected pad.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="97"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="92">a #GstCollectData.</doc>
        </parameter>
        <parameter name="flag">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="93">the #GstCollectPadsStateFlags to set.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STATE_UNSET"
                    c:identifier="GST_COLLECT_PADS_STATE_UNSET"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="98">Clears a state flag on a collected pad.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="105"/>
      <parameters>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="100">a #GstCollectData.</doc>
        </parameter>
        <parameter name="flag">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="101">the #GstCollectPadsStateFlags to clear.</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STREAM_LOCK"
                    c:identifier="GST_COLLECT_PADS_STREAM_LOCK"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="300">Lock the stream lock of @pads.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="306"/>
      <parameters>
        <parameter name="pads">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="302">a #GstCollectPads</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="COLLECT_PADS_STREAM_UNLOCK"
                    c:identifier="GST_COLLECT_PADS_STREAM_UNLOCK"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="307">Unlock the stream lock of @pads.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="313"/>
      <parameters>
        <parameter name="pads">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="309">a #GstCollectPads</doc>
        </parameter>
      </parameters>
    </function-macro>
    <record name="CollectData" c:type="GstCollectData">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="132">Structure used by the collect_pads.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="168"/>
      <field name="collect" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="134">owner #GstCollectPads</doc>
        <type name="CollectPads" c:type="GstCollectPads*"/>
      </field>
      <field name="pad" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="135">#GstPad managed by this data</doc>
        <type name="Gst.Pad" c:type="GstPad*"/>
      </field>
      <field name="buffer" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="136">currently queued buffer.</doc>
        <type name="Gst.Buffer" c:type="GstBuffer*"/>
      </field>
      <field name="pos" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="137">position in the buffer</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="segment" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="138">last segment received.</doc>
        <type name="Gst.Segment" c:type="GstSegment"/>
      </field>
      <field name="state" readable="0" private="1">
        <type name="CollectPadsStateFlags" c:type="GstCollectPadsStateFlags"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CollectDataPrivate" c:type="GstCollectDataPrivate*"/>
      </field>
      <union name="ABI" c:type="ABI">
        <source-position filename="libs/gst/base/gstcollectpads.h" line="167"/>
        <record name="abi" c:type="abi">
          <source-position filename="libs/gst/base/gstcollectpads.h"
                           line="165"/>
          <field name="dts" writable="1">
            <type name="gint64" c:type="gint64"/>
          </field>
        </record>
        <field name="_gst_reserved" readable="0" private="1">
          <array zero-terminated="0" fixed-size="4">
            <type name="gpointer" c:type="gpointer"/>
          </array>
        </field>
      </union>
    </record>
    <callback name="CollectDataDestroyNotify"
              c:type="GstCollectDataDestroyNotify">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="44">A function that will be called when the #GstCollectData will be freed.
It is passed the pointer to the structure and should free any custom
memory and resources allocated for it.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="52"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="46">the #GstCollectData that will be freed</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
      </parameters>
    </callback>
    <record name="CollectDataPrivate"
            c:type="GstCollectDataPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="39"/>
    </record>
    <class name="CollectPads"
           c:symbol-prefix="collect_pads"
           c:type="GstCollectPads"
           parent="Gst.Object"
           glib:type-name="GstCollectPads"
           glib:get-type="gst_collect_pads_get_type"
           glib:type-struct="CollectPadsClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.c"
           line="23">Manages a set of pads that operate in collect mode. This means that control
is given to the manager of this object when all pads have data.

  * Collectpads are created with gst_collect_pads_new(). A callback should then
    be installed with gst_collect_pads_set_function ().

  * Pads are added to the collection with gst_collect_pads_add_pad()/
    gst_collect_pads_remove_pad(). The pad has to be a sinkpad. When added,
    the chain, event and query functions of the pad are overridden. The
    element_private of the pad is used to store private information for the
    collectpads.

  * For each pad, data is queued in the _chain function or by
    performing a pull_range.

  * When data is queued on all pads in waiting mode, the callback function is called.

  * Data can be dequeued from the pad with the gst_collect_pads_pop() method.
    One can peek at the data with the gst_collect_pads_peek() function.
    These functions will return %NULL if the pad received an EOS event. When all
    pads return %NULL from a gst_collect_pads_peek(), the element can emit an EOS
    event itself.

  * Data can also be dequeued in byte units using the gst_collect_pads_available(),
    gst_collect_pads_read_buffer() and gst_collect_pads_flush() calls.

  * Elements should call gst_collect_pads_start() and gst_collect_pads_stop() in
    their state change functions to start and stop the processing of the collectpads.
    The gst_collect_pads_stop() call should be called before calling the parent
    element state change function in the PAUSED_TO_READY state change to ensure
    no pad is blocked and the element can finish streaming.

  * gst_collect_pads_set_waiting() sets a pad to waiting or non-waiting mode.
    CollectPads element is not waiting for data to be collected on non-waiting pads.
    Thus these pads may but need not have data when the callback is called.
    All pads are in waiting mode by default.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="341"/>
      <constructor name="new" c:identifier="gst_collect_pads_new">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="273">Create a new instance of #GstCollectPads.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="349"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="280">a new #GstCollectPads, or %NULL in case of an error.</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </return-value>
      </constructor>
      <method name="add_pad" c:identifier="gst_collect_pads_add_pad">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="585">Add a pad to the collection of collect pads. The pad has to be
a sinkpad. The refcount of the pad is incremented. Use
gst_collect_pads_remove_pad() to remove the pad from the collection
again.

You specify a size for the returned #GstCollectData structure
so that you can use it to store additional information.

You can also specify a #GstCollectDataDestroyNotify that will be called
just before the #GstCollectData structure is freed. It is passed the
pointer to the structure and should free any custom memory and resources
allocated for it.

Keeping a pad locked in waiting state is only relevant when using
the default collection algorithm (providing the oldest buffer).
It ensures a buffer must be available on this pad for a collection
to take place.  This is of typical use to a muxer element where
non-subtitle streams should always be in waiting state,
e.g. to assure that caps information is available on all these streams
when initial headers have to be written.

The pad will be automatically activated in push mode when @pads is
started.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="385"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="620">a new #GstCollectData to identify the
  new pad. Or %NULL if wrong parameters are supplied.</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="587">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="588">the pad to add</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="589">the size of the returned #GstCollectData structure</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="destroy_notify"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="590">function to be called before the returned
  #GstCollectData structure is freed</doc>
            <type name="CollectDataDestroyNotify"
                  c:type="GstCollectDataDestroyNotify"/>
          </parameter>
          <parameter name="lock" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="592">whether to lock this pad in usual waiting state</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="available" c:identifier="gst_collect_pads_available">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1012">Query how much bytes can be read from each queued buffer. This means
that the result of this call is the maximum number of bytes that can
be read from each of the pads.

This function should be called with @pads STREAM_LOCK held, such as
in the callback.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="413"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="1025">The maximum number of bytes queued on all pads. This function
returns 0 if a pad has no queued buffer.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1014">the collectpads to query</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="clip_running_time"
              c:identifier="gst_collect_pads_clip_running_time">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="472">Convenience clipping function that converts incoming buffer's timestamp
to running time, or clips the buffer if outside configured segment.

Since 1.6, this clipping function also sets the DTS parameter of the
GstCollectData structure. This version of the running time DTS can be
negative. G_MININT64 is used to indicate invalid value.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="434"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="474">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="cdata" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="475">collect data of corresponding pad</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="buf" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="476">buffer being clipped</doc>
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
          <parameter name="outbuf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     optional="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="477">output buffer with running time, or NULL if clipped</doc>
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="478">user data (unused)</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="event_default"
              c:identifier="gst_collect_pads_event_default">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1647">Default #GstCollectPads event handling that elements should always
chain up to to ensure proper operation.  Element might however indicate
event should not be forwarded downstream.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="442"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1649">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1650">collect data of corresponding pad</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1651">event being processed</doc>
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
          <parameter name="discard" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1652">process but do not send event downstream</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush" c:identifier="gst_collect_pads_flush">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1081">Flush @size bytes from the pad @data.

This function should be called with @pads STREAM_LOCK held, such as
in the callback.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="416"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="1094">The number of bytes flushed This can be less than @size and
is 0 if the pad was end-of-stream.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1083">the collectpads to query</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1084">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1085">the number of bytes to flush</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek" c:identifier="gst_collect_pads_peek">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="930">Peek at the buffer currently queued in @data. This function
should be called with the @pads STREAM_LOCK held, such as in the callback
handler.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="405"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="941">The buffer in @data or %NULL if no
buffer is queued. should unref the buffer after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="932">the collectpads to peek</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="933">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop" c:identifier="gst_collect_pads_pop">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="962">Pop the buffer currently queued in @data. This function
should be called with the @pads STREAM_LOCK held, such as in the callback
handler.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="408"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="973">The buffer in @data or %NULL if no
buffer was queued. You should unref the buffer after usage.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="964">the collectpads to pop</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="965">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
        </parameters>
      </method>
      <method name="query_default"
              c:identifier="gst_collect_pads_query_default">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="2025">Default #GstCollectPads query handling that elements should always
chain up to to ensure proper operation.  Element might however indicate
query should not be forwarded downstream.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="448"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="2027">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="2028">collect data of corresponding pad</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="query" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="2029">query being processed</doc>
            <type name="Gst.Query" c:type="GstQuery*"/>
          </parameter>
          <parameter name="discard" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="2030">process but do not send event downstream</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="read_buffer" c:identifier="gst_collect_pads_read_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1127">Get a subbuffer of @size bytes from the given pad @data.

This function should be called with @pads STREAM_LOCK held, such as in the
callback.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="419"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="1140">A sub buffer. The size of the buffer can
be less that requested. A return of %NULL signals that the pad is
end-of-stream. Unref the buffer after use.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1129">the collectpads to query</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1130">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1131">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="remove_pad" c:identifier="gst_collect_pads_remove_pad">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="683">Remove a pad from the collection of collect pads. This function will also
free the #GstCollectData and all the resources that were allocated with
gst_collect_pads_add_pad().

The pad will be deactivated automatically when @pads is stopped.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="389"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="696">%TRUE if the pad could be removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="685">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="686">the pad to remove</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_buffer_function"
              c:identifier="gst_collect_pads_set_buffer_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="304">Set the callback function and user data that will be called with
the oldest buffer when all pads have been collected, or %NULL on EOS.
If a buffer is passed, the callback owns a reference and must unref
it.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="358"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="306">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="307">the function to set</doc>
            <type name="CollectPadsBufferFunction"
                  c:type="GstCollectPadsBufferFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="308">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clip_function"
              c:identifier="gst_collect_pads_set_clip_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="542">Install a clipping function that is called right after a buffer is received
on a pad managed by @pads. See #GstCollectPadsClipFunction for more info.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="374"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="544">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="clipfunc"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="545">clip function to install</doc>
            <type name="CollectPadsClipFunction"
                  c:type="GstCollectPadsClipFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="546">user data to pass to @clip_func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_compare_function"
              c:identifier="gst_collect_pads_set_compare_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="329">Set the timestamp comparison function.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="370"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="331">the pads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="332">the function to set</doc>
            <type name="CollectPadsCompareFunction"
                  c:type="GstCollectPadsCompareFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="333">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_event_function"
              c:identifier="gst_collect_pads_set_event_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="416">Set the event callback function and user data that will be called when
collectpads has received an event originating from one of the collected
pads.  If the event being processed is a serialized one, this callback is
called with @pads STREAM_LOCK held, otherwise not.  As this lock should be
held when calling a number of CollectPads functions, it should be acquired
if so (unusually) needed.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="362"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="418">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="419">the function to set</doc>
            <type name="CollectPadsEventFunction"
                  c:type="GstCollectPadsEventFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="420">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flush_function"
              c:identifier="gst_collect_pads_set_flush_function"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="562">Install a flush function that is called when the internal
state of all pads should be flushed as part of flushing seek
handling. See #GstCollectPadsFlushFunction for more info.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="378"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="564">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="565">flush function to install</doc>
            <type name="CollectPadsFlushFunction"
                  c:type="GstCollectPadsFlushFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="566">user data to pass to @func</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing" c:identifier="gst_collect_pads_set_flushing">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="804">Change the flushing state of all the pads in the collection. No pad
is able to accept anymore data when @flushing is %TRUE. Calling this
function with @flushing %FALSE makes @pads accept data again.
Caller must ensure that downstream streaming (thread) is not blocked,
e.g. by sending a FLUSH_START downstream.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="400"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="806">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="807">desired state of the pads</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_function" c:identifier="gst_collect_pads_set_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="356">CollectPads provides a default collection algorithm that will determine
the oldest buffer available on all of its pads, and then delegate
to a configured callback.
However, if circumstances are more complicated and/or more control
is desired, this sets a callback that will be invoked instead when
all the pads added to the collection have buffers queued.
Evidently, this callback is not compatible with
gst_collect_pads_set_buffer_function() callback.
If this callback is set, the former will be unset.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="354"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="358">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="359">the function to set</doc>
            <type name="CollectPadsFunction" c:type="GstCollectPadsFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="360">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_query_function"
              c:identifier="gst_collect_pads_set_query_function">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="444">Set the query callback function and user data that will be called after
collectpads has received a query originating from one of the collected
pads.  If the query being processed is a serialized one, this callback is
called with @pads STREAM_LOCK held, otherwise not.  As this lock should be
held when calling a number of CollectPads functions, it should be acquired
if so (unusually) needed.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="366"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="446">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="447">the function to set</doc>
            <type name="CollectPadsQueryFunction"
                  c:type="GstCollectPadsQueryFunction"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="448">user data passed to the function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_waiting" c:identifier="gst_collect_pads_set_waiting">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1196">Sets a pad to waiting or non-waiting mode, if at least this pad
has not been created with locked waiting state,
in which case nothing happens.

This function should be called with @pads STREAM_LOCK held, such as
in the callback.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="428"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1198">the collectpads</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1199">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="waiting" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1200">boolean indicating whether this pad should operate
          in waiting or non-waiting mode</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <method name="src_event_default"
              c:identifier="gst_collect_pads_src_event_default"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1909">Default #GstCollectPads event handling for the src pad of elements.
Elements can chain up to this to let flushing seek event handling
be done by #GstCollectPads.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="445"/>
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1911">the #GstCollectPads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1912">src #GstPad that received the event</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="event" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1913">event being processed</doc>
            <type name="Gst.Event" c:type="GstEvent*"/>
          </parameter>
        </parameters>
      </method>
      <method name="start" c:identifier="gst_collect_pads_start">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="831">Starts the processing of data in the collect_pads.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="394"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="833">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="stop" c:identifier="gst_collect_pads_stop">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="872">Stops the processing of data in the collect_pads. this function
will also unblock any blocking operations.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="397"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="874">the collectpads to use</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="take_buffer" c:identifier="gst_collect_pads_take_buffer">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.c"
             line="1166">Get a subbuffer of @size bytes from the given pad @data. Flushes the amount
of read bytes.

This function should be called with @pads STREAM_LOCK held, such as in the
callback.

MT safe.</doc>
        <source-position filename="libs/gst/base/gstcollectpads.h" line="422"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.c"
               line="1180">A sub buffer. The size of the buffer can
be less that requested. A return of %NULL signals that the pad is
end-of-stream. Unref the buffer after use.</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </return-value>
        <parameters>
          <instance-parameter name="pads" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1168">the collectpads to query</doc>
            <type name="CollectPads" c:type="GstCollectPads*"/>
          </instance-parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1169">the data to use</doc>
            <type name="CollectData" c:type="GstCollectData*"/>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstcollectpads.c"
                 line="1170">the number of bytes to read</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <field name="object">
        <type name="Gst.Object" c:type="GstObject"/>
      </field>
      <field name="data">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="317">#GList of #GstCollectData managed
  by this #GstCollectPads.</doc>
        <type name="GLib.SList" c:type="GSList*">
          <type name="CollectData"/>
        </type>
      </field>
      <field name="stream_lock" readable="0" private="1">
        <type name="GLib.RecMutex" c:type="GRecMutex"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="CollectPadsPrivate" c:type="GstCollectPadsPrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <callback name="CollectPadsBufferFunction"
              c:type="GstCollectPadsBufferFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="181">A function that will be called when a (considered oldest) buffer can be muxed.
If all pads have reached EOS, this function is called with %NULL @buffer
and %NULL @data.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="194"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="192">%GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="183">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="184">the #GstCollectData of pad that has received the buffer</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="buffer" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="185">the #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="186">user data passed to gst_collect_pads_set_buffer_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="CollectPadsClass"
            c:type="GstCollectPadsClass"
            glib:is-gtype-struct-for="CollectPads">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="341"/>
      <field name="parent_class">
        <type name="Gst.ObjectClass" c:type="GstObjectClass"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="CollectPadsClipFunction"
              c:type="GstCollectPadsClipFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="251">A function that will be called when @inbuffer is received on the pad managed
by @data in the collectpad object @pads.

The function should use the segment of @data and the negotiated media type on
the pad to perform clipping of @inbuffer.

This function takes ownership of @inbuffer and should output a buffer in
@outbuffer or return %NULL in @outbuffer if the buffer should be dropped.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="270"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="268">a #GstFlowReturn that corresponds to the result of clipping.</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="253">a #GstCollectPads</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="254">a #GstCollectData</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="inbuffer" transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="255">the input #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="outbuffer"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="256">the output #GstBuffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer**"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="4">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="257">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsCompareFunction"
              c:type="GstCollectPadsCompareFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="197">A function for comparing two timestamps of buffers or newsegments collected on one pad.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="212"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="208">Integer less than zero when first timestamp is deemed older than the second one.
         Zero if the timestamps are deemed equally old.
         Integer greater than zero when second timestamp is deemed older than the first one.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="199">the #GstCollectPads that is comparing the timestamps</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="data1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="200">the first #GstCollectData</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="timestamp1" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="201">the first timestamp</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="data2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="202">the second #GstCollectData</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="timestamp2" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="203">the second timestamp</doc>
          <type name="Gst.ClockTime" c:type="GstClockTime"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="5">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="204">user data passed to gst_collect_pads_set_compare_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsEventFunction"
              c:type="GstCollectPadsEventFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="217">A function that will be called while processing an event. It takes
ownership of the event and is responsible for chaining up (to
gst_collect_pads_event_default()) or dropping events (such typical cases
being handled by the default handler).</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="231"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="229">%TRUE if the pad could handle the event</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="219">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="220">the #GstPad that received an event</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="event" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="221">the #GstEvent received</doc>
          <type name="Gst.Event" c:type="GstEvent*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="222">user data passed to gst_collect_pads_set_event_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsFlushFunction"
              c:type="GstCollectPadsFlushFunction"
              version="1.4">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="275">A function that will be called while processing a flushing seek event.

The function should flush any internal state of the element and the state of
all the pads. It should clear only the state not directly managed by the
@pads object. It is therefore not necessary to call
gst_collect_pads_set_flushing nor gst_collect_pads_clear from this function.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="289"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="277">a #GstCollectPads</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="278">user data</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="CollectPadsFunction" c:type="GstCollectPadsFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="170">A function that will be called when all pads have received data.</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="179"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="177">%GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="172">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="173">user data passed to gst_collect_pads_set_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="CollectPadsPrivate"
            c:type="GstCollectPadsPrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="41"/>
    </record>
    <callback name="CollectPadsQueryFunction"
              c:type="GstCollectPadsQueryFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstcollectpads.h"
           line="235">A function that will be called while processing a query. It takes
ownership of the query and is responsible for chaining up (to
events downstream (with gst_pad_event_default()).</doc>
      <source-position filename="libs/gst/base/gstcollectpads.h" line="248"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="246">%TRUE if the pad could handle the event</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="pads" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="237">the #GstCollectPads that triggered the callback</doc>
          <type name="CollectPads" c:type="GstCollectPads*"/>
        </parameter>
        <parameter name="pad" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="238">the #GstPad that received an event</doc>
          <type name="CollectData" c:type="GstCollectData*"/>
        </parameter>
        <parameter name="query" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="239">the #GstEvent received</doc>
          <type name="Gst.Query" c:type="GstQuery*"/>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="3">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstcollectpads.h"
               line="240">user data passed to gst_collect_pads_set_query_function()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <bitfield name="CollectPadsStateFlags" c:type="GstCollectPadsStateFlags">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="72"/>
      <member name="eos" value="1" c:identifier="GST_COLLECT_PADS_STATE_EOS">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="56">Set if collectdata's pad is EOS.</doc>
      </member>
      <member name="flushing"
              value="2"
              c:identifier="GST_COLLECT_PADS_STATE_FLUSHING">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="57">Set if collectdata's pad is flushing.</doc>
      </member>
      <member name="new_segment"
              value="4"
              c:identifier="GST_COLLECT_PADS_STATE_NEW_SEGMENT">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="58">Set if collectdata's pad received a
                                     new_segment event.</doc>
      </member>
      <member name="waiting"
              value="8"
              c:identifier="GST_COLLECT_PADS_STATE_WAITING">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="60">Set if collectdata's pad must be waited
                                     for when collecting.</doc>
      </member>
      <member name="locked"
              value="16"
              c:identifier="GST_COLLECT_PADS_STATE_LOCKED">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstcollectpads.h"
             line="62">Set collectdata's pad WAITING state must
                                     not be changed.
#GstCollectPadsStateFlags indicate private state of a collectdata('s pad).</doc>
      </member>
    </bitfield>
    <function-macro name="DATA_QUEUE"
                    c:identifier="GST_DATA_QUEUE"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="31"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="DATA_QUEUE_CLASS"
                    c:identifier="GST_DATA_QUEUE_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="33"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <class name="DataQueue"
           c:symbol-prefix="data_queue"
           c:type="GstDataQueue"
           parent="GObject.Object"
           glib:type-name="GstDataQueue"
           glib:get-type="gst_data_queue_get_type"
           glib:type-struct="DataQueueClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstdataqueue.c"
           line="22">#GstDataQueue is an object that handles threadsafe queueing of objects. It
also provides size-related functionality. This object should be used for
any #GstElement that wishes to provide some sort of queueing functionality.</doc>
      <source-position filename="libs/gst/base/gstdataqueue.h" line="137"/>
      <constructor name="new"
                   c:identifier="gst_data_queue_new"
                   version="1.2"
                   introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="212">Creates a new #GstDataQueue. If @fullcallback or @emptycallback are supplied, then
the #GstDataQueue will call the respective callback to signal full or empty condition.
If the callbacks are NULL the #GstDataQueue will instead emit 'full' and 'empty'
signals.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="143"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="226">a new #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </return-value>
        <parameters>
          <parameter name="checkfull" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="214">the callback used to tell if the element considers the queue full
or not.</doc>
            <type name="DataQueueCheckFullFunction"
                  c:type="GstDataQueueCheckFullFunction"/>
          </parameter>
          <parameter name="fullcallback" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="216">the callback which will be called when the queue is considered full.</doc>
            <type name="DataQueueFullCallback"
                  c:type="GstDataQueueFullCallback"/>
          </parameter>
          <parameter name="emptycallback"
                     transfer-ownership="none"
                     closure="3">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="217">the callback which will be called when the queue is considered empty.</doc>
            <type name="DataQueueEmptyCallback"
                  c:type="GstDataQueueEmptyCallback"/>
          </parameter>
          <parameter name="checkdata"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="218">a #gpointer that will be passed to the @checkfull, @fullcallback,
  and @emptycallback callbacks.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="empty">
        <source-position filename="libs/gst/base/gstdataqueue.h" line="133"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="full">
        <source-position filename="libs/gst/base/gstdataqueue.h" line="134"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="drop_head"
              c:identifier="gst_data_queue_drop_head"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="687">Pop and unref the head-most #GstMiniObject with the given #GType.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="166"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="694">%TRUE if an element was removed.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="689">The #GstDataQueue to drop an item from.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="type" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="690">The #GType of the item to drop.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="flush"
              c:identifier="gst_data_queue_flush"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="316">Flushes all the contents of the @queue. Any call to #gst_data_queue_push and
#gst_data_queue_pop will be released.
MT safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="160"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="318">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_level"
              c:identifier="gst_data_queue_get_level"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="759">Get the current level of the queue.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="175"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="761">The #GstDataQueue</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="level"
                     direction="out"
                     caller-allocates="1"
                     transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="762">the location to store the result</doc>
            <type name="DataQueueSize" c:type="GstDataQueueSize*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="gst_data_queue_is_empty"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="335">Queries if there are any items in the @queue.
MT safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="172"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="342">%TRUE if @queue is empty.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="337">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_full"
              c:identifier="gst_data_queue_is_full"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="358">Queries if @queue is full. This check will be done using the
#GstDataQueueCheckFullFunction registered with @queue.
MT safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="169"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="366">%TRUE if @queue is full.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="360">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="limits_changed"
              c:identifier="gst_data_queue_limits_changed"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="735">Inform the queue that the limits for the fullness check have changed and that
any blocking gst_data_queue_push() should be unblocked to recheck the limits.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="178"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="737">The #GstDataQueue</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek"
              c:identifier="gst_data_queue_peek"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="632">Retrieves the first @item available on the @queue without removing it.
If the queue is currently empty, the call will block until at least
one item is available, OR the @queue is set to the flushing state.
MT safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="157"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="642">%TRUE if an @item was successfully retrieved from the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="634">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="item"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="635">pointer to store the returned #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem**"/>
          </parameter>
        </parameters>
      </method>
      <method name="pop"
              c:identifier="gst_data_queue_pop"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="562">Retrieves the first @item available on the @queue. If the queue is currently
empty, the call will block until at least one item is available, OR the
@queue is set to the flushing state.
MT safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="154"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="572">%TRUE if an @item was successfully retrieved from the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="564">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="item"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="565">pointer to store the returned #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem**"/>
          </parameter>
        </parameters>
      </method>
      <method name="push"
              c:identifier="gst_data_queue_push"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="478">Pushes a #GstDataQueueItem (or a structure that begins with the same fields)
on the @queue. If the @queue is full, the call will block until space is
available, OR the @queue is set to flushing state.
MT safe.

Note that this function has slightly different semantics than gst_pad_push()
and gst_pad_push_event(): this function only takes ownership of @item and
the #GstMiniObject contained in @item if the push was successful. If %FALSE
is returned, the caller is responsible for freeing @item and its contents.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="148"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="493">%TRUE if the @item was successfully pushed on the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="480">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="481">a #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_force"
              c:identifier="gst_data_queue_push_force"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="430">Pushes a #GstDataQueueItem (or a structure that begins with the same fields)
on the @queue. It ignores if the @queue is full or not and forces the @item
to be pushed anyway.
MT safe.

Note that this function has slightly different semantics than gst_pad_push()
and gst_pad_push_event(): this function only takes ownership of @item and
the #GstMiniObject contained in @item if the push was successful. If %FALSE
is returned, the caller is responsible for freeing @item and its contents.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="151"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.c"
               line="445">%TRUE if the @item was successfully pushed on the @queue.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="432">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="item" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="433">a #GstDataQueueItem.</doc>
            <type name="DataQueueItem" c:type="GstDataQueueItem*"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_flushing"
              c:identifier="gst_data_queue_set_flushing"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="382">Sets the queue to flushing state if @flushing is %TRUE. If set to flushing
state, any incoming data on the @queue will be discarded. Any call currently
blocking on #gst_data_queue_push or #gst_data_queue_pop will return straight
away with a return value of %FALSE. While the @queue is in flushing state,
all calls to those two functions will return %FALSE.

MT Safe.</doc>
        <source-position filename="libs/gst/base/gstdataqueue.h" line="163"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="queue" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="384">a #GstDataQueue.</doc>
            <type name="DataQueue" c:type="GstDataQueue*"/>
          </instance-parameter>
          <parameter name="flushing" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstdataqueue.c"
                 line="385">a #gboolean stating if the queue will be flushing or not.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </method>
      <property name="current-level-bytes"
                transfer-ownership="none"
                default-value="0">
        <type name="guint" c:type="guint"/>
      </property>
      <property name="current-level-time"
                transfer-ownership="none"
                default-value="0">
        <type name="guint64" c:type="guint64"/>
      </property>
      <property name="current-level-visible"
                transfer-ownership="none"
                default-value="0">
        <type name="guint" c:type="guint"/>
      </property>
      <field name="object">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="112">the parent structure</doc>
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="DataQueuePrivate" c:type="GstDataQueuePrivate*"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <glib:signal name="empty" when="first" introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="147">Reports that the queue became empty (empty).
A queue is empty if the total amount of visible items inside it (num-visible, time,
size) is lower than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
      <glib:signal name="full" when="first" introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.c"
             line="161">Reports that the queue became full (full).
A queue is full if the total amount of data inside it (num-visible, time,
size) is higher than the boundary values which can be set through the GObject
properties.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
      </glib:signal>
    </class>
    <callback name="DataQueueCheckFullFunction"
              c:type="GstDataQueueCheckFullFunction"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstdataqueue.h"
           line="91">The prototype of the function used to inform the queue that it should be
considered as full.</doc>
      <source-position filename="libs/gst/base/gstdataqueue.h" line="104"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="102">%TRUE if the queue should be considered full.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.h"
               line="93">a #GstDataQueue.</doc>
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="visible" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.h"
               line="94">The number of visible items currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="bytes" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.h"
               line="95">The amount of bytes currently in the queue.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="time" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.h"
               line="96">The accumulated duration of the items currently in the queue.</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="checkdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstdataqueue.h"
               line="97">The #gpointer registered when the #GstDataQueue was created.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueClass"
            c:type="GstDataQueueClass"
            glib:is-gtype-struct-for="DataQueue">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="137"/>
      <field name="parent_class">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="empty">
        <callback name="empty">
          <source-position filename="libs/gst/base/gstdataqueue.h" line="133"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="full">
        <callback name="full">
          <source-position filename="libs/gst/base/gstdataqueue.h" line="134"/>
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="queue" transfer-ownership="none">
              <type name="DataQueue" c:type="GstDataQueue*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="DataQueueEmptyCallback" c:type="GstDataQueueEmptyCallback">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="108"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="DataQueueFullCallback" c:type="GstDataQueueFullCallback">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="107"/>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="queue" transfer-ownership="none">
          <type name="DataQueue" c:type="GstDataQueue*"/>
        </parameter>
        <parameter name="checkdata"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="DataQueueItem" c:type="GstDataQueueItem" introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstdataqueue.h"
           line="47">Structure used by #GstDataQueue. You can supply a different structure, as
long as the top of the structure is identical to this structure.</doc>
      <source-position filename="libs/gst/base/gstdataqueue.h" line="74"/>
      <field name="object" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="49">the #GstMiniObject to queue.</doc>
        <type name="Gst.MiniObject" c:type="GstMiniObject*"/>
      </field>
      <field name="size" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="50">the size in bytes of the miniobject.</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="duration" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="51">the duration in #GstClockTime of the miniobject. Can not be
%GST_CLOCK_TIME_NONE.</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="visible" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="53">%TRUE if @object should be considered as a visible object.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="destroy" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="54">The #GDestroyNotify function to use to free the #GstDataQueueItem.
This function should also drop the reference to @object the owner of the
#GstDataQueueItem is assumed to hold.</doc>
        <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="DataQueuePrivate"
            c:type="GstDataQueuePrivate"
            disguised="1"
            opaque="1">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="45"/>
    </record>
    <record name="DataQueueSize" c:type="GstDataQueueSize" introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstdataqueue.h"
           line="76">Structure describing the size of a queue.</doc>
      <source-position filename="libs/gst/base/gstdataqueue.h" line="89"/>
      <field name="visible" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="78">number of buffers</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="bytes" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="79">number of bytes</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="time" writable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstdataqueue.h"
             line="80">amount of time</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
    </record>
    <record name="FlowCombiner"
            c:type="GstFlowCombiner"
            opaque="1"
            version="1.4"
            glib:type-name="GstFlowCombiner"
            glib:get-type="gst_flow_combiner_get_type"
            c:symbol-prefix="flow_combiner">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstflowcombiner.c"
           line="24">Utility struct to help handling #GstFlowReturn combination. Useful for
#GstElement&lt;!-- --&gt;s that have multiple source pads and need to combine
the different #GstFlowReturn for those pads.

#GstFlowCombiner works by using the last #GstFlowReturn for all #GstPad
it has in its list and computes the combined return value and provides
it to the caller.

To add a new pad to the #GstFlowCombiner use gst_flow_combiner_add_pad().
The new #GstPad is stored with a default value of %GST_FLOW_OK.

In case you want a #GstPad to be removed, use gst_flow_combiner_remove_pad().

Please be aware that this struct isn't thread safe as its designed to be
 used by demuxers, those usually will have a single thread operating it.

These functions will take refs on the passed #GstPad&lt;!-- --&gt;s.

Aside from reducing the user's code size, the main advantage of using this
helper struct is to follow the standard rules for #GstFlowReturn combination.
These rules are:

* %GST_FLOW_EOS: only if all returns are EOS too
* %GST_FLOW_NOT_LINKED: only if all returns are NOT_LINKED too
* %GST_FLOW_ERROR or below: if at least one returns an error return
* %GST_FLOW_NOT_NEGOTIATED: if at least one returns a not-negotiated return
* %GST_FLOW_FLUSHING: if at least one returns flushing
* %GST_FLOW_OK: otherwise

%GST_FLOW_ERROR or below, GST_FLOW_NOT_NEGOTIATED and GST_FLOW_FLUSHING are
returned immediately from the gst_flow_combiner_update_flow() function.</doc>
      <source-position filename="libs/gst/base/gstflowcombiner.h" line="43"/>
      <constructor name="new"
                   c:identifier="gst_flow_combiner_new"
                   version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="87">Creates a new #GstFlowCombiner, use gst_flow_combiner_free() to free it.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="46"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstflowcombiner.c"
               line="92">A new #GstFlowCombiner</doc>
          <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
        </return-value>
      </constructor>
      <method name="add_pad"
              c:identifier="gst_flow_combiner_add_pad"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="320">Adds a new #GstPad to the #GstFlowCombiner.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="64"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="322">the #GstFlowCombiner</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="323">the #GstPad that is being added</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="clear"
              c:identifier="gst_flow_combiner_clear"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="168">Removes all pads from a #GstFlowCombiner and resets it to its initial state.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="70"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="170">the #GstFlowCombiner to clear</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="free" c:identifier="gst_flow_combiner_free" version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="110">Frees a #GstFlowCombiner struct and all its internal data.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="55"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="112">the #GstFlowCombiner to free</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="gst_flow_combiner_ref" version="1.12.1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="124">Increments the reference count on the #GstFlowCombiner.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="49"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstflowcombiner.c"
               line="130">the #GstFlowCombiner.</doc>
          <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="126">the #GstFlowCombiner to add a reference to.</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="remove_pad"
              c:identifier="gst_flow_combiner_remove_pad"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="338">Removes a #GstPad from the #GstFlowCombiner.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="67"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="340">the #GstFlowCombiner</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="341">the #GstPad to remove</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
        </parameters>
      </method>
      <method name="reset"
              c:identifier="gst_flow_combiner_reset"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="190">Reset flow combiner and all pads to their initial state without removing pads.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="73"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="192">the #GstFlowCombiner to clear</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref"
              c:identifier="gst_flow_combiner_unref"
              version="1.12.1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="144">Decrements the reference count on the #GstFlowCombiner.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="52"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="146">the #GstFlowCombiner to unreference.</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_flow"
              c:identifier="gst_flow_combiner_update_flow"
              version="1.4">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="253">Computes the combined flow return for the pads in it.

The #GstFlowReturn parameter should be the last flow return update for a pad
in this #GstFlowCombiner. It will use this value to be able to shortcut some
combinations and avoid looking over all pads again. e.g. The last combined
return is the same as the latest obtained #GstFlowReturn.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="58"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstflowcombiner.c"
               line="265">The combined #GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="255">the #GstFlowCombiner</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
          <parameter name="fret" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="256">the latest #GstFlowReturn received for a pad in this #GstFlowCombiner</doc>
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </parameter>
        </parameters>
      </method>
      <method name="update_pad_flow"
              c:identifier="gst_flow_combiner_update_pad_flow"
              version="1.6">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstflowcombiner.c"
             line="292">Sets the provided pad's last flow return to provided value and computes
the combined flow return for the pads in it.

The #GstFlowReturn parameter should be the last flow return update for a pad
in this #GstFlowCombiner. It will use this value to be able to shortcut some
combinations and avoid looking over all pads again. e.g. The last combined
return is the same as the latest obtained #GstFlowReturn.</doc>
        <source-position filename="libs/gst/base/gstflowcombiner.h" line="61"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstflowcombiner.c"
               line="306">The combined #GstFlowReturn</doc>
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="combiner" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="294">the #GstFlowCombiner</doc>
            <type name="FlowCombiner" c:type="GstFlowCombiner*"/>
          </instance-parameter>
          <parameter name="pad" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="295">the #GstPad whose #GstFlowReturn to update</doc>
            <type name="Gst.Pad" c:type="GstPad*"/>
          </parameter>
          <parameter name="fret" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstflowcombiner.c"
                 line="296">the latest #GstFlowReturn received for a pad in this #GstFlowCombiner</doc>
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </parameter>
        </parameters>
      </method>
    </record>
    <function-macro name="IS_ADAPTER"
                    c:identifier="GST_IS_ADAPTER"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstadapter.h" line="37"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_ADAPTER_CLASS"
                    c:identifier="GST_IS_ADAPTER_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstadapter.h" line="39"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AGGREGATOR"
                    c:identifier="GST_IS_AGGREGATOR"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="136"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AGGREGATOR_CLASS"
                    c:identifier="GST_IS_AGGREGATOR_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="137"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AGGREGATOR_PAD"
                    c:identifier="GST_IS_AGGREGATOR_PAD"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="46"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_AGGREGATOR_PAD_CLASS"
                    c:identifier="GST_IS_AGGREGATOR_PAD_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstaggregator.h" line="47"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_PARSE"
                    c:identifier="GST_IS_BASE_PARSE"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="34"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_PARSE_CLASS"
                    c:identifier="GST_IS_BASE_PARSE_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbaseparse.h" line="35"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_SINK"
                    c:identifier="GST_IS_BASE_SINK"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_SINK_CLASS"
                    c:identifier="GST_IS_BASE_SINK_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesink.h" line="37"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_SRC"
                    c:identifier="GST_IS_BASE_SRC"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_SRC_CLASS"
                    c:identifier="GST_IS_BASE_SRC_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasesrc.h" line="37"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_TRANSFORM"
                    c:identifier="GST_IS_BASE_TRANSFORM"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="33"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_BASE_TRANSFORM_CLASS"
                    c:identifier="GST_IS_BASE_TRANSFORM_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbasetransform.h" line="34"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_COLLECT_PADS"
                    c:identifier="GST_IS_COLLECT_PADS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_COLLECT_PADS_CLASS"
                    c:identifier="GST_IS_COLLECT_PADS_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstcollectpads.h" line="36"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_DATA_QUEUE"
                    c:identifier="GST_IS_DATA_QUEUE"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_DATA_QUEUE_CLASS"
                    c:identifier="GST_IS_DATA_QUEUE_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstdataqueue.h" line="37"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PUSH_SRC"
                    c:identifier="GST_IS_PUSH_SRC"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstpushsrc.h" line="36"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="IS_PUSH_SRC_CLASS"
                    c:identifier="GST_IS_PUSH_SRC_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstpushsrc.h" line="37"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PUSH_SRC"
                    c:identifier="GST_PUSH_SRC"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstpushsrc.h" line="33"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PUSH_SRC_CLASS"
                    c:identifier="GST_PUSH_SRC_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstpushsrc.h" line="34"/>
      <parameters>
        <parameter name="klass">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="PUSH_SRC_GET_CLASS"
                    c:identifier="GST_PUSH_SRC_GET_CLASS"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstpushsrc.h" line="35"/>
      <parameters>
        <parameter name="obj">
        </parameter>
      </parameters>
    </function-macro>
    <class name="PushSrc"
           c:symbol-prefix="push_src"
           c:type="GstPushSrc"
           parent="BaseSrc"
           glib:type-name="GstPushSrc"
           glib:get-type="gst_push_src_get_type"
           glib:type-struct="PushSrcClass">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstpushsrc.c"
           line="23">This class is mostly useful for elements that cannot do
random access, or at least very slowly. The source usually
prefers to push out a fixed size buffer.

Subclasses usually operate in a format that is different from the
default GST_FORMAT_BYTES format of #GstBaseSrc.

Classes extending this base class will usually be scheduled
in a push based mode. If the peer accepts to operate without
offsets and within the limits of the allowed block size, this
class can operate in getrange based mode automatically. To make
this possible, the subclass should implement and override the
SCHEDULING query.

The subclass should extend the methods from the baseclass in
addition to the ::create method.

Seeking, flushing, scheduling and sync is all handled by this
base class.</doc>
      <source-position filename="libs/gst/base/gstpushsrc.h" line="93"/>
      <virtual-method name="alloc">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstpushsrc.h"
             line="81">Allocate memory for a buffer.</doc>
        <source-position filename="libs/gst/base/gstpushsrc.h" line="87"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="PushSrc" c:type="GstPushSrc*"/>
          </instance-parameter>
          <parameter name="buf"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="create">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstpushsrc.h"
             line="73">Ask the subclass to create a buffer, the default implementation will call alloc if
no allocated @buf is provided and then call fill.</doc>
        <source-position filename="libs/gst/base/gstpushsrc.h" line="80"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="PushSrc" c:type="GstPushSrc*"/>
          </instance-parameter>
          <parameter name="buf"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full"
                     nullable="1"
                     allow-none="1">
            <type name="Gst.Buffer" c:type="GstBuffer**"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="fill">
        <source-position filename="libs/gst/base/gstpushsrc.h" line="89"/>
        <return-value transfer-ownership="none">
          <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
        </return-value>
        <parameters>
          <instance-parameter name="src" transfer-ownership="none">
            <type name="PushSrc" c:type="GstPushSrc*"/>
          </instance-parameter>
          <parameter name="buf" transfer-ownership="none">
            <type name="Gst.Buffer" c:type="GstBuffer*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <field name="parent">
        <type name="BaseSrc" c:type="GstBaseSrc"/>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </class>
    <record name="PushSrcClass"
            c:type="GstPushSrcClass"
            glib:is-gtype-struct-for="PushSrc">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstpushsrc.h"
           line="54">Subclasses can override any of the available virtual methods or not, as
needed. At the minimum, the @fill method should be overridden to produce
buffers.</doc>
      <source-position filename="libs/gst/base/gstpushsrc.h" line="93"/>
      <field name="parent_class">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstpushsrc.h"
             line="56">Element parent class</doc>
        <type name="BaseSrcClass" c:type="GstBaseSrcClass"/>
      </field>
      <field name="create">
        <callback name="create">
          <source-position filename="libs/gst/base/gstpushsrc.h" line="80"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="PushSrc" c:type="GstPushSrc*"/>
            </parameter>
            <parameter name="buf"
                       direction="inout"
                       caller-allocates="0"
                       transfer-ownership="full"
                       nullable="1"
                       allow-none="1">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="alloc">
        <callback name="alloc">
          <source-position filename="libs/gst/base/gstpushsrc.h" line="87"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="PushSrc" c:type="GstPushSrc*"/>
            </parameter>
            <parameter name="buf"
                       direction="out"
                       caller-allocates="0"
                       transfer-ownership="full"
                       nullable="1">
              <type name="Gst.Buffer" c:type="GstBuffer**"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="fill">
        <callback name="fill">
          <source-position filename="libs/gst/base/gstpushsrc.h" line="89"/>
          <return-value transfer-ownership="none">
            <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
          </return-value>
          <parameters>
            <parameter name="src" transfer-ownership="none">
              <type name="PushSrc" c:type="GstPushSrc*"/>
            </parameter>
            <parameter name="buf" transfer-ownership="none">
              <type name="Gst.Buffer" c:type="GstBuffer*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="_gst_reserved" readable="0" private="1">
        <array zero-terminated="0" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="QueueArray"
            c:type="GstQueueArray"
            disguised="1"
            opaque="1"
            introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstqueuearray.c"
           line="23">#GstQueueArray is an object that provides standard queue functionality
based on an array instead of linked lists. This reduces the overhead
caused by memory management by a large factor.</doc>
      <source-position filename="libs/gst/base/gstqueuearray.h" line="34"/>
      <method name="clear"
              c:identifier="gst_queue_array_clear"
              version="1.16"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="163">Clears queue @array and frees all memory associated to it.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="47"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="165">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="drop_element"
              c:identifier="gst_queue_array_drop_element"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="696">Drops the queue element at position @idx from queue @array.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="71"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="703">the dropped element</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="698">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="699">index to drop</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="drop_struct"
              c:identifier="gst_queue_array_drop_struct"
              version="1.6"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="578">Drops the queue element at position @idx from queue @array and copies the
data of the element or structure that was removed into @p_struct if
@p_struct is set (not NULL).</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="98"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="588">TRUE on success, or FALSE on error</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="580">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="581">index to drop</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="p_struct"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="582">address into which to store the data of the dropped structure, or NULL</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="find"
              c:identifier="gst_queue_array_find"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="718">Finds an element in the queue @array, either by comparing every element
with @func or by looking up @data if no compare function @func is provided,
and returning the index of the found element.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="74"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="728">Index of the found element or -1 if nothing was found.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="720">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1"
                     closure="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="721">comparison function, or %NULL to find @data by value</doc>
            <type name="GLib.CompareFunc" c:type="GCompareFunc"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="722">data for comparison function</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="free"
              c:identifier="gst_queue_array_free"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="105">Frees queue @array and all memory associated to it.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="40"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="107">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_length"
              c:identifier="gst_queue_array_get_length"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="766">Returns the length of the queue @array</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="78"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="772">the length of the queue @array.</doc>
          <type name="guint" c:type="guint"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="768">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_empty"
              c:identifier="gst_queue_array_is_empty"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="560">Checks if the queue @array is empty.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="68"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="566">%TRUE if the queue @array is empty</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="562">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_head"
              c:identifier="gst_queue_array_peek_head"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="270">Returns the head of the queue @array and does not
remove it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="53"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="277">The head of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="272">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_head_struct"
              c:identifier="gst_queue_array_peek_head_struct"
              version="1.6"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="247">Returns the head of the queue @array without removing it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="92"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="253">pointer to element or struct, or NULL if @array was empty. The
   data pointed to by the returned pointer stays valid only as long as
   the queue array is not modified further!</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="249">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_nth"
              c:identifier="gst_queue_array_peek_nth"
              version="1.16"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="292">Returns the item at @idx in @array, but does not remove it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="56"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="297">The item, or %NULL if @idx was out of bounds</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_nth_struct"
              c:identifier="gst_queue_array_peek_nth_struct"
              version="1.16"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="312">Returns the item at @idx in @array, but does not remove it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="95"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="317">The item, or %NULL if @idx was out of bounds</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="idx" transfer-ownership="none">
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </method>
      <method name="peek_tail"
              c:identifier="gst_queue_array_peek_tail"
              version="1.14"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="434">Returns the tail of the queue @array, but does not remove it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="62"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="440">The tail of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="436">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="peek_tail_struct"
              c:identifier="gst_queue_array_peek_tail_struct"
              version="1.14"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="462">Returns the tail of the queue @array, but does not remove it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="105"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="468">The tail of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="464">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_head"
              c:identifier="gst_queue_array_pop_head"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="219">Returns and head of the queue @array and removes
it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="50"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="226">The head of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="221">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_head_struct"
              c:identifier="gst_queue_array_pop_head_struct"
              version="1.6"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="189">Returns the head of the queue @array and removes it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="89"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="195">pointer to element or struct, or NULL if @array was empty. The
   data pointed to by the returned pointer stays valid only as long as
   the queue array is not modified further!</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="191">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_tail"
              c:identifier="gst_queue_array_pop_tail"
              version="1.14"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="490">Returns the tail of the queue @array and removes
it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="59"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="497">The tail of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="492">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="pop_tail_struct"
              c:identifier="gst_queue_array_pop_tail_struct"
              version="1.14"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="525">Returns the tail of the queue @array and removes
it from the queue.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="102"/>
        <return-value transfer-ownership="none" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="532">The tail of the queue</doc>
          <type name="gpointer" c:type="gpointer"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="527">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="push_tail"
              c:identifier="gst_queue_array_push_tail"
              version="1.2"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="410">Pushes @data to the tail of the queue @array.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="65"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="412">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="413">object to push</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="push_tail_struct"
              c:identifier="gst_queue_array_push_tail_struct">
        <source-position filename="libs/gst/base/gstqueuearray.h" line="86"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="p_struct"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="set_clear_func"
              c:identifier="gst_queue_array_set_clear_func"
              version="1.16"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="122">Sets a function to clear an element of @array.

The @clear_func will be called when an element in the array
data segment is removed and when the array is freed and data
segment is deallocated as well. @clear_func will be passed a
pointer to the element to clear, rather than the element itself.

Note that in contrast with other uses of #GDestroyNotify
functions, @clear_func is expected to clear the contents of
the array element it is given, but not free the element itself.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="43"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="array" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="124">a #GstQueueArray object</doc>
            <type name="QueueArray" c:type="GstQueueArray*"/>
          </instance-parameter>
          <parameter name="clear_func" transfer-ownership="none" scope="async">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="125">a function to clear an element of @array</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_queue_array_new"
                version="1.2"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="84">Allocates a new #GstQueueArray object with an initial
queue size of @initial_size.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="37"/>
        <return-value>
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="91">a new #GstQueueArray object</doc>
          <type name="QueueArray" c:type="GstQueueArray*"/>
        </return-value>
        <parameters>
          <parameter name="initial_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="86">Initial size of the new queue</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_for_struct"
                c:identifier="gst_queue_array_new_for_struct"
                version="1.6"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="53">Allocates a new #GstQueueArray object for elements (e.g. structures)
of size @struct_size, with an initial queue size of @initial_size.</doc>
        <source-position filename="libs/gst/base/gstqueuearray.h" line="83"/>
        <return-value>
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="61">a new #GstQueueArray object</doc>
          <type name="QueueArray" c:type="GstQueueArray*"/>
        </return-value>
        <parameters>
          <parameter name="struct_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="55">Size of each element (e.g. structure) in the array</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
          <parameter name="initial_size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gstqueuearray.c"
                 line="56">Initial size of the new queue</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="TypeFindData"
            c:type="GstTypeFindData"
            disguised="1"
            opaque="1"
            version="1.22">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="501">The opaque #GstTypeFindData structure.</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="32"/>
      <method name="free"
              c:identifier="gst_type_find_data_free"
              version="1.22"
              introspectable="0">
        <source-position filename="libs/gst/base/gsttypefindhelper.h"
                         line="39"/>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1142">GstTypeFindData * to free</doc>
            <type name="TypeFindData" c:type="GstTypeFindData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_caps"
              c:identifier="gst_type_find_data_get_caps"
              version="1.22"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1083">Returns #GstCaps associated with #GstTypeFindData</doc>
        <source-position filename="libs/gst/base/gsttypefindhelper.h"
                         line="36"/>
        <return-value transfer-ownership="full" nullable="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1089">#GstCaps.</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1085">GstTypeFindData *</doc>
            <type name="TypeFindData" c:type="GstTypeFindData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_probability"
              c:identifier="gst_type_find_data_get_probability"
              version="1.22"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1102">Returns #GstTypeFindProbability associated with #GstTypeFindData</doc>
        <source-position filename="libs/gst/base/gsttypefindhelper.h"
                         line="37"/>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1108">#GstTypeFindProbability.</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1104">GstTypeFindData *</doc>
            <type name="TypeFindData" c:type="GstTypeFindData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_typefind"
              c:identifier="gst_type_find_data_get_typefind"
              version="1.22"
              introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1121">Returns #GstTypeFind associated with #GstTypeFindData</doc>
        <source-position filename="libs/gst/base/gsttypefindhelper.h"
                         line="38"/>
        <return-value>
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1127">#GstTypeFind.</doc>
          <type name="Gst.TypeFind" c:type="GstTypeFind*"/>
        </return-value>
        <parameters>
          <instance-parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1123">GstTypeFindData *</doc>
            <type name="TypeFindData" c:type="GstTypeFindData*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="new"
                c:identifier="gst_type_find_data_new"
                version="1.22"
                introspectable="0">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1045">Free-function: gst_type_find_data_free</doc>
        <source-position filename="libs/gst/base/gsttypefindhelper.h"
                         line="34"/>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1053">the #GstTypeFindData. The caller should free
         the returned #GstTypeFindData with gst_type_find_data_free().</doc>
          <type name="TypeFindData" c:type="GstTypeFindData*"/>
        </return-value>
        <parameters>
          <parameter name="obj"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1047">object doing the typefinding, or %NULL (used for logging)</doc>
            <type name="Gst.Object" c:type="GstObject*"/>
          </parameter>
          <parameter name="data" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1048">a pointer with data to typefind</doc>
            <array length="2" zero-terminated="0" c:type="const guint8*">
              <type name="guint8" c:type="guint8"/>
            </array>
          </parameter>
          <parameter name="size" transfer-ownership="none">
            <doc xml:space="preserve"
                 filename="libs/gst/base/gsttypefindhelper.c"
                 line="1049">the size of @data</doc>
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <callback name="TypeFindHelperGetRangeFunction"
              c:type="GstTypeFindHelperGetRangeFunction">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.h"
           line="89">This function will be called by gst_type_find_helper_get_range() when
typefinding functions request to peek at the data of a stream at certain
offsets. If this function returns GST_FLOW_OK, the result buffer will be
stored in @buffer. The  contents of @buffer is invalid for any other
return value.

This function is supposed to behave exactly like a #GstPadGetRangeFunction.</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h"
                       line="107"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.h"
             line="105">GST_FLOW_OK for success</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.h"
               line="91">a #GstObject that will handle the getrange request</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="parent"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.h"
               line="92">the parent of @obj or %NULL</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.h"
               line="93">the offset of the range</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="length" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.h"
               line="94">the length of the range</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="buffer"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.h"
               line="95">a memory location to hold the result buffer</doc>
          <type name="Gst.Buffer" c:type="GstBuffer**"/>
        </parameter>
      </parameters>
    </callback>
    <function name="bit_reader_new"
              c:identifier="gst_bit_reader_new"
              moved-to="BitReader.new"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitreader.c"
           line="51">Create a new #GstBitReader instance, which will read from @data.

Free-function: gst_bit_reader_free</doc>
      <source-position filename="libs/gst/base/gstbitreader.h" line="55"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitreader.c"
             line="61">a new #GstBitReader instance</doc>
        <type name="BitReader" c:type="GstBitReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="53">Data from which the #GstBitReader
  should read</doc>
          <array length="1" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitreader.c"
               line="55">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_writer_new"
              c:identifier="gst_bit_writer_new"
              moved-to="BitWriter.new"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitwriter.c"
           line="42">Creates a new, empty #GstBitWriter instance.

Free-function: gst_bit_writer_free</doc>
      <source-position filename="libs/gst/base/gstbitwriter.h" line="61"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="49">a new, empty #GstByteWriter instance</doc>
        <type name="BitWriter" c:type="GstBitWriter*"/>
      </return-value>
    </function>
    <function name="bit_writer_new_with_data"
              c:identifier="gst_bit_writer_new_with_data"
              moved-to="BitWriter.new_with_data"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitwriter.c"
           line="81">Creates a new #GstBitWriter instance with the given memory area. If
@initialized is %TRUE it is possible to read @size bits from the
#GstBitWriter from the beginning.

Free-function: gst_bit_writer_free</doc>
      <source-position filename="libs/gst/base/gstbitwriter.h" line="67"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="93">a new #GstBitWriter instance</doc>
        <type name="BitWriter" c:type="GstBitWriter*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="83">Memory area for writing</doc>
          <array length="1" zero-terminated="0" c:type="guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="84">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="85">if %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="bit_writer_new_with_size"
              c:identifier="gst_bit_writer_new_with_size"
              moved-to="BitWriter.new_with_size"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbitwriter.c"
           line="61">Creates a #GstBitWriter instance with the given initial data size.

Free-function: gst_bit_writer_free</doc>
      <source-position filename="libs/gst/base/gstbitwriter.h" line="64"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbitwriter.c"
             line="70">a new #GstBitWriter instance</doc>
        <type name="BitWriter" c:type="GstBitWriter*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="63">Initial size of data in bytes</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
        <parameter name="fixed" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbitwriter.c"
               line="64">If %TRUE the data can't be reallocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="byte_reader_dup_string"
                    c:identifier="gst_byte_reader_dup_string"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbytereader.h" line="224"/>
      <parameters>
        <parameter name="reader">
        </parameter>
        <parameter name="str">
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="byte_reader_get_string"
                    c:identifier="gst_byte_reader_get_string"
                    introspectable="0">
      <source-position filename="libs/gst/base/gstbytereader.h" line="248"/>
      <parameters>
        <parameter name="reader">
        </parameter>
        <parameter name="str">
        </parameter>
      </parameters>
    </function-macro>
    <function name="byte_reader_new"
              c:identifier="gst_byte_reader_new"
              moved-to="ByteReader.new"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytereader.c"
           line="87">Create a new #GstByteReader instance, which will read from @data.

Free-function: gst_byte_reader_free</doc>
      <source-position filename="libs/gst/base/gstbytereader.h" line="52"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytereader.c"
             line="97">a new #GstByteReader instance</doc>
        <type name="ByteReader" c:type="GstByteReader*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="89">data from which the
    #GstByteReader should read</doc>
          <array length="1" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="91">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="byte_reader_peek_string"
                    c:identifier="gst_byte_reader_peek_string"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytereader.c"
           line="1126">Returns a constant pointer to the current data position if there is
a NUL-terminated string in the data (this could be just a NUL terminator).
The current position will be maintained. This will work for any
NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.

This function will fail if no NUL-terminator was found in in the data.</doc>
      <source-position filename="libs/gst/base/gstbytereader.h" line="251"/>
      <parameters>
        <parameter name="reader">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1128">a #GstByteReader instance</doc>
        </parameter>
        <parameter name="str">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1129">address of a
    #gchar pointer variable in which to store the result</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function-macro name="byte_reader_skip_string"
                    c:identifier="gst_byte_reader_skip_string"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytereader.c"
           line="1068">Skips a NUL-terminated string in the #GstByteReader instance, advancing
the current position to the byte after the string. This will work for
any NUL-terminated string with a character width of 8 bits, so ASCII,
UTF-8, ISO-8859-N etc.

This function will fail if no NUL-terminator was found in in the data.</doc>
      <source-position filename="libs/gst/base/gstbytereader.h" line="236"/>
      <parameters>
        <parameter name="reader">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytereader.c"
               line="1070">a #GstByteReader instance</doc>
        </parameter>
      </parameters>
    </function-macro>
    <function name="byte_writer_new"
              c:identifier="gst_byte_writer_new"
              moved-to="ByteWriter.new"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytewriter.c"
           line="69">Creates a new, empty #GstByteWriter instance

Free-function: gst_byte_writer_free</doc>
      <source-position filename="libs/gst/base/gstbytewriter.h" line="55"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="76">a new, empty #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
    </function>
    <function name="byte_writer_new_with_data"
              c:identifier="gst_byte_writer_new_with_data"
              moved-to="ByteWriter.new_with_data"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytewriter.c"
           line="112">Creates a new #GstByteWriter instance with the given
memory area. If @initialized is %TRUE it is possible to
read @size bytes from the #GstByteWriter from the beginning.

Free-function: gst_byte_writer_free</doc>
      <source-position filename="libs/gst/base/gstbytewriter.h" line="61"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="124">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="114">Memory area for writing</doc>
          <type name="guint8" c:type="guint8*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="115">Size of @data in bytes</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="initialized" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="116">If %TRUE the complete data can be read from the beginning</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="byte_writer_new_with_size"
              c:identifier="gst_byte_writer_new_with_size"
              moved-to="ByteWriter.new_with_size"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytewriter.c"
           line="87">Creates a new #GstByteWriter instance with the given
initial data size.

Free-function: gst_byte_writer_free</doc>
      <source-position filename="libs/gst/base/gstbytewriter.h" line="58"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gstbytewriter.c"
             line="97">a new #GstByteWriter instance</doc>
        <type name="ByteWriter" c:type="GstByteWriter*"/>
      </return-value>
      <parameters>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="89">Initial size of data</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="fixed" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.c"
               line="90">If %TRUE the data can't be reallocated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function-macro name="byte_writer_put_string"
                    c:identifier="gst_byte_writer_put_string"
                    introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstbytewriter.h"
           line="218">Write a NUL-terminated string to @writer (including the terminator). The
string is assumed to be in an 8-bit encoding (e.g. ASCII,UTF-8 or
ISO-8859-1).</doc>
      <source-position filename="libs/gst/base/gstbytewriter.h" line="229"/>
      <parameters>
        <parameter name="writer">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.h"
               line="220">#GstByteWriter instance</doc>
        </parameter>
        <parameter name="data">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstbytewriter.h"
               line="221">Null terminated string</doc>
        </parameter>
      </parameters>
    </function-macro>
    <docsection name="gsttypefindhelper">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="24">Utility functions for elements doing typefinding:
gst_type_find_helper() does typefinding in pull mode, while
gst_type_find_helper_for_buffer() is useful for elements needing to do
typefinding in push mode from a chain function.</doc>
    </docsection>
    <function name="queue_array_new"
              c:identifier="gst_queue_array_new"
              moved-to="QueueArray.new"
              version="1.2"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstqueuearray.c"
           line="84">Allocates a new #GstQueueArray object with an initial
queue size of @initial_size.</doc>
      <source-position filename="libs/gst/base/gstqueuearray.h" line="37"/>
      <return-value>
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="91">a new #GstQueueArray object</doc>
        <type name="QueueArray" c:type="GstQueueArray*"/>
      </return-value>
      <parameters>
        <parameter name="initial_size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="86">Initial size of the new queue</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="queue_array_new_for_struct"
              c:identifier="gst_queue_array_new_for_struct"
              moved-to="QueueArray.new_for_struct"
              version="1.6"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gstqueuearray.c"
           line="53">Allocates a new #GstQueueArray object for elements (e.g. structures)
of size @struct_size, with an initial queue size of @initial_size.</doc>
      <source-position filename="libs/gst/base/gstqueuearray.h" line="83"/>
      <return-value>
        <doc xml:space="preserve"
             filename="libs/gst/base/gstqueuearray.c"
             line="61">a new #GstQueueArray object</doc>
        <type name="QueueArray" c:type="GstQueueArray*"/>
      </return-value>
      <parameters>
        <parameter name="struct_size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="55">Size of each element (e.g. structure) in the array</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="initial_size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gstqueuearray.c"
               line="56">Initial size of the new queue</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_data_new"
              c:identifier="gst_type_find_data_new"
              moved-to="TypeFindData.new"
              version="1.22"
              introspectable="0">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="1045">Free-function: gst_type_find_data_free</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="34"/>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1053">the #GstTypeFindData. The caller should free
         the returned #GstTypeFindData with gst_type_find_data_free().</doc>
        <type name="TypeFindData" c:type="GstTypeFindData*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1047">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1048">a pointer with data to typefind</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="1049">the size of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper" c:identifier="gst_type_find_helper">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="463">Tries to find what type of data is flowing from the given source #GstPad.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="42"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="472">the #GstCaps corresponding to the data
    stream.  Returns %NULL if no #GstCaps matches the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="src" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="465">A source #GstPad</doc>
          <type name="Gst.Pad" c:type="GstPad*"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="466">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_buffer"
              c:identifier="gst_type_find_helper_for_buffer">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="785">Tries to find what type of data is contained in the given #GstBuffer, the
assumption being that the buffer represents the beginning of the stream or
file.

All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or %NULL if
the content of the buffer could not be identified.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="65"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="805">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="787">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="788">a #GstBuffer with data to typefind</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="789">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_buffer_with_caps"
              c:identifier="gst_type_find_helper_for_buffer_with_caps"
              version="1.22">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="870">Tries to find if type of media contained in the given #GstBuffer, matches
@caps specified, assumption being that the buffer represents the beginning
of the stream or file.

Tries to find what type of data is contained in the given @data, the
assumption being that the data represents the beginning of the stream or
file.

Only the typefinder matching the given caps will be called, if found. The
caps with the highest probability will be returned, or %NULL if the content
of the @data could not be identified.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="76"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="892">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="872">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="873">a #GstBuffer with data to typefind</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="874">caps of the media</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="875">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_buffer_with_extension"
              c:identifier="gst_type_find_helper_for_buffer_with_extension"
              version="1.16">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="816">Tries to find what type of data is contained in the given #GstBuffer, the
assumption being that the buffer represents the beginning of the stream or
file.

All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or %NULL if
the content of the buffer could not be identified.

When @extension is not %NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="70"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="841">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="818">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="buf" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="819">a #GstBuffer with data to typefind</doc>
          <type name="Gst.Buffer" c:type="GstBuffer*"/>
        </parameter>
        <parameter name="extension"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="820">extension of the media, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="821">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_data"
              c:identifier="gst_type_find_helper_for_data">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="582">Tries to find what type of data is contained in the given @data, the
assumption being that the data represents the beginning of the stream or
file.

All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or %NULL if
the content of @data could not be identified.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="45"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="603">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="584">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="585">* a pointer with data to typefind</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="586">the size of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="587">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_data_with_caps"
              c:identifier="gst_type_find_helper_for_data_with_caps"
              version="1.22">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="698">Tries to find if type of media contained in the given @data, matches the
@caps specified, assumption being that the data represents the beginning
of the stream or file.

Only the typefinder matching the given caps will be called, if found. The
caps with the highest probability will be returned, or %NULL if the content
of the @data could not be identified.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="58"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="717">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="700">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="701">a pointer with data to typefind</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="702">the size of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="703">caps of the media</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="704">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_data_with_extension"
              c:identifier="gst_type_find_helper_for_data_with_extension"
              version="1.16">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="615">Tries to find what type of data is contained in the given @data, the
assumption being that the data represents the beginning of the stream or
file.

All available typefinders will be called on the data in order of rank. If
a typefinding function returns a probability of %GST_TYPE_FIND_MAXIMUM,
typefinding is stopped immediately and the found caps will be returned
right away. Otherwise, all available typefind functions will the tried,
and the caps with the highest probability will be returned, or %NULL if
the content of @data could not be identified.

When @extension is not %NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="51"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="641">the #GstCaps corresponding to the data,
    or %NULL if no type could be found. The caller should free the caps
    returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="617">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="data" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="618">* a pointer with data to typefind</doc>
          <array length="2" zero-terminated="0" c:type="const guint8*">
            <type name="guint8" c:type="guint8"/>
          </array>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="619">the size of @data</doc>
          <type name="gsize" c:type="gsize"/>
        </parameter>
        <parameter name="extension"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="620">extension of the media, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="621">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_for_extension"
              c:identifier="gst_type_find_helper_for_extension">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="924">Tries to find the best #GstCaps associated with @extension.

All available typefinders will be checked against the extension in order
of rank. The caps of the first typefinder that can handle @extension will be
returned.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="82"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="937">the #GstCaps corresponding to
    @extension, or %NULL if no type could be found. The caller should free
    the caps returned with gst_caps_unref().</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="926">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="extension" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="927">an extension</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range"
              c:identifier="gst_type_find_helper_get_range">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="303">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).

When @extension is not %NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.

Free-function: gst_caps_unref</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h"
                       line="113"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="329">the #GstCaps corresponding to the data
    stream.  Returns %NULL if no #GstCaps matches the data stream.</doc>
        <type name="Gst.Caps" c:type="GstCaps*"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="305">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="parent"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="306">the parent of @obj or %NULL</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="307">A generic #GstTypeFindHelperGetRangeFunction that will
       be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="309">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="extension"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="310">extension of the media, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="311">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_helper_get_range_full"
              c:identifier="gst_type_find_helper_get_range_full"
              version="1.14.3">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="345">Utility function to do pull-based typefinding. Unlike gst_type_find_helper()
however, this function will use the specified function @func to obtain the
data needed by the typefind functions, rather than operating on a given
source pad. This is useful mostly for elements like tag demuxers which
strip off data at the beginning and/or end of a file and want to typefind
the stripped data stream before adding their own source pad (the specified
callback can then call the upstream peer pad with offsets adjusted for the
tag size, for example).

When @extension is not %NULL, this function will first try the typefind
functions for the given extension, which might speed up the typefinding
in many cases.</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h"
                       line="121"/>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="370">the last %GstFlowReturn from pulling a buffer or %GST_FLOW_OK if
         typefinding was successful.</doc>
        <type name="Gst.FlowReturn" c:type="GstFlowReturn"/>
      </return-value>
      <parameters>
        <parameter name="obj" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="347">A #GstObject that will be passed as first argument to @func</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="parent"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="348">the parent of @obj or %NULL</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="func" transfer-ownership="none" scope="call">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="349">A generic #GstTypeFindHelperGetRangeFunction that will
       be used to access data at random offsets when doing the typefinding</doc>
          <type name="TypeFindHelperGetRangeFunction"
                c:type="GstTypeFindHelperGetRangeFunction"/>
        </parameter>
        <parameter name="size" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="351">The length in bytes</doc>
          <type name="guint64" c:type="guint64"/>
        </parameter>
        <parameter name="extension"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="352">extension of the media, or %NULL</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="caps"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="353">returned caps</doc>
          <type name="Gst.Caps" c:type="GstCaps**"/>
        </parameter>
        <parameter name="prob"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full"
                   optional="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="354">location to store the probability of the found
    caps, or %NULL</doc>
          <type name="Gst.TypeFindProbability"
                c:type="GstTypeFindProbability*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_find_list_factories_for_caps"
              c:identifier="gst_type_find_list_factories_for_caps"
              version="1.22">
      <doc xml:space="preserve"
           filename="libs/gst/base/gsttypefindhelper.c"
           line="989">Tries to find the best #GstTypeFindFactory associated with @caps.

The typefinder that can handle @caps will be returned.

Free-function: g_list_free</doc>
      <source-position filename="libs/gst/base/gsttypefindhelper.h" line="86"/>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve"
             filename="libs/gst/base/gsttypefindhelper.c"
             line="1000">the list of #GstTypeFindFactory
         corresponding to @caps, or %NULL if no typefinder could be
         found. Caller should free the returned list with g_list_free()
         and list elements with gst_object_unref().</doc>
        <type name="GLib.List" c:type="GList*">
          <type name="Gst.TypeFindFactory"/>
        </type>
      </return-value>
      <parameters>
        <parameter name="obj"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="991">object doing the typefinding, or %NULL (used for logging)</doc>
          <type name="Gst.Object" c:type="GstObject*"/>
        </parameter>
        <parameter name="caps" transfer-ownership="none">
          <doc xml:space="preserve"
               filename="libs/gst/base/gsttypefindhelper.c"
               line="992">caps of the media</doc>
          <type name="Gst.Caps" c:type="GstCaps*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
