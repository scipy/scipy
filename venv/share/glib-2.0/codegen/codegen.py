# -*- Mode: Python -*-
# coding=utf-8

# GDBus - GLib D-Bus Library
#
# Copyright (C) 2008-2018 Red Hat, Inc.
# Copyright (C) 2018 Iñigo Martínez <inigomartinez@gmail.com>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General
# Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
#
# Author: David Zeuthen <davidz@redhat.com>

from . import config
from . import utils
from . import dbustypes
from .utils import print_error

LICENSE_STR = """/*
 * This file is generated by gdbus-codegen, do not modify it.
 *
 * The license of this code is the same as for the D-Bus interface description
 * it was derived from. Note that it links to GLib, so must comply with the
 * LGPL linking clauses.
 */\n"""


# Disable line length warnings as wrapping the C code templates would be hard
# flake8: noqa: E501


def generate_namespace(namespace):
    ns = namespace
    if len(namespace) > 0:
        if utils.is_ugly_case(namespace):
            ns = namespace.replace("_", "")
            ns_upper = namespace.upper() + "_"
            ns_lower = namespace.lower() + "_"
        else:
            ns_upper = utils.camel_case_to_uscore(namespace).upper() + "_"
            ns_lower = utils.camel_case_to_uscore(namespace).lower() + "_"
    else:
        ns_upper = ""
        ns_lower = ""

    return (ns, ns_upper, ns_lower)


def generate_header_guard(header_name):
    # There might be more characters that are safe to use than these, but lets
    # stay conservative.
    safe_valid_chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    return "".join(
        map(lambda c: c if c in safe_valid_chars else "_", header_name.upper())
    )


class HeaderCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        generate_objmanager,
        generate_autocleanup,
        header_name,
        input_files_basenames,
        use_pragma,
        glib_min_required,
        symbol_decorator,
        symbol_decorator_header,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.generate_objmanager = generate_objmanager
        self.generate_autocleanup = generate_autocleanup
        self.header_guard = generate_header_guard(header_name)
        self.input_files_basenames = input_files_basenames
        self.use_pragma = use_pragma
        self.glib_min_required = glib_min_required
        self.symbol_decorator = symbol_decorator
        self.symbol_decorator_header = symbol_decorator_header
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_header_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        self.outfile.write("\n")

        if self.use_pragma:
            self.outfile.write("#pragma once\n")
        else:
            self.outfile.write("#ifndef __{!s}__\n".format(self.header_guard))
            self.outfile.write("#define __{!s}__\n".format(self.header_guard))

        if self.symbol_decorator_header is not None:
            self.outfile.write("\n")
            self.outfile.write('#include "%s"\n' % self.symbol_decorator_header)

        self.outfile.write("\n")
        self.outfile.write("#include <gio/gio.h>\n")
        self.outfile.write("\n")
        self.outfile.write("G_BEGIN_DECLS\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def declare_types(self):
        for i in self.ifaces:
            self.outfile.write("\n")
            self.outfile.write(
                "/* ------------------------------------------------------------------------ */\n"
            )
            self.outfile.write("/* Declarations for %s */\n" % i.name)
            self.outfile.write("\n")

            # First the GInterface
            self.outfile.write(
                "#define %sTYPE_%s (%s_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s, %s))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %s%s_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_%s, %sIface))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%s;\n" % (i.camel_name))
            self.outfile.write(
                "typedef struct _%s %s;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sIface %sIface;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sIface\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  GTypeInterface parent_iface;\n")

            function_pointers = {}

            # vfuncs for methods
            if len(i.methods) > 0:
                self.outfile.write("\n")
                for m in i.methods:
                    key = (m.since, "_method_%s" % m.name_lower)
                    value = "  gboolean (*handle_%s) (\n" % (m.name_lower)
                    value += "    %s *object,\n" % (i.camel_name)
                    value += "    GDBusMethodInvocation *invocation"
                    if m.unix_fd:
                        value += ",\n    GUnixFDList *fd_list"
                    for a in m.in_args:
                        value += ",\n    %sarg_%s" % (a.ctype_in, a.name)
                    value += ");\n\n"
                    function_pointers[key] = value

            # vfuncs for signals
            if len(i.signals) > 0:
                self.outfile.write("\n")
                for s in i.signals:
                    key = (s.since, "_signal_%s" % s.name_lower)
                    value = "  void (*%s) (\n" % (s.name_lower)
                    value += "    %s *object" % (i.camel_name)
                    for a in s.args:
                        value += ",\n    %sarg_%s" % (a.ctype_in, a.name)
                    value += ");\n\n"
                    function_pointers[key] = value

            # vfuncs for properties
            if len(i.properties) > 0:
                self.outfile.write("\n")
                for p in i.properties:
                    key = (p.since, "_prop_get_%s" % p.name_lower)
                    value = "  %s (*get_%s) (%s *object);\n\n" % (
                        p.arg.ctype_in,
                        p.name_lower,
                        i.camel_name,
                    )
                    function_pointers[key] = value

            # Sort according to @since tag, then name.. this ensures
            # that the function pointers don't change order assuming
            # judicious use of @since
            #
            # Also use a proper version comparison function so e.g.
            # 10.0 comes after 2.0.
            #
            # See https://bugzilla.gnome.org/show_bug.cgi?id=647577#c5
            # for discussion
            for key in sorted(function_pointers.keys(), key=utils.version_cmp_key):
                self.outfile.write("%s" % function_pointers[key])

            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.generate_autocleanup == "all":
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%s, g_object_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %s_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GDBusInterfaceInfo *%s_interface_info (void);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "guint %s_override_properties (GObjectClass *klass, guint property_id_begin);\n"
                % (i.name_lower)
            )
            self.outfile.write("\n")

            # Then method call completion functions
            if len(i.methods) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus method call completion functions: */\n")
                for m in i.methods:
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_complete_%s (\n"
                        "    %s *object,\n"
                        "    GDBusMethodInvocation *invocation"
                        % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    if m.unix_fd:
                        self.outfile.write(",\n    GUnixFDList *fd_list")
                    for a in m.out_args:
                        self.outfile.write(",\n    %s%s" % (a.ctype_in, a.name))
                    self.outfile.write(");\n")
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then signal emission functions
            if len(i.signals) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus signal emissions functions: */\n")
                for s in i.signals:
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if s.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_emit_%s (\n"
                        "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
                    )
                    for a in s.args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    self.outfile.write(");\n")
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then method call declarations
            if len(i.methods) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus method calls: */\n")
                for m in i.methods:
                    # async begin
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_call_%s (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.in_args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    if self.glib_min_required >= (2, 64):
                        self.outfile.write(
                            ",\n    GDBusCallFlags call_flags"
                            ",\n    gint timeout_msec"
                        )
                    if m.unix_fd:
                        self.outfile.write(",\n    GUnixFDList *fd_list")
                    self.outfile.write(
                        ",\n"
                        "    GCancellable *cancellable,\n"
                        "    GAsyncReadyCallback callback,\n"
                        "    gpointer user_data);\n"
                    )
                    self.outfile.write("\n")
                    # async finish
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "gboolean %s_call_%s_finish (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.out_args:
                        self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
                    if m.unix_fd:
                        self.outfile.write(",\n    GUnixFDList **out_fd_list")
                    self.outfile.write(
                        ",\n" "    GAsyncResult *res,\n" "    GError **error);\n"
                    )
                    self.outfile.write("\n")
                    # sync
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if m.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "gboolean %s_call_%s_sync (\n"
                        "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
                    )
                    for a in m.in_args:
                        self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
                    if self.glib_min_required >= (2, 64):
                        self.outfile.write(
                            ",\n    GDBusCallFlags call_flags"
                            ",\n    gint timeout_msec"
                        )
                    if m.unix_fd:
                        self.outfile.write(",\n    GUnixFDList  *fd_list")
                    for a in m.out_args:
                        self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
                    if m.unix_fd:
                        self.outfile.write(",\n    GUnixFDList **out_fd_list")
                    self.outfile.write(
                        ",\n"
                        "    GCancellable *cancellable,\n"
                        "    GError **error);\n"
                    )
                    self.outfile.write("\n")
                self.outfile.write("\n")

            # Then the property accessor declarations
            if len(i.properties) > 0:
                self.outfile.write("\n")
                self.outfile.write("/* D-Bus property accessors: */\n")
                for p in i.properties:
                    # getter
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if p.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "%s%s_get_%s (%s *object);\n"
                        % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
                    )
                    if p.arg.free_func is not None:
                        if self.symbol_decorator is not None:
                            self.outfile.write("%s\n" % self.symbol_decorator)
                        if p.deprecated:
                            self.outfile.write("G_GNUC_DEPRECATED ")
                        self.outfile.write(
                            "%s%s_dup_%s (%s *object);\n"
                            % (
                                p.arg.ctype_in_dup,
                                i.name_lower,
                                p.name_lower,
                                i.camel_name,
                            )
                        )
                    # setter
                    if self.symbol_decorator is not None:
                        self.outfile.write("%s\n" % self.symbol_decorator)
                    if p.deprecated:
                        self.outfile.write("G_GNUC_DEPRECATED ")
                    self.outfile.write(
                        "void %s_set_%s (%s *object, %svalue);\n"
                        % (i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in)
                    )
                    self.outfile.write("\n")

            # Then the proxy
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_%s_PROXY (%s_proxy_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_PROXY, %sProxy))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_PROXY, %sProxyClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_PROXY, %sProxyClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_PROXY))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %sIS_%s_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_PROXY))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sProxy %sProxy;\n" % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sProxyClass %sProxyClass;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sProxyPrivate %sProxyPrivate;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sProxy\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  GDBusProxy parent_instance;\n")
            self.outfile.write("  %sProxyPrivate *priv;\n" % (i.camel_name))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sProxyClass\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusProxyClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %s_proxy_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sProxy, g_object_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "void %s_proxy_new (\n"
                "    GDBusConnection     *connection,\n"
                "    GDBusProxyFlags      flags,\n"
                "    const gchar         *name,\n"
                "    const gchar         *object_path,\n"
                "    GCancellable        *cancellable,\n"
                "    GAsyncReadyCallback  callback,\n"
                "    gpointer             user_data);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_finish (\n"
                "    GAsyncResult        *res,\n"
                "    GError             **error);\n" % (i.camel_name, i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_sync (\n"
                "    GDBusConnection     *connection,\n"
                "    GDBusProxyFlags      flags,\n"
                "    const gchar         *name,\n"
                "    const gchar         *object_path,\n"
                "    GCancellable        *cancellable,\n"
                "    GError             **error);\n" % (i.camel_name, i.name_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "void %s_proxy_new_for_bus (\n"
                "    GBusType             bus_type,\n"
                "    GDBusProxyFlags      flags,\n"
                "    const gchar         *name,\n"
                "    const gchar         *object_path,\n"
                "    GCancellable        *cancellable,\n"
                "    GAsyncReadyCallback  callback,\n"
                "    gpointer             user_data);\n" % (i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_for_bus_finish (\n"
                "    GAsyncResult        *res,\n"
                "    GError             **error);\n" % (i.camel_name, i.name_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_proxy_new_for_bus_sync (\n"
                "    GBusType             bus_type,\n"
                "    GDBusProxyFlags      flags,\n"
                "    const gchar         *name,\n"
                "    const gchar         *object_path,\n"
                "    GCancellable        *cancellable,\n"
                "    GError             **error);\n" % (i.camel_name, i.name_lower)
            )
            self.outfile.write("\n")

            # Then the skeleton
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_%s_SKELETON (%s_skeleton_get_type ())\n"
                % (i.ns_upper, i.name_upper, i.name_lower)
            )
            self.outfile.write(
                "#define %s%s_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_%s_SKELETON, %sSkeleton))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_%s_SKELETON, %sSkeletonClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %s%s_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_%s_SKELETON, %sSkeletonClass))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper, i.camel_name)
            )
            self.outfile.write(
                "#define %sIS_%s_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_%s_SKELETON))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "#define %sIS_%s_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_%s_SKELETON))\n"
                % (i.ns_upper, i.name_upper, i.ns_upper, i.name_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sSkeleton %sSkeleton;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sSkeletonClass %sSkeletonClass;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write(
                "typedef struct _%sSkeletonPrivate %sSkeletonPrivate;\n"
                % (i.camel_name, i.camel_name)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sSkeleton\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  GDBusInterfaceSkeleton parent_instance;\n")
            self.outfile.write("  %sSkeletonPrivate *priv;\n" % (i.camel_name))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sSkeletonClass\n" % (i.camel_name))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusInterfaceSkeletonClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %s_skeleton_get_type (void) G_GNUC_CONST;\n" % (i.name_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sSkeleton, g_object_unref)\n"
                    % (i.camel_name)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            if i.deprecated:
                self.outfile.write("G_GNUC_DEPRECATED ")
            self.outfile.write(
                "%s *%s_skeleton_new (void);\n" % (i.camel_name, i.name_lower)
            )

            self.outfile.write("\n")

        # Finally, the Object, ObjectProxy, ObjectSkeleton and ObjectManagerClient
        if self.generate_objmanager:
            self.outfile.write("\n")
            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT (%sobject_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT, %sObject))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sOBJECT_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), %sTYPE_OBJECT, %sObject))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObject;\n" % (self.namespace))
            self.outfile.write(
                "typedef struct _%sObject %sObject;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectIface %sObjectIface;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectIface\n" % (self.namespace))
            self.outfile.write("{\n" "  GTypeInterface parent_iface;\n" "};\n" "\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %sobject_get_type (void) G_GNUC_CONST;\n" "\n" % (self.ns_lower)
            )
            if self.generate_autocleanup == "all":
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObject, g_object_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "%s *%sobject_get_%s (%sObject *object);\n"
                    % (
                        i.camel_name,
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                    )
                )
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "%s *%sobject_peek_%s (%sObject *object);\n"
                    % (
                        i.camel_name,
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                    )
                )
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_PROXY (%sobject_proxy_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_PROXY, %sObjectProxy))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_PROXY, %sObjectProxyClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_PROXY, %sObjectProxyClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_PROXY))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_PROXY))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectProxy %sObjectProxy;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectProxyClass %sObjectProxyClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectProxyPrivate %sObjectProxyPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectProxy\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  GDBusObjectProxy parent_instance;\n")
            self.outfile.write("  %sObjectProxyPrivate *priv;\n" % (self.namespace))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectProxyClass\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusObjectProxyClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %sobject_proxy_get_type (void) G_GNUC_CONST;\n" % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectProxy, g_object_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "%sObjectProxy *%sobject_proxy_new (GDBusConnection *connection, const gchar *object_path);\n"
                % (self.namespace, self.ns_lower)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_SKELETON (%sobject_skeleton_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_SKELETON, %sObjectSkeleton))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_SKELETON, %sObjectSkeletonClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_SKELETON, %sObjectSkeletonClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_SKELETON))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_SKELETON))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectSkeleton %sObjectSkeleton;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectSkeletonClass %sObjectSkeletonClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectSkeletonPrivate %sObjectSkeletonPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectSkeleton\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  GDBusObjectSkeleton parent_instance;\n")
            self.outfile.write("  %sObjectSkeletonPrivate *priv;\n" % (self.namespace))
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectSkeletonClass\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  GDBusObjectSkeletonClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %sobject_skeleton_get_type (void) G_GNUC_CONST;\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectSkeleton, g_object_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "%sObjectSkeleton *%sobject_skeleton_new (const gchar *object_path);\n"
                % (self.namespace, self.ns_lower)
            )
            for i in self.ifaces:
                if self.symbol_decorator is not None:
                    self.outfile.write("%s\n" % self.symbol_decorator)
                if i.deprecated:
                    self.outfile.write("G_GNUC_DEPRECATED ")
                self.outfile.write(
                    "void %sobject_skeleton_set_%s (%sObjectSkeleton *object, %s *interface_);\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                    )
                )
            self.outfile.write("\n")

            self.outfile.write("/* ---- */\n")
            self.outfile.write("\n")
            self.outfile.write(
                "#define %sTYPE_OBJECT_MANAGER_CLIENT (%sobject_manager_client_get_type ())\n"
                % (self.ns_upper, self.ns_lower)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClient))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sOBJECT_MANAGER_CLIENT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), %sTYPE_OBJECT_MANAGER_CLIENT, %sObjectManagerClientClass))\n"
                % (self.ns_upper, self.ns_upper, self.namespace)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_MANAGER_CLIENT(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), %sTYPE_OBJECT_MANAGER_CLIENT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write(
                "#define %sIS_OBJECT_MANAGER_CLIENT_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), %sTYPE_OBJECT_MANAGER_CLIENT))\n"
                % (self.ns_upper, self.ns_upper)
            )
            self.outfile.write("\n")
            self.outfile.write(
                "typedef struct _%sObjectManagerClient %sObjectManagerClient;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectManagerClientClass %sObjectManagerClientClass;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write(
                "typedef struct _%sObjectManagerClientPrivate %sObjectManagerClientPrivate;\n"
                % (self.namespace, self.namespace)
            )
            self.outfile.write("\n")
            self.outfile.write("struct _%sObjectManagerClient\n" % (self.namespace))
            self.outfile.write("{\n")
            self.outfile.write("  /*< private >*/\n")
            self.outfile.write("  GDBusObjectManagerClient parent_instance;\n")
            self.outfile.write(
                "  %sObjectManagerClientPrivate *priv;\n" % (self.namespace)
            )
            self.outfile.write("};\n")
            self.outfile.write("\n")
            self.outfile.write(
                "struct _%sObjectManagerClientClass\n" % (self.namespace)
            )
            self.outfile.write("{\n")
            self.outfile.write("  GDBusObjectManagerClientClass parent_class;\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")
            if self.generate_autocleanup in ("objects", "all"):
                self.outfile.write("#if GLIB_CHECK_VERSION(2, 44, 0)\n")
                self.outfile.write(
                    "G_DEFINE_AUTOPTR_CLEANUP_FUNC (%sObjectManagerClient, g_object_unref)\n"
                    % (self.namespace)
                )
                self.outfile.write("#endif\n")
                self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %sobject_manager_client_get_type (void) G_GNUC_CONST;\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GType %sobject_manager_client_get_proxy_type (GDBusObjectManagerClient *manager, const gchar *object_path, const gchar *interface_name, gpointer user_data);\n"
                % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "void %sobject_manager_client_new (\n"
                "    GDBusConnection        *connection,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const gchar            *name,\n"
                "    const gchar            *object_path,\n"
                "    GCancellable           *cancellable,\n"
                "    GAsyncReadyCallback     callback,\n"
                "    gpointer                user_data);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GDBusObjectManager *%sobject_manager_client_new_finish (\n"
                "    GAsyncResult        *res,\n"
                "    GError             **error);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GDBusObjectManager *%sobject_manager_client_new_sync (\n"
                "    GDBusConnection        *connection,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const gchar            *name,\n"
                "    const gchar            *object_path,\n"
                "    GCancellable           *cancellable,\n"
                "    GError                **error);\n" % (self.ns_lower)
            )
            self.outfile.write("\n")
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "void %sobject_manager_client_new_for_bus (\n"
                "    GBusType                bus_type,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const gchar            *name,\n"
                "    const gchar            *object_path,\n"
                "    GCancellable           *cancellable,\n"
                "    GAsyncReadyCallback     callback,\n"
                "    gpointer                user_data);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GDBusObjectManager *%sobject_manager_client_new_for_bus_finish (\n"
                "    GAsyncResult        *res,\n"
                "    GError             **error);\n" % (self.ns_lower)
            )
            if self.symbol_decorator is not None:
                self.outfile.write("%s\n" % self.symbol_decorator)
            self.outfile.write(
                "GDBusObjectManager *%sobject_manager_client_new_for_bus_sync (\n"
                "    GBusType                bus_type,\n"
                "    GDBusObjectManagerClientFlags  flags,\n"
                "    const gchar            *name,\n"
                "    const gchar            *object_path,\n"
                "    GCancellable           *cancellable,\n"
                "    GError                **error);\n" % (self.ns_lower)
            )
            self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_header_postamble(self):
        self.outfile.write("\n")
        self.outfile.write("G_END_DECLS\n")

        if not self.use_pragma:
            self.outfile.write("\n")
            self.outfile.write("#endif /* __{!s}__ */\n".format(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_header_preamble()
        self.declare_types()
        self.generate_header_postamble()


# ----------------------------------------------------------------------------------------------------


class InterfaceInfoHeaderCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        header_name,
        input_files_basenames,
        use_pragma,
        glib_min_required,
        symbol_decorator,
        symbol_decorator_header,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.header_guard = generate_header_guard(header_name)
        self.input_files_basenames = input_files_basenames
        self.use_pragma = use_pragma
        self.glib_min_required = glib_min_required
        self.symbol_decorator = symbol_decorator
        if self.symbol_decorator is None:
            self.symbol_decorator = ""
        self.symbol_decorator_header = symbol_decorator_header
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_header_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        self.outfile.write("\n")

        if self.use_pragma:
            self.outfile.write("#pragma once\n")
        else:
            self.outfile.write("#ifndef __{!s}__\n".format(self.header_guard))
            self.outfile.write("#define __{!s}__\n".format(self.header_guard))

        if self.symbol_decorator_header is not None:
            self.outfile.write("\n")
            self.outfile.write('#include "%s"\n' % self.symbol_decorator_header)

        self.outfile.write("\n")
        self.outfile.write("#include <gio/gio.h>\n")
        self.outfile.write("\n")
        self.outfile.write("G_BEGIN_DECLS\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def declare_infos(self):
        for i in self.ifaces:
            self.outfile.write(
                "extern %s const GDBusInterfaceInfo %s_interface;\n"
                % (self.symbol_decorator, i.name_lower)
            )

    # ----------------------------------------------------------------------------------------------------

    def generate_header_postamble(self):
        self.outfile.write("\n")
        self.outfile.write("G_END_DECLS\n")

        if not self.use_pragma:
            self.outfile.write("\n")
            self.outfile.write("#endif /* __{!s}__ */\n".format(self.header_guard))

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_header_preamble()
        self.declare_infos()
        self.generate_header_postamble()


# ----------------------------------------------------------------------------------------------------


class InterfaceInfoBodyCodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        header_name,
        input_files_basenames,
        glib_min_required,
        symbol_decoration_define,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.header_name = header_name
        self.input_files_basenames = input_files_basenames
        self.glib_min_required = glib_min_required
        self.symbol_decoration_define = symbol_decoration_define
        self.outfile = outfile

    # ----------------------------------------------------------------------------------------------------

    def generate_body_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))

        if self.symbol_decoration_define is not None:
            self.outfile.write("\n")
            self.outfile.write("#define %s\n" % self.symbol_decoration_define)

        self.outfile.write("\n")
        self.outfile.write(
            "#ifdef HAVE_CONFIG_H\n"
            '#  include "config.h"\n'
            "#endif\n"
            "\n"
            '#include "%s"\n'
            "\n"
            "#include <string.h>\n" % (self.header_name)
        )
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_array(self, array_name_lower, element_type, elements):
        self.outfile.write(
            "const %s * const %s[] =\n" % (element_type, array_name_lower)
        )
        self.outfile.write("{\n")
        for _, name in elements:
            self.outfile.write("  &%s,\n" % name)
        self.outfile.write("  NULL,\n")
        self.outfile.write("};\n")
        self.outfile.write("\n")

    def define_annotations(self, array_name_lower, annotations):
        if len(annotations) == 0:
            return

        annotation_pointers = []

        for a in annotations:
            # Skip internal annotations.
            if a.key.startswith("org.gtk.GDBus"):
                continue

            self.define_annotations(
                "%s__%s_annotations" % (array_name_lower, a.key_lower), a.annotations
            )

            self.outfile.write(
                "const GDBusAnnotationInfo %s__%s_annotation =\n"
                % (array_name_lower, a.key_lower)
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (gchar *) "%s",\n' % a.key)
            self.outfile.write('  (gchar *) "%s",\n' % a.value)
            if len(a.annotations) > 0:
                self.outfile.write(
                    "  (GDBusAnnotationInfo **) %s__%s_annotations,\n"
                    % (array_name_lower, a.key_lower)
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

            key = (a.since, "%s__%s_annotation" % (array_name_lower, a.key_lower))
            annotation_pointers.append(key)

        self.generate_array(
            array_name_lower, "GDBusAnnotationInfo", annotation_pointers
        )

    def define_args(self, array_name_lower, args):
        if len(args) == 0:
            return

        arg_pointers = []

        for a in args:
            self.define_annotations(
                "%s__%s_arg_annotations" % (array_name_lower, a.name), a.annotations
            )

            self.outfile.write(
                "const GDBusArgInfo %s__%s_arg =\n" % (array_name_lower, a.name)
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (gchar *) "%s",\n' % a.name)
            self.outfile.write('  (gchar *) "%s",\n' % a.signature)
            if len(a.annotations) > 0:
                self.outfile.write(
                    "  (GDBusAnnotationInfo **) %s__%s_arg_annotations,\n"
                    % (array_name_lower, a.name)
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

            key = (a.since, "%s__%s_arg" % (array_name_lower, a.name))
            arg_pointers.append(key)

        self.generate_array(array_name_lower, "GDBusArgInfo", arg_pointers)

    def define_infos(self):
        for i in self.ifaces:
            self.outfile.write(
                "/* ------------------------------------------------------------------------ */\n"
            )
            self.outfile.write("/* Definitions for %s */\n" % i.name)
            self.outfile.write("\n")

            # GDBusMethodInfos.
            if len(i.methods) > 0:
                method_pointers = []

                for m in i.methods:
                    self.define_args(
                        "%s_interface__%s_method_in_args"
                        % (i.name_lower, m.name_lower),
                        m.in_args,
                    )
                    self.define_args(
                        "%s_interface__%s_method_out_args"
                        % (i.name_lower, m.name_lower),
                        m.out_args,
                    )
                    self.define_annotations(
                        "%s_interface__%s_method_annotations"
                        % (i.name_lower, m.name_lower),
                        m.annotations,
                    )

                    self.outfile.write(
                        "const GDBusMethodInfo %s_interface__%s_method =\n"
                        % (i.name_lower, m.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (gchar *) "%s",\n' % m.name)
                    if len(m.in_args) > 0:
                        self.outfile.write(
                            "  (GDBusArgInfo **) %s_interface__%s_method_in_args,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no in args */\n")
                    if len(m.out_args) > 0:
                        self.outfile.write(
                            "  (GDBusArgInfo **) %s_interface__%s_method_out_args,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no out args */\n")
                    if len(m.annotations) > 0:
                        self.outfile.write(
                            "  (GDBusAnnotationInfo **) %s_interface__%s_method_annotations,\n"
                            % (i.name_lower, m.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        m.since,
                        "%s_interface__%s_method" % (i.name_lower, m.name_lower),
                    )
                    method_pointers.append(key)

                self.generate_array(
                    "%s_interface_methods" % i.name_lower,
                    "GDBusMethodInfo",
                    method_pointers,
                )

            # GDBusSignalInfos.
            if len(i.signals) > 0:
                signal_pointers = []

                for s in i.signals:
                    self.define_args(
                        "%s_interface__%s_signal_args" % (i.name_lower, s.name_lower),
                        s.args,
                    )
                    self.define_annotations(
                        "%s_interface__%s_signal_annotations"
                        % (i.name_lower, s.name_lower),
                        s.annotations,
                    )

                    self.outfile.write(
                        "const GDBusSignalInfo %s_interface__%s_signal =\n"
                        % (i.name_lower, s.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (gchar *) "%s",\n' % s.name)
                    if len(s.args) > 0:
                        self.outfile.write(
                            "  (GDBusArgInfo **) %s_interface__%s_signal_args,\n"
                            % (i.name_lower, s.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no args */\n")
                    if len(s.annotations) > 0:
                        self.outfile.write(
                            "  (GDBusAnnotationInfo **) %s_interface__%s_signal_annotations,\n"
                            % (i.name_lower, s.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        s.since,
                        "%s_interface__%s_signal" % (i.name_lower, s.name_lower),
                    )
                    signal_pointers.append(key)

                self.generate_array(
                    "%s_interface_signals" % i.name_lower,
                    "GDBusSignalInfo",
                    signal_pointers,
                )

            # GDBusPropertyInfos.
            if len(i.properties) > 0:
                property_pointers = []

                for p in i.properties:
                    if p.readable and p.writable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                    elif p.readable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE"
                    elif p.writable:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                    else:
                        flags = "G_DBUS_PROPERTY_INFO_FLAGS_NONE"

                    self.define_annotations(
                        "%s_interface__%s_property_annotations"
                        % (i.name_lower, p.name_lower),
                        p.annotations,
                    )

                    self.outfile.write(
                        "const GDBusPropertyInfo %s_interface__%s_property =\n"
                        % (i.name_lower, p.name_lower)
                    )
                    self.outfile.write("{\n")
                    self.outfile.write("  -1,  /* ref count */\n")
                    self.outfile.write('  (gchar *) "%s",\n' % p.name)
                    self.outfile.write('  (gchar *) "%s",\n' % p.signature)
                    self.outfile.write("  %s,\n" % flags)
                    if len(p.annotations) > 0:
                        self.outfile.write(
                            "  (GDBusAnnotationInfo **) %s_interface__%s_property_annotations,\n"
                            % (i.name_lower, p.name_lower)
                        )
                    else:
                        self.outfile.write("  NULL,  /* no annotations */\n")
                    self.outfile.write("};\n")
                    self.outfile.write("\n")

                    key = (
                        p.since,
                        "%s_interface__%s_property" % (i.name_lower, p.name_lower),
                    )
                    property_pointers.append(key)

                self.generate_array(
                    "%s_interface_properties" % i.name_lower,
                    "GDBusPropertyInfo",
                    property_pointers,
                )

            # Finally the GDBusInterfaceInfo.
            self.define_annotations(
                "%s_interface_annotations" % i.name_lower, i.annotations
            )

            self.outfile.write(
                "const GDBusInterfaceInfo %s_interface =\n" % i.name_lower
            )
            self.outfile.write("{\n")
            self.outfile.write("  -1,  /* ref count */\n")
            self.outfile.write('  (gchar *) "%s",\n' % i.name)
            if len(i.methods) > 0:
                self.outfile.write(
                    "  (GDBusMethodInfo **) %s_interface_methods,\n" % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no methods */\n")
            if len(i.signals) > 0:
                self.outfile.write(
                    "  (GDBusSignalInfo **) %s_interface_signals,\n" % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no signals */\n")
            if len(i.properties) > 0:
                self.outfile.write(
                    "  (GDBusPropertyInfo **) %s_interface_properties,\n" % i.name_lower
                )
            else:
                self.outfile.write("NULL,  /* no properties */\n")
            if len(i.annotations) > 0:
                self.outfile.write(
                    "  (GDBusAnnotationInfo **) %s_interface_annotations,\n"
                    % i.name_lower
                )
            else:
                self.outfile.write("  NULL,  /* no annotations */\n")
            self.outfile.write("};\n")
            self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate(self):
        self.generate_body_preamble()
        self.define_infos()


# ----------------------------------------------------------------------------------------------------


class CodeGenerator:
    def __init__(
        self,
        ifaces,
        namespace,
        generate_objmanager,
        header_name,
        input_files_basenames,
        docbook_gen,
        glib_min_required,
        symbol_decoration_define,
        outfile,
    ):
        self.ifaces = ifaces
        self.namespace, self.ns_upper, self.ns_lower = generate_namespace(namespace)
        self.generate_objmanager = generate_objmanager
        self.header_name = header_name
        self.input_files_basenames = input_files_basenames
        self.docbook_gen = docbook_gen
        self.glib_min_required = glib_min_required
        self.symbol_decoration_define = symbol_decoration_define
        self.outfile = outfile
        self.marshallers = set()

    # ----------------------------------------------------------------------------------------------------

    def generate_body_preamble(self):
        basenames = ", ".join(self.input_files_basenames)
        self.outfile.write(LICENSE_STR.format(config.VERSION, basenames))
        if self.symbol_decoration_define is not None:
            self.outfile.write("\n")
            self.outfile.write("#define %s\n" % self.symbol_decoration_define)
        self.outfile.write("\n")
        self.outfile.write(
            "#ifdef HAVE_CONFIG_H\n"
            '#  include "config.h"\n'
            "#endif\n"
            "\n"
            '#include "%s"\n'
            "\n"
            "#include <string.h>\n" % (self.header_name)
        )

        self.outfile.write(
            "#ifdef G_OS_UNIX\n" "#  include <gio/gunixfdlist.h>\n" "#endif\n" "\n"
        )

        self.outfile.write(
            """#ifdef G_ENABLE_DEBUG
#define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
#define g_marshal_value_peek_char(v)     g_value_get_schar (v)
#define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
#define g_marshal_value_peek_int(v)      g_value_get_int (v)
#define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
#define g_marshal_value_peek_long(v)     g_value_get_long (v)
#define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
#define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
#define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
#define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
#define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
#define g_marshal_value_peek_float(v)    g_value_get_float (v)
#define g_marshal_value_peek_double(v)   g_value_get_double (v)
#define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
#define g_marshal_value_peek_param(v)    g_value_get_param (v)
#define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
#define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
#define g_marshal_value_peek_object(v)   g_value_get_object (v)
#define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
#else /* !G_ENABLE_DEBUG */
/* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
 *          Do not access GValues directly in your code. Instead, use the
 *          g_value_get_*() functions
 */
#define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
#define g_marshal_value_peek_char(v)     (v)->data[0].v_int
#define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
#define g_marshal_value_peek_int(v)      (v)->data[0].v_int
#define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
#define g_marshal_value_peek_long(v)     (v)->data[0].v_long
#define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
#define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
#define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
#define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
#define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
#define g_marshal_value_peek_float(v)    (v)->data[0].v_float
#define g_marshal_value_peek_double(v)   (v)->data[0].v_double
#define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
#define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
#define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
#define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
#define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
#define g_marshal_value_peek_variant(v)  (v)->data[0].v_pointer
#endif /* !G_ENABLE_DEBUG */"""
            "\n\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  GDBusArgInfo parent_struct;\n"
            "  gboolean use_gvariant;\n"
            "} _ExtendedGDBusArgInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  GDBusMethodInfo parent_struct;\n"
            "  const gchar *signal_name;\n"
            "  gboolean pass_fdlist;\n"
            "} _ExtendedGDBusMethodInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  GDBusSignalInfo parent_struct;\n"
            "  const gchar *signal_name;\n"
            "} _ExtendedGDBusSignalInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  GDBusPropertyInfo parent_struct;\n"
            "  const gchar *hyphen_name;\n"
            "  guint use_gvariant : 1;\n"
            "  guint emits_changed_signal : 1;\n"
            "} _ExtendedGDBusPropertyInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  GDBusInterfaceInfo parent_struct;\n"
            "  const gchar *hyphen_name;\n"
            "} _ExtendedGDBusInterfaceInfo;\n"
            "\n"
        )

        self.outfile.write(
            "typedef struct\n"
            "{\n"
            "  const _ExtendedGDBusPropertyInfo *info;\n"
            "  guint prop_id;\n"
            "  GValue orig_value; /* the value before the change */\n"
            "} ChangedProperty;\n"
            "\n"
            "static void\n"
            "_changed_property_free (ChangedProperty *data)\n"
            "{\n"
            "  g_value_unset (&data->orig_value);\n"
            "  g_free (data);\n"
            "}\n"
            "\n"
        )

        self.outfile.write(
            "static gboolean\n"
            "_g_strv_equal0 (gchar **a, gchar **b)\n"
            "{\n"
            "  gboolean ret = FALSE;\n"
            "  guint n;\n"
            "  if (a == NULL && b == NULL)\n"
            "    {\n"
            "      ret = TRUE;\n"
            "      goto out;\n"
            "    }\n"
            "  if (a == NULL || b == NULL)\n"
            "    goto out;\n"
            "  if (g_strv_length (a) != g_strv_length (b))\n"
            "    goto out;\n"
            "  for (n = 0; a[n] != NULL; n++)\n"
            "    if (g_strcmp0 (a[n], b[n]) != 0)\n"
            "      goto out;\n"
            "  ret = TRUE;\n"
            "out:\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

        self.outfile.write(
            "static gboolean\n"
            "_g_variant_equal0 (GVariant *a, GVariant *b)\n"
            "{\n"
            "  gboolean ret = FALSE;\n"
            "  if (a == NULL && b == NULL)\n"
            "    {\n"
            "      ret = TRUE;\n"
            "      goto out;\n"
            "    }\n"
            "  if (a == NULL || b == NULL)\n"
            "    goto out;\n"
            "  ret = g_variant_equal (a, b);\n"
            "out:\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

        # simplified - only supports the types we use
        self.outfile.write(
            "G_GNUC_UNUSED static gboolean\n"
            "_g_value_equal (const GValue *a, const GValue *b)\n"
            "{\n"
            "  gboolean ret = FALSE;\n"
            "  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));\n"
            "  switch (G_VALUE_TYPE (a))\n"
            "    {\n"
            "      case G_TYPE_BOOLEAN:\n"
            "        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));\n"
            "        break;\n"
            "      case G_TYPE_UCHAR:\n"
            "        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));\n"
            "        break;\n"
            "      case G_TYPE_INT:\n"
            "        ret = (g_value_get_int (a) == g_value_get_int (b));\n"
            "        break;\n"
            "      case G_TYPE_UINT:\n"
            "        ret = (g_value_get_uint (a) == g_value_get_uint (b));\n"
            "        break;\n"
            "      case G_TYPE_INT64:\n"
            "        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));\n"
            "        break;\n"
            "      case G_TYPE_UINT64:\n"
            "        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));\n"
            "        break;\n"
            "      case G_TYPE_DOUBLE:\n"
            "        {\n"
            "          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */\n"
            "          gdouble da = g_value_get_double (a);\n"
            "          gdouble db = g_value_get_double (b);\n"
            "          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;\n"
            "        }\n"
            "        break;\n"
            "      case G_TYPE_STRING:\n"
            "        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);\n"
            "        break;\n"
            "      case G_TYPE_VARIANT:\n"
            "        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));\n"
            "        break;\n"
            "      default:\n"
            "        if (G_VALUE_TYPE (a) == G_TYPE_STRV)\n"
            "          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));\n"
            "        else\n"
            '          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));\n'
            "        break;\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n"
        )

    def generate_annotations(self, prefix, annotations):
        if annotations is None:
            return

        n = 0
        for a in annotations:
            # self.generate_annotations('%s_%d'%(prefix, n), a.get_annotations())

            # skip internal annotations
            if a.key.startswith("org.gtk.GDBus"):
                continue

            self.outfile.write(
                "static const GDBusAnnotationInfo %s_%d =\n"
                "{\n"
                "  -1,\n"
                '  (gchar *) "%s",\n'
                '  (gchar *) "%s",\n' % (prefix, n, a.key, a.value)
            )
            if len(a.annotations) == 0:
                self.outfile.write("  NULL\n")
            else:
                self.outfile.write(
                    "  (GDBusAnnotationInfo **) &%s_%d_pointers\n" % (prefix, n)
                )
            self.outfile.write("};\n" "\n")
            n += 1

        if n > 0:
            self.outfile.write(
                "static const GDBusAnnotationInfo * const %s_pointers[] =\n"
                "{\n" % (prefix)
            )
            m = 0
            for a in annotations:
                if a.key.startswith("org.gtk.GDBus"):
                    continue
                self.outfile.write("  &%s_%d,\n" % (prefix, m))
                m += 1
            self.outfile.write("  NULL\n" "};\n" "\n")
        return n

    def generate_args(self, prefix, args):
        for a in args:
            num_anno = self.generate_annotations(
                "%s_arg_%s_annotation_info" % (prefix, a.name), a.annotations
            )

            self.outfile.write(
                "static const _ExtendedGDBusArgInfo %s_%s =\n"
                "{\n"
                "  {\n"
                "    -1,\n"
                '    (gchar *) "%s",\n'
                '    (gchar *) "%s",\n' % (prefix, a.name, a.name, a.signature)
            )
            if num_anno == 0:
                self.outfile.write("    NULL\n")
            else:
                self.outfile.write(
                    "    (GDBusAnnotationInfo **) &%s_arg_%s_annotation_info_pointers\n"
                    % (prefix, a.name)
                )
            self.outfile.write("  },\n")
            if not utils.lookup_annotation(
                a.annotations, "org.gtk.GDBus.C.ForceGVariant"
            ):
                self.outfile.write("  FALSE\n")
            else:
                self.outfile.write("  TRUE\n")
            self.outfile.write("};\n" "\n")

        if len(args) > 0:
            self.outfile.write(
                "static const GDBusArgInfo * const %s_pointers[] =\n" "{\n" % (prefix)
            )
            for a in args:
                self.outfile.write("  &%s_%s.parent_struct,\n" % (prefix, a.name))
            self.outfile.write("  NULL\n" "};\n" "\n")

    def generate_signals_enum_for_interface(self, i):
        if not i.signals:
            return

        self.outfile.write("enum\n{\n")
        for s in i.signals:
            self.outfile.write(f"  {s.upper_id_name},\n")
        self.outfile.write("};\n" "\n")

        self.outfile.write(
            "static unsigned "
            f"{i.signals_enum_name}[{len(i.signals)}] = {{ 0 }};"
            "\n"
            "\n"
        )

    def generate_introspection_for_interface(self, i):
        self.outfile.write(
            "/* ---- Introspection data for %s ---- */\n" "\n" % (i.name)
        )

        if len(i.methods) > 0:
            for m in i.methods:
                self.generate_args(
                    "_%s_method_info_%s_IN_ARG" % (i.name_lower, m.name_lower),
                    m.in_args,
                )
                self.generate_args(
                    "_%s_method_info_%s_OUT_ARG" % (i.name_lower, m.name_lower),
                    m.out_args,
                )

                num_anno = self.generate_annotations(
                    "_%s_method_%s_annotation_info" % (i.name_lower, m.name_lower),
                    m.annotations,
                )

                self.outfile.write(
                    "static const _ExtendedGDBusMethodInfo _%s_method_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (gchar *) "%s",\n' % (i.name_lower, m.name_lower, m.name)
                )
                if len(m.in_args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (GDBusArgInfo **) &_%s_method_info_%s_IN_ARG_pointers,\n"
                        % (i.name_lower, m.name_lower)
                    )
                if len(m.out_args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (GDBusArgInfo **) &_%s_method_info_%s_OUT_ARG_pointers,\n"
                        % (i.name_lower, m.name_lower)
                    )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (GDBusAnnotationInfo **) &_%s_method_%s_annotation_info_pointers\n"
                        % (i.name_lower, m.name_lower)
                    )
                self.outfile.write(
                    "  },\n"
                    '  "handle-%s",\n'
                    "  %s\n" % (m.name_hyphen, "TRUE" if m.unix_fd else "FALSE")
                )
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const GDBusMethodInfo * const _%s_method_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for m in i.methods:
                self.outfile.write(
                    "  &_%s_method_info_%s.parent_struct,\n"
                    % (i.name_lower, m.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        # ---

        if len(i.signals) > 0:
            for s in i.signals:
                self.generate_args(
                    "_%s_signal_info_%s_ARG" % (i.name_lower, s.name_lower), s.args
                )

                num_anno = self.generate_annotations(
                    "_%s_signal_%s_annotation_info" % (i.name_lower, s.name_lower),
                    s.annotations,
                )
                self.outfile.write(
                    "static const _ExtendedGDBusSignalInfo _%s_signal_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (gchar *) "%s",\n' % (i.name_lower, s.name_lower, s.name)
                )
                if len(s.args) == 0:
                    self.outfile.write("    NULL,\n")
                else:
                    self.outfile.write(
                        "    (GDBusArgInfo **) &_%s_signal_info_%s_ARG_pointers,\n"
                        % (i.name_lower, s.name_lower)
                    )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (GDBusAnnotationInfo **) &_%s_signal_%s_annotation_info_pointers\n"
                        % (i.name_lower, s.name_lower)
                    )
                self.outfile.write("  },\n" '  "%s"\n' % (s.name_hyphen))
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const GDBusSignalInfo * const _%s_signal_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for s in i.signals:
                self.outfile.write(
                    "  &_%s_signal_info_%s.parent_struct,\n"
                    % (i.name_lower, s.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        # ---

        if len(i.properties) > 0:
            for p in i.properties:
                if p.readable and p.writable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE | G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                elif p.readable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_READABLE"
                elif p.writable:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE"
                else:
                    access = "G_DBUS_PROPERTY_INFO_FLAGS_NONE"
                num_anno = self.generate_annotations(
                    "_%s_property_%s_annotation_info" % (i.name_lower, p.name_lower),
                    p.annotations,
                )
                self.outfile.write(
                    "static const _ExtendedGDBusPropertyInfo _%s_property_info_%s =\n"
                    "{\n"
                    "  {\n"
                    "    -1,\n"
                    '    (gchar *) "%s",\n'
                    '    (gchar *) "%s",\n'
                    "    %s,\n"
                    % (i.name_lower, p.name_lower, p.name, p.arg.signature, access)
                )
                if num_anno == 0:
                    self.outfile.write("    NULL\n")
                else:
                    self.outfile.write(
                        "    (GDBusAnnotationInfo **) &_%s_property_%s_annotation_info_pointers\n"
                        % (i.name_lower, p.name_lower)
                    )
                self.outfile.write("  },\n" '  "%s",\n' % (p.name_hyphen))
                if not utils.lookup_annotation(
                    p.annotations, "org.gtk.GDBus.C.ForceGVariant"
                ):
                    self.outfile.write("  FALSE,\n")
                else:
                    self.outfile.write("  TRUE,\n")
                if p.emits_changed_signal:
                    self.outfile.write("  TRUE\n")
                else:
                    self.outfile.write("  FALSE\n")
                self.outfile.write("};\n" "\n")

            self.outfile.write(
                "static const GDBusPropertyInfo * const _%s_property_info_pointers[] =\n"
                "{\n" % (i.name_lower)
            )
            for p in i.properties:
                self.outfile.write(
                    "  &_%s_property_info_%s.parent_struct,\n"
                    % (i.name_lower, p.name_lower)
                )
            self.outfile.write("  NULL\n" "};\n" "\n")

        num_anno = self.generate_annotations(
            "_%s_annotation_info" % (i.name_lower), i.annotations
        )
        self.outfile.write(
            "static const _ExtendedGDBusInterfaceInfo _%s_interface_info =\n"
            "{\n"
            "  {\n"
            "    -1,\n"
            '    (gchar *) "%s",\n' % (i.name_lower, i.name)
        )
        if len(i.methods) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (GDBusMethodInfo **) &_%s_method_info_pointers,\n" % (i.name_lower)
            )
        if len(i.signals) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (GDBusSignalInfo **) &_%s_signal_info_pointers,\n" % (i.name_lower)
            )
        if len(i.properties) == 0:
            self.outfile.write("    NULL,\n")
        else:
            self.outfile.write(
                "    (GDBusPropertyInfo **) &_%s_property_info_pointers,\n"
                % (i.name_lower)
            )
        if num_anno == 0:
            self.outfile.write("    NULL\n")
        else:
            self.outfile.write(
                "    (GDBusAnnotationInfo **) &_%s_annotation_info_pointers\n"
                % (i.name_lower)
            )
        self.outfile.write("  },\n" '  "%s",\n' "};\n" "\n" % (i.name_hyphen))
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_interface_info:\n"
                " *\n"
                " * Gets a machine-readable description of the #%s D-Bus interface.\n"
                " *\n"
                " * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.\n"
                % (i.name_lower, i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "GDBusInterfaceInfo *\n"
            "%s_interface_info (void)\n"
            "{\n"
            "  return (GDBusInterfaceInfo *) &_%s_interface_info.parent_struct;\n"
            "}\n"
            "\n" % (i.name_lower, i.name_lower)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_override_properties:\n"
                " * @klass: The class structure for a #GObject derived class.\n"
                " * @property_id_begin: The property id to assign to the first overridden property.\n"
                " *\n"
                " * Overrides all #GObject properties in the #%s interface for a concrete class.\n"
                " * The properties are overridden in the order they are defined.\n"
                " *\n"
                " * Returns: The last property id.\n" % (i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "guint\n" "%s_override_properties (GObjectClass *klass" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED")
        self.outfile.write(", guint property_id_begin)\n" "{\n")
        for p in i.properties:
            self.outfile.write(
                '  g_object_class_override_property (klass, property_id_begin++, "%s");\n'
                % (p.name_hyphen)
            )
        self.outfile.write("  return property_id_begin - 1;\n" "}\n" "\n")
        self.outfile.write("\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_interface(self, i):
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s:\n"
                " *\n"
                " * Abstract interface type for the D-Bus interface #%s.\n"
                % (i.camel_name, i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sIface:\n"
                " * @parent_iface: The parent interface.\n" % (i.camel_name),
                False,
            )
        )

        doc_bits = {}
        if len(i.methods) > 0:
            for m in i.methods:
                key = (m.since, "_method_%s" % m.name_lower)
                value = "@handle_%s: " % (m.name_lower)
                value += "Handler for the #%s::handle-%s signal." % (
                    i.camel_name,
                    m.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.signals) > 0:
            for s in i.signals:
                key = (s.since, "_signal_%s" % s.name_lower)
                value = "@%s: " % (s.name_lower)
                value += "Handler for the #%s::%s signal." % (
                    i.camel_name,
                    s.name_hyphen,
                )
                doc_bits[key] = value
        if len(i.properties) > 0:
            for p in i.properties:
                key = (p.since, "_prop_get_%s" % p.name_lower)
                value = "@get_%s: " % (p.name_lower)
                value += "Getter for the #%s:%s property." % (
                    i.camel_name,
                    p.name_hyphen,
                )
                doc_bits[key] = value
        for key in sorted(doc_bits.keys(), key=utils.version_cmp_key):
            self.outfile.write(" * %s\n" % doc_bits[key])

        self.outfile.write(
            self.docbook_gen.expand(
                " *\n" " * Virtual table for the D-Bus interface #%s.\n" % (i.name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sIface %sInterface;\n" % (i.camel_name, i.camel_name)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE (%s, %s, G_TYPE_OBJECT)\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write("\n")

        self.outfile.write(
            "static void\n"
            "%s_default_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.methods) == 0 and len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.methods) > 0:
            self.outfile.write(
                "  /* GObject signals for incoming D-Bus method calls: */\n"
            )
            for m in i.methods:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::handle-%s:\n"
                        "   * @object: A #%s.\n"
                        "   * @invocation: A #GDBusMethodInvocation.\n"
                        % (i.camel_name, m.name_hyphen, i.camel_name),
                        False,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(
                        "   * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                    )
                for a in m.in_args:
                    self.outfile.write(
                        "   * @arg_%s: Argument passed by remote caller.\n" % (a.name)
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * Signal emitted when a remote caller is invoking the %s.%s() D-Bus method.\n"
                        "   *\n"
                        "   * If a signal handler returns %%TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call %s_complete_%s() or e.g. g_dbus_method_invocation_return_error() on it) and no other signal handlers will run. If no signal handler handles the invocation, the %%G_DBUS_ERROR_UNKNOWN_METHOD error is returned.\n"
                        "   *\n"
                        "   * Returns: %%G_DBUS_METHOD_INVOCATION_HANDLED or %%TRUE if the invocation was handled, %%G_DBUS_METHOD_INVOCATION_UNHANDLED or %%FALSE to let other signal handlers run.\n"
                        % (i.name, m.name, i.name_lower, m.name_lower),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 2)
                if m.unix_fd:
                    extra_args = 2
                else:
                    extra_args = 1
                self.outfile.write(
                    '  g_signal_new ("handle-%s",\n'
                    "    G_TYPE_FROM_INTERFACE (iface),\n"
                    "    G_SIGNAL_RUN_LAST,\n"
                    "    G_STRUCT_OFFSET (%sIface, handle_%s),\n"
                    "    g_signal_accumulator_true_handled,\n"
                    "    NULL,\n"  # accu_data
                    f"      {i.name_lower}_method_marshal_{m.name_lower},\n"
                    "    G_TYPE_BOOLEAN,\n"
                    "    %d,\n"
                    "    G_TYPE_DBUS_METHOD_INVOCATION"
                    % (
                        m.name_hyphen,
                        i.camel_name,
                        m.name_lower,
                        len(m.in_args) + extra_args,
                    )
                )
                if m.unix_fd:
                    self.outfile.write(", G_TYPE_UNIX_FD_LIST")
                for a in m.in_args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.signals) > 0:
            self.outfile.write("  /* GObject signals for received D-Bus signals: */\n")
            for s in i.signals:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s::%s:\n"
                        "   * @object: A #%s.\n"
                        % (i.camel_name, s.name_hyphen, i.camel_name),
                        False,
                    )
                )
                for a in s.args:
                    self.outfile.write("   * @arg_%s: Argument.\n" % (a.name))
                self.outfile.write(
                    self.docbook_gen.expand(
                        "   *\n"
                        "   * On the client-side, this signal is emitted whenever the D-Bus signal #%s::%s is received.\n"
                        "   *\n"
                        "   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.\n"
                        % (i.name, s.name),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 2)
                self.outfile.write(
                    f"  {i.signals_enum_name}[{s.upper_id_name}] =\n"
                    '    g_signal_new ("%s",\n'
                    "      G_TYPE_FROM_INTERFACE (iface),\n"
                    "      G_SIGNAL_RUN_LAST,\n"
                    "      G_STRUCT_OFFSET (%sIface, %s),\n"
                    "      NULL,\n"  # accumulator
                    "      NULL,\n"  # accu_data
                    f"      {i.name_lower}_signal_marshal_{s.name_lower},\n"
                    "      G_TYPE_NONE,\n"
                    "      %d"
                    % (s.name_hyphen, i.camel_name, s.name_lower, len(s.args))
                )
                for a in s.args:
                    self.outfile.write(", %s" % (a.gtype))
                self.outfile.write(");\n")
                self.outfile.write("\n")

        if len(i.properties) > 0:
            self.outfile.write("  /* GObject properties for D-Bus properties: */\n")
            for p in i.properties:
                if p.readable and p.writable:
                    hint = "Since the D-Bus property for this #GObject property is both readable and writable, it is meaningful to both read from it and write to it on both the service- and client-side."
                elif p.readable:
                    hint = "Since the D-Bus property for this #GObject property is readable but not writable, it is meaningful to read from it on both the client- and service-side. It is only meaningful, however, to write to it on the service-side."
                elif p.writable:
                    hint = "Since the D-Bus property for this #GObject property is writable but not readable, it is meaningful to write to it on both the client- and service-side. It is only meaningful, however, to read from it on the service-side."
                else:
                    print_error(
                        'Cannot handle property "{}" that neither readable nor writable'.format(
                            p.name
                        )
                    )
                self.outfile.write(
                    self.docbook_gen.expand(
                        "  /**\n"
                        "   * %s:%s:\n"
                        "   *\n"
                        "   * Represents the D-Bus property #%s:%s.\n"
                        "   *\n"
                        "   * %s\n"
                        % (i.camel_name, p.name_hyphen, i.name, p.name, hint),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 2)
                self.outfile.write("  g_object_interface_install_property (iface,\n")
                if p.arg.gtype == "G_TYPE_VARIANT":
                    s = (
                        'g_param_spec_variant ("%s", "%s", "%s", G_VARIANT_TYPE ("%s"), NULL'
                        % (p.name_hyphen, p.name, p.name, p.arg.signature)
                    )
                elif p.arg.signature == "b":
                    s = 'g_param_spec_boolean ("%s", "%s", "%s", FALSE' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "y":
                    s = 'g_param_spec_uchar ("%s", "%s", "%s", 0, 255, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "n":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT16, G_MAXINT16, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "q":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT16, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "i":
                    s = (
                        'g_param_spec_int ("%s", "%s", "%s", G_MININT32, G_MAXINT32, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "u":
                    s = 'g_param_spec_uint ("%s", "%s", "%s", 0, G_MAXUINT32, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "x":
                    s = (
                        'g_param_spec_int64 ("%s", "%s", "%s", G_MININT64, G_MAXINT64, 0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "t":
                    s = 'g_param_spec_uint64 ("%s", "%s", "%s", 0, G_MAXUINT64, 0' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "d":
                    s = (
                        'g_param_spec_double ("%s", "%s", "%s", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0'
                        % (p.name_hyphen, p.name, p.name)
                    )
                elif p.arg.signature == "s":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "o":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "g":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ay":
                    s = 'g_param_spec_string ("%s", "%s", "%s", NULL' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "as":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "ao":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                elif p.arg.signature == "aay":
                    s = 'g_param_spec_boxed ("%s", "%s", "%s", G_TYPE_STRV' % (
                        p.name_hyphen,
                        p.name,
                        p.name,
                    )
                else:
                    print_error(
                        'Unsupported gtype "{}" for GParamSpec'.format(p.arg.gtype)
                    )
                flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
                if p.deprecated:
                    flags = "G_PARAM_DEPRECATED | " + flags
                self.outfile.write("    %s, %s));" % (s, flags))
                self.outfile.write("\n")

        self.outfile.write("}\n" "\n")

    # ----------------------------------------------------------------------------------------------------

    def generate_property_accessors(self, i):
        for p in i.properties:
            # getter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is readable, it is meaningful to use this function on both the client- and service-side."
            elif p.writable:
                hint = "Since this D-Bus property is not readable, it is only meaningful to use this function on the service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_get_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " *\n"
                    " * Gets the value of the #%s:%s D-Bus property.\n"
                    " *\n"
                    " * %s\n"
                    " *\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            if p.arg.free_func is not None:
                self.outfile.write(
                    " * The returned value is only valid until the property changes so on the client-side it is only safe to use this function on the thread where @object was constructed. Use %s_dup_%s() if on another thread.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): The property value or %%NULL if the property is not set. Do not free the returned value, it belongs to @object.\n"
                    % (i.name_lower, p.name_lower)
                )
            else:
                self.outfile.write(" * Returns: The property value.\n")
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "%s\n"
                "%s_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  g_return_val_if_fail (%sIS_%s (object), %s);\n"
                "\n"
                "  return %s%s_GET_IFACE (object)->get_%s (object);\n"
                % (
                    i.ns_upper,
                    i.name_upper,
                    p.arg.ctype_in_default_value,
                    i.ns_upper,
                    i.name_upper,
                    p.name_lower,
                )
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")
            if p.arg.free_func is not None:
                self.outfile.write(
                    self.docbook_gen.expand(
                        "/**\n"
                        " * %s_dup_%s: (skip)\n"
                        " * @object: A #%s.\n"
                        " *\n"
                        " * Gets a copy of the #%s:%s D-Bus property.\n"
                        " *\n"
                        " * %s\n"
                        " *\n"
                        " * Returns: (transfer full) (nullable): The property value or %%NULL if the property is not set. The returned value should be freed with %s().\n"
                        % (
                            i.name_lower,
                            p.name_lower,
                            i.camel_name,
                            i.name,
                            p.name,
                            hint,
                            p.arg.free_func,
                        ),
                        False,
                    )
                )
                self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
                self.outfile.write(
                    "%s\n"
                    "%s_dup_%s (%s *object)\n"
                    "{\n"
                    "  %svalue;\n"
                    % (
                        p.arg.ctype_in_dup,
                        i.name_lower,
                        p.name_lower,
                        i.camel_name,
                        p.arg.ctype_in_dup,
                    )
                )
                self.outfile.write(
                    '  g_object_get (G_OBJECT (object), "%s", &value, NULL);\n'
                    % (p.name_hyphen)
                )
                self.outfile.write("  return value;\n")
                self.outfile.write("}\n")
                self.outfile.write("\n")

            # setter
            if p.readable and p.writable:
                hint = "Since this D-Bus property is both readable and writable, it is meaningful to use this function on both the client- and service-side."
            elif p.readable:
                hint = "Since this D-Bus property is not writable, it is only meaningful to use this function on the service-side."
            elif p.writable:
                hint = "Since this D-Bus property is writable, it is meaningful to use this function on both the client- and service-side."
            else:
                print_error(
                    'Cannot handle property "{}" that neither readable nor writable'.format(
                        p.name
                    )
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_set_%s: (skip)\n"
                    " * @object: A #%s.\n"
                    " * @value: The value to set.\n"
                    " *\n"
                    " * Sets the #%s:%s D-Bus property to @value.\n"
                    " *\n"
                    " * %s\n"
                    % (i.name_lower, p.name_lower, i.camel_name, i.name, p.name, hint),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(p, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_set_%s (%s *object, %svalue)\n"
                "{\n" % (i.name_lower, p.name_lower, i.camel_name, p.arg.ctype_in)
            )
            self.outfile.write(
                '  g_object_set (G_OBJECT (object), "%s", value, NULL);\n'
                % (p.name_hyphen)
            )
            self.outfile.write("}\n")
            self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_signal_emitters(self, i):
        for s in i.signals:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %s_emit_%s:\n"
                    " * @object: A #%s.\n" % (i.name_lower, s.name_lower, i.camel_name),
                    False,
                )
            )
            for a in s.args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the signal.\n" % (a.name)
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n" " * Emits the #%s::%s D-Bus signal.\n" % (i.name, s.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(s, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_emit_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n"
                "{\n"
                "  g_signal_emit (object, "
                f"{i.signals_enum_name}[{s.upper_id_name}], 0"
            )
            for a in s.args:
                self.outfile.write(", arg_%s" % a.name)
            self.outfile.write(");\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_marshaller(self, func_name, in_args, ret_arg=None):
        self.generate_marshaller_declaration(func_name, uses_ret=ret_arg is not None)
        self.outfile.write("{\n")
        self.generate_marshaller_body(func_name, in_args, ret_arg)
        self.outfile.write("}\n" "\n")

    def generate_marshaller_wrapper(self, wrapper_name, wrapped_func):
        self.generate_marshaller_declaration(
            wrapper_name,
            uses_ret=True,
            uses_hint=True,
            inline=True,
        )
        self.outfile.write("{\n")
        self.outfile.write(
            f"  {wrapped_func} (closure,\n"
            "    return_value, n_param_values, param_values, "
            "invocation_hint, marshal_data);\n"
        )
        self.outfile.write("}\n" "\n")

    def generate_marshaller_declaration(
        self, func_name, uses_ret=False, uses_hint=False, inline=False
    ):
        self.outfile.write(
            f"{'inline ' if inline else ''}static void\n"
            f"{func_name} (\n"
            "    GClosure     *closure,\n"
            f"    GValue       *return_value{' G_GNUC_UNUSED' if not uses_ret else ''},\n"
            "    unsigned int  n_param_values,\n"
            "    const GValue *param_values,\n"
            f"    void         *invocation_hint{' G_GNUC_UNUSED' if not uses_hint else ''},\n"
            "    void         *marshal_data)\n"
        )

    def generate_marshaller_body(self, func_name, in_args=[], ret_arg=None):
        marshal_func_type = f"{utils.uscore_to_camel_case(func_name)}Func"
        self.outfile.write(
            f"  typedef {ret_arg.ctype_in if ret_arg else 'void '}(*{marshal_func_type})\n"
            "       (void *data1,\n"
            + "".join([f"        {a.ctype_in}arg_{a.name},\n" for a in in_args])
            + "        void *data2);\n"
            f"  {marshal_func_type} callback;\n"
            "  GCClosure *cc = (GCClosure*) closure;\n"
            f"  void *data1, *data2;\n"
        )

        if ret_arg:
            self.outfile.write(
                f"  {ret_arg.ctype_in}v_return;\n"
                "\n"
                "  g_return_if_fail (return_value != NULL);"
            )

        self.outfile.write(
            "\n"
            f"  g_return_if_fail (n_param_values == {len(in_args) + 1});\n"
            "\n"
            "  if (G_CCLOSURE_SWAP_DATA (closure))\n"
            "    {\n"
            "      data1 = closure->data;\n"
            "      data2 = g_value_peek_pointer (param_values + 0);\n"
            "    }\n"
            "  else\n"
            "    {\n"
            "      data1 = g_value_peek_pointer (param_values + 0);\n"
            "      data2 = closure->data;\n"
            "    }\n"
            "\n"
            f"  callback = ({marshal_func_type})\n"
            "    (marshal_data ? marshal_data : cc->callback);\n"
            "\n"
        )

        prefix = ""
        if ret_arg:
            self.outfile.write("  v_return =\n")
            prefix = 2 * " "

        self.outfile.write(
            f"{prefix}  callback (data1,\n"
            + "".join(
                [
                    f"{prefix}            {in_args[i].gvalue_get} (param_values + {i+1}),\n"
                    for i in range(len(in_args))
                ]
            )
            + f"{prefix}            data2);\n"
        )

        if ret_arg:
            self.outfile.write(
                "\n" f"  {ret_arg.gvalue_set} (return_value, v_return);\n"
            )

    def generic_marshaller_name(self, args=[], ret=None):
        name = "_g_dbus_codegen_marshal_"
        name += f"{ret.gvalue_type.upper() if ret else 'VOID'}__"
        if args:
            name += "_".join(f"{a.gvalue_type.upper()}" for a in args)
        else:
            name += "VOID"
        return name

    def generic_marshaller_name_for_type(self, t):
        assert isinstance(t, (dbustypes.Signal, dbustypes.Method))

        if not t.marshaller_ret_arg:
            if not t.marshaller_in_args:
                return "g_cclosure_marshal_VOID__VOID"
            elif (
                len(t.marshaller_in_args) == 1
                and t.marshaller_in_args[0].gclosure_marshaller
            ):
                return t.marshaller_in_args[0].gclosure_marshaller

        return self.generic_marshaller_name(t.marshaller_in_args, t.marshaller_ret_arg)

    def generate_generic_marshallers(self, i):
        for t in i.signals + i.methods:
            marshaller_name = self.generic_marshaller_name_for_type(t)
            if marshaller_name.startswith("g_cclosure_"):
                self.marshallers.add(marshaller_name)
                continue

            if marshaller_name in self.marshallers:
                continue

            self.generate_marshaller(
                marshaller_name, t.marshaller_in_args, t.marshaller_ret_arg
            )
            self.marshallers.add(marshaller_name)

    def generate_marshaller_for_type(self, i, t):
        assert isinstance(t, (dbustypes.Signal, dbustypes.Method))

        kind_uscore = utils.camel_case_to_uscore(t.__class__.__name__.lower())
        func_name = f"{i.name_lower}_{kind_uscore}_marshal_{t.name_lower}"
        marshaller_name = self.generic_marshaller_name_for_type(t)
        assert marshaller_name in self.marshallers

        self.generate_marshaller_wrapper(func_name, marshaller_name)

    def generate_signal_marshallers(self, i):
        for s in i.signals:
            self.generate_marshaller_for_type(i, s)

    def generate_method_marshallers(self, i):
        for m in i.methods:
            self.generate_marshaller_for_type(i, m)

    # ---------------------------------------------------------------------------------------------------

    def generate_method_calls(self, i):
        for m in i.methods:
            # async begin
            self.outfile.write(
                "/**\n"
                " * %s_call_%s:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                    " * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %%NULL.\n"
                    " * @user_data: User data to pass to @callback.\n"
                    " *\n"
                    " * Asynchronously invokes the %s.%s() D-Bus method on @proxy.\n"
                    " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                    " * You can then call %s_call_%s_finish() to get the result of the operation.\n"
                    " *\n"
                    " * See %s_call_%s_sync() for the synchronous, blocking version of this method.\n"
                    % (
                        i.name,
                        m.name,
                        i.name_lower,
                        m.name_lower,
                        i.name_lower,
                        m.name_lower,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_call_%s (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    gint timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList *fd_list")
            self.outfile.write(
                ",\n"
                "    GCancellable *cancellable,\n"
                "    GAsyncReadyCallback callback,\n"
                "    gpointer user_data)\n"
                "{\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  g_dbus_proxy_call_with_unix_fd_list (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write("  g_dbus_proxy_call (G_DBUS_PROXY (proxy),\n")
            self.outfile.write('    "%s",\n' '    g_variant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n")
            self.outfile.write(
                "    cancellable,\n" "    callback,\n" "    user_data);\n"
            )
            self.outfile.write("}\n" "\n")
            # async finish
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_finish:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out) (optional): Return location for a #GUnixFDList or %NULL to ignore.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_call_%s().\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Finishes an operation started with %s_call_%s().\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name_lower, m.name_lower, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "gboolean\n"
                "%s_call_%s_finish (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList **out_fd_list")
            self.outfile.write(
                ",\n"
                "    GAsyncResult *res,\n"
                "    GError **error)\n"
                "{\n"
                "  GVariant *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_with_unix_fd_list_finish (G_DBUS_PROXY (proxy), out_fd_list, res, error);\n"
                )
            else:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);\n"
                )
            self.outfile.write("  if (_ret == NULL)\n" "    goto _out;\n")
            self.outfile.write("  g_variant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  g_variant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

            # sync
            self.outfile.write(
                "/**\n"
                " * %s_call_%s_sync:\n"
                " * @proxy: A #%sProxy.\n" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(
                    " * @arg_%s: Argument to pass with the method invocation.\n"
                    % (a.name)
                )
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    " * @call_flags: Flags from the #GDBusCallFlags enumeration. If you want to allow interactive\n"
                    "       authorization be sure to set %G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION.\n"
                    ' * @timeout_msec: The timeout in milliseconds (with %G_MAXINT meaning "infinite") or\n'
                    "       -1 to use the proxy default timeout.\n"
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(
                    " * @out_%s: (out) (optional)%s: Return location for return parameter or %%NULL to ignore.\n"
                    % (a.name, " " + a.array_annotation if a.array_annotation else "")
                )
            if m.unix_fd:
                self.outfile.write(
                    " * @out_fd_list: (out): Return location for a #GUnixFDList or %NULL.\n"
                )
            self.outfile.write(
                self.docbook_gen.expand(
                    " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                    " * @error: Return location for error or %%NULL.\n"
                    " *\n"
                    " * Synchronously invokes the %s.%s() D-Bus method on @proxy. The calling thread is blocked until a reply is received.\n"
                    " *\n"
                    " * See %s_call_%s() for the asynchronous version of this method.\n"
                    " *\n"
                    " * Returns: (skip): %%TRUE if the call succeeded, %%FALSE if @error is set.\n"
                    % (i.name, m.name, i.name_lower, m.name_lower),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "gboolean\n"
                "%s_call_%s_sync (\n"
                "    %s *proxy" % (i.name_lower, m.name_lower, i.camel_name)
            )
            for a in m.in_args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            if self.glib_min_required >= (2, 64):
                self.outfile.write(
                    ",\n    GDBusCallFlags call_flags" ",\n    gint timeout_msec"
                )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList  *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %sout_%s" % (a.ctype_out, a.name))
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList **out_fd_list")
            self.outfile.write(
                ",\n"
                "    GCancellable *cancellable,\n"
                "    GError **error)\n"
                "{\n"
                "  GVariant *_ret;\n"
            )
            if m.unix_fd:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_with_unix_fd_list_sync (G_DBUS_PROXY (proxy),\n"
                )
            else:
                self.outfile.write(
                    "  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),\n"
                )
            self.outfile.write('    "%s",\n' '    g_variant_new ("(' % (m.name))
            for a in m.in_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.in_args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("),\n")
            if self.glib_min_required >= (2, 64):
                self.outfile.write("    call_flags,\n" "    timeout_msec,\n")
            else:
                self.outfile.write("    G_DBUS_CALL_FLAGS_NONE,\n" "    -1,\n")
            if m.unix_fd:
                self.outfile.write("    fd_list,\n" "    out_fd_list,\n")
            self.outfile.write(
                "    cancellable,\n"
                "    error);\n"
                "  if (_ret == NULL)\n"
                "    goto _out;\n"
            )
            self.outfile.write("  g_variant_get (_ret,\n" '                 "(')
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_out))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                 out_%s" % (a.name))
            self.outfile.write(");\n" "  g_variant_unref (_ret);\n")
            self.outfile.write("_out:\n" "  return _ret != NULL;\n" "}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_method_completers(self, i):
        for m in i.methods:
            self.outfile.write(
                "/**\n"
                " * %s_complete_%s:\n"
                " * @object: A #%s.\n"
                " * @invocation: (transfer full): A #GDBusMethodInvocation.\n"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(
                    " * @fd_list: (nullable): A #GUnixFDList or %NULL.\n"
                )
            for a in m.out_args:
                self.outfile.write(" * @%s: Parameter to return.\n" % (a.name))
            self.outfile.write(
                self.docbook_gen.expand(
                    " *\n"
                    " * Helper function used in service implementations to finish handling invocations of the %s.%s() D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.\n"
                    " *\n"
                    " * This method will free @invocation, you cannot use it afterwards.\n"
                    % (i.name, m.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(m, self.outfile, 0)
            self.outfile.write(
                "void\n"
                "%s_complete_%s (\n"
                "    %s *object G_GNUC_UNUSED,\n"
                "    GDBusMethodInvocation *invocation"
                % (i.name_lower, m.name_lower, i.camel_name)
            )
            if m.unix_fd:
                self.outfile.write(",\n    GUnixFDList *fd_list")
            for a in m.out_args:
                self.outfile.write(",\n    %s%s" % (a.ctype_in, a.name))
            self.outfile.write(")\n" "{\n")

            if m.unix_fd:
                self.outfile.write(
                    "  g_dbus_method_invocation_return_value_with_unix_fd_list (invocation,\n"
                    '    g_variant_new ("('
                )
            else:
                self.outfile.write(
                    "  g_dbus_method_invocation_return_value (invocation,\n"
                    '    g_variant_new ("('
                )
            for a in m.out_args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in m.out_args:
                self.outfile.write(",\n                   %s" % (a.name))
            if m.unix_fd:
                self.outfile.write("),\n    fd_list);\n")
            else:
                self.outfile.write("));\n")
            self.outfile.write("}\n" "\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_proxy(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxy:\n"
                " *\n"
                " * The #%sProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sProxy.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sProxyPrivate\n"
            "{\n"
            "  GData *qdata;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void %s_proxy_iface_init (%sIface *iface);\n"
            "\n" % (i.name_lower, i.camel_name)
        )
        self.outfile.write("#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sProxy)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sProxy, %s_proxy, G_TYPE_DBUS_PROXY,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_proxy_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_proxy_finalize (GObject *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write("  g_datalist_clear (&proxy->priv->qdata);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_proxy_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors
        #
        # Note that we are guaranteed that prop_id starts at 1 and is
        # laid out in the same order as introspection data pointers
        #
        self.outfile.write(
            "static void\n"
            "%s_proxy_get_property (GObject      *object" % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(
                " G_GNUC_UNUSED,\n"
                "  guint         prop_id G_GNUC_UNUSED,\n"
                "  GValue       *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                ",\n" "  guint         prop_id,\n" "  GValue       *value,\n"
            )
        self.outfile.write("  GParamSpec   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  GVariant *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (object), info->parent_struct.name);\n"
                "  if (info->use_gvariant)\n"
                "    {\n"
                "      g_value_set_variant (value, variant);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                # could be that we don't have the value in cache - in that case, we do
                # nothing and the user gets the default value for the GType
                "      if (variant != NULL)\n"
                "        g_dbus_gvariant_to_gvalue (variant, value);\n"
                "    }\n"
                "  if (variant != NULL)\n"
                "    g_variant_unref (variant);\n" % (len(i.properties), i.name_lower)
            )
        self.outfile.write("}\n" "\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_proxy_set_property_cb (GDBusProxy *proxy,\n"
                "  GAsyncResult *res,\n"
                "  gpointer      user_data)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info = user_data;\n"
                "  GError *error;\n"
                "  GVariant *_ret;\n"
                "  error = NULL;\n"
                "  _ret = g_dbus_proxy_call_finish (proxy, res, &error);\n"
                "  if (!_ret)\n"
                "    {\n"
                "      g_warning (\"Error setting property '%%s' on interface %s: %%s (%%s, %%d)\",\n"
                "                 info->parent_struct.name, \n"
                "                 error->message, g_quark_to_string (error->domain), error->code);\n"
                "      g_error_free (error);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      g_variant_unref (_ret);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write("}\n" "\n")
        self.outfile.write("static void\n" "%s_proxy_set_property (" % (i.name_lower))
        if len(i.properties) == 0:
            self.outfile.write(
                "GObject      *object G_GNUC_UNUSED,\n"
                "  guint         prop_id G_GNUC_UNUSED,\n"
                "  const GValue *value G_GNUC_UNUSED,\n"
            )
        else:
            self.outfile.write(
                "GObject      *object,\n"
                "  guint         prop_id,\n"
                "  const GValue *value,\n"
            )
        self.outfile.write("  GParamSpec   *pspec G_GNUC_UNUSED)\n" "{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  GVariant *variant;\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  variant = g_dbus_gvalue_to_gvariant (value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
                "  g_dbus_proxy_call (G_DBUS_PROXY (object),\n"
                '    "org.freedesktop.DBus.Properties.Set",\n'
                '    g_variant_new ("(ssv)", "%s", info->parent_struct.name, variant),\n'
                "    G_DBUS_CALL_FLAGS_NONE,\n"
                "    -1,\n"
                "    NULL, (GAsyncReadyCallback) %s_proxy_set_property_cb, (GDBusPropertyInfo *) &info->parent_struct);\n"
                "  g_variant_unref (variant);\n"
                % (len(i.properties), i.name_lower, i.name, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # signal received
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_signal (GDBusProxy *proxy,\n"
            "  const gchar *sender_name G_GNUC_UNUSED,\n"
            "  const gchar *signal_name,\n"
            "  GVariant *parameters)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  _ExtendedGDBusSignalInfo *info;\n"
            "  GVariantIter iter;\n"
            "  GVariant *child;\n"
            "  GValue *paramv;\n"
            "  gsize num_params;\n"
            "  gsize n;\n"
            "  guint signal_id;\n"
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, signal_name);\n"
            "  if (info == NULL)\n"
            "    return;\n" % (i.name_lower)
        )
        self.outfile.write(
            "  num_params = g_variant_n_children (parameters);\n"
            "  paramv = g_new0 (GValue, num_params + 1);\n"
            "  g_value_init (&paramv[0], %sTYPE_%s);\n"
            "  g_value_set_object (&paramv[0], proxy);\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_variant_iter_init (&iter, parameters);\n"
            "  n = 1;\n"
            "  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          g_value_init (&paramv[n], G_TYPE_VARIANT);\n"
            "          g_value_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      g_variant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write("  g_signal_emitv (paramv, signal_id, 0, NULL);\n")
        self.outfile.write(
            "  for (n = 0; n < num_params + 1; n++)\n"
            "    g_value_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        # property changed
        self.outfile.write(
            "static void\n"
            "%s_proxy_g_properties_changed (GDBusProxy *_proxy,\n"
            "  GVariant *changed_properties,\n"
            "  const gchar *const *invalidated_properties)\n"
            "{\n" % (i.name_lower)
        )
        # Note: info could be NULL if we are talking to a newer version of the interface
        self.outfile.write(
            "  %sProxy *proxy = %s%s_PROXY (_proxy);\n"
            "  guint n;\n"
            "  const gchar *key;\n"
            "  GVariantIter *iter;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            '  g_variant_get (changed_properties, "a{sv}", &iter);\n'
            '  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))\n'
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, key);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, key);\n"
            "      if (info != NULL)\n"
            "        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "  g_variant_iter_free (iter);\n"
            "  for (n = 0; invalidated_properties[n] != NULL; n++)\n"
            "    {\n"
            "      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, invalidated_properties[n]);\n"
            "      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);\n"
            "      if (info != NULL)\n"
            "        g_object_notify (G_OBJECT (proxy), info->hyphen_name);\n"
            "    }\n"
            "}\n"
            "\n" % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower, i.name_lower)
        )

        # property vfuncs
        for p in i.properties:
            self.outfile.write(
                "static %s\n"
                "%s_proxy_get_%s (%s *object)\n"
                "{\n"
                "  %sProxy *proxy = %s%s_PROXY (object);\n"
                "  GVariant *variant;\n"
                "  %svalue = %s;\n"
                % (
                    p.arg.ctype_in,
                    i.name_lower,
                    p.name_lower,
                    i.camel_name,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    p.arg.ctype_in,
                    p.arg.ctype_in_default_value,
                )
            )
            # For some property types, we have to free the returned
            # value (or part of it, e.g. the container) because of how
            # GVariant works.. see https://bugzilla.gnome.org/show_bug.cgi?id=657100
            # for details
            #
            free_container = False
            if (
                p.arg.gvariant_get == "g_variant_get_strv"
                or p.arg.gvariant_get == "g_variant_get_objv"
                or p.arg.gvariant_get == "g_variant_get_bytestring_array"
            ):
                free_container = True
            # If already using an old value for strv, objv, bytestring_array (see below),
            # then just return that... that way the result from multiple consecutive calls
            # to the getter are valid as long as they're freed
            #
            if free_container:
                self.outfile.write(
                    '  value = g_datalist_get_data (&proxy->priv->qdata, "%s");\n'
                    "  if (value != NULL)\n"
                    "    return value;\n" % (p.name)
                )
            self.outfile.write(
                '  variant = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (proxy), "%s");\n'
                % (p.name)
            )
            if p.arg.gtype == "G_TYPE_VARIANT":
                self.outfile.write("  value = variant;\n")
                self.outfile.write("  if (variant != NULL)\n")
                self.outfile.write("    g_variant_unref (variant);\n")
            else:
                self.outfile.write("  if (variant != NULL)\n" "    {\n")
                extra_len = ""
                if (
                    p.arg.gvariant_get == "g_variant_get_string"
                    or p.arg.gvariant_get == "g_variant_get_strv"
                    or p.arg.gvariant_get == "g_variant_get_objv"
                    or p.arg.gvariant_get == "g_variant_get_bytestring_array"
                ):
                    extra_len = ", NULL"
                self.outfile.write(
                    "      value = %s (variant%s);\n" % (p.arg.gvariant_get, extra_len)
                )
                if free_container:
                    self.outfile.write(
                        '      g_datalist_set_data_full (&proxy->priv->qdata, "%s", (gpointer) value, g_free);\n'
                        % (p.name)
                    )
                self.outfile.write("      g_variant_unref (variant);\n")
                self.outfile.write("    }\n")
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%s_proxy_init (%sProxy *proxy)\n"
            "{\n"
            "#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n"
            "  proxy->priv = %s_proxy_get_instance_private (proxy);\n"
            "#else\n"
            "  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, %sTYPE_%s_PROXY, %sProxyPrivate);\n"
            "#endif\n\n"
            "  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), %s_interface_info ());\n"
            "}\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
                i.name_lower,
            )
        )
        self.outfile.write(
            "static void\n"
            "%s_proxy_class_init (%sProxyClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class;\n"
            "  GDBusProxyClass *proxy_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize     = %s_proxy_finalize;\n"
            "  gobject_class->get_property = %s_proxy_get_property;\n"
            "  gobject_class->set_property = %s_proxy_set_property;\n"
            "\n"
            "  proxy_class = G_DBUS_PROXY_CLASS (klass);\n"
            "  proxy_class->g_signal = %s_proxy_g_signal;\n"
            "  proxy_class->g_properties_changed = %s_proxy_g_properties_changed;\n"
            "\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
                i.name_lower,
            )
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  %s_override_properties (gobject_class, 1);\n\n" % (i.name_lower)
            )
        self.outfile.write(
            "#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38\n"
            "  g_type_class_add_private (klass, sizeof (%sProxyPrivate));\n"
            "#endif\n" % (i.camel_name)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_proxy_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_proxy_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates a proxy for the D-Bus interface #%s. See g_dbus_proxy_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new (\n"
            "    GDBusConnection     *connection,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GAsyncReadyCallback  callback,\n"
            "    gpointer             user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_proxy_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_sync:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates a proxy for the D-Bus interface #%s. See g_dbus_proxy_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_sync (\n"
            "    GDBusConnection     *connection,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GError             **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %s_proxy_new() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %s_proxy_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %s_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.name_lower),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "void\n"
            "%s_proxy_new_for_bus (\n"
            "    GBusType             bus_type,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GAsyncReadyCallback  callback,\n"
            "    gpointer             user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_%s_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "}\n"
            "\n" % (i.name_lower, i.ns_upper, i.name_upper, i.name)
        )
        self.outfile.write(
            "/**\n"
            " * %s_proxy_new_for_bus_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %s_proxy_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %s_proxy_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
            % (i.name_lower, i.name_lower, i.name_lower, i.camel_name)
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (i.camel_name, i.name_lower, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_proxy_new_for_bus_sync:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusProxyFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %s_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %s_proxy_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sProxy): The constructed proxy object or %%NULL if @error is set.\n"
                % (i.name_lower, i.name_lower, i.name_lower, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_proxy_new_for_bus_sync (\n"
            "    GBusType             bus_type,\n"
            "    GDBusProxyFlags      flags,\n"
            "    const gchar         *name,\n"
            "    const gchar         *object_path,\n"
            "    GCancellable        *cancellable,\n"
            "    GError             **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_%s_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "%s", NULL);\n'
            "  if (ret != NULL)\n"
            "    return %s%s (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.name,
                i.ns_upper,
                i.name_upper,
            )
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def generate_skeleton(self, i):
        # class boilerplate
        self.outfile.write(
            "/* ------------------------------------------------------------------------ */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeleton:\n"
                " *\n"
                " * The #%sSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sSkeleton.\n" % (i.camel_name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write("\n")

        self.outfile.write(
            "struct _%sSkeletonPrivate\n"
            "{\n"
            "  GValue *properties;\n"
            "  GList *changed_properties;\n"
            "  GSource *changed_properties_idle_source;\n"
            "  GMainContext *context;\n"
            "  GMutex lock;\n"
            "};\n"
            "\n" % i.camel_name
        )

        self.outfile.write(
            "static void\n"
            "_%s_skeleton_handle_method_call (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name,\n"
            "  const gchar *method_name,\n"
            "  GVariant *parameters,\n"
            "  GDBusMethodInvocation *invocation,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  _ExtendedGDBusMethodInfo *info;\n"
            "  GVariantIter iter;\n"
            "  GVariant *child;\n"
            "  GValue *paramv;\n"
            "  gsize num_params;\n"
            "  guint num_extra;\n"
            "  gsize n;\n"
            "  guint signal_id;\n"
            "  GValue return_value = G_VALUE_INIT;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);\n"
            "  g_assert (info != NULL);\n"
        )
        self.outfile.write(
            "  num_params = g_variant_n_children (parameters);\n"
            "  num_extra = info->pass_fdlist ? 3 : 2;"
            "  paramv = g_new0 (GValue, num_params + num_extra);\n"
            "  n = 0;\n"
            "  g_value_init (&paramv[n], %sTYPE_%s);\n"
            "  g_value_set_object (&paramv[n++], skeleton);\n"
            "  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);\n"
            "  g_value_set_object (&paramv[n++], invocation);\n"
            "  if (info->pass_fdlist)\n"
            "    {\n"
            "#ifdef G_OS_UNIX\n"
            "      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);\n"
            "      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));\n"
            "#else\n"
            "      g_assert_not_reached ();\n"
            "#endif\n"
            "    }\n" % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_variant_iter_init (&iter, parameters);\n"
            "  while ((child = g_variant_iter_next_value (&iter)) != NULL)\n"
            "    {\n"
            "      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];\n"
            "      if (arg_info->use_gvariant)\n"
            "        {\n"
            "          g_value_init (&paramv[n], G_TYPE_VARIANT);\n"
            "          g_value_set_variant (&paramv[n], child);\n"
            "          n++;\n"
            "        }\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);\n"
            "      g_variant_unref (child);\n"
            "    }\n"
        )
        self.outfile.write(
            "  signal_id = g_signal_lookup (info->signal_name, %sTYPE_%s);\n"
            % (i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  g_value_init (&return_value, G_TYPE_BOOLEAN);\n"
            "  g_signal_emitv (paramv, signal_id, 0, &return_value);\n"
            "  if (!g_value_get_boolean (&return_value))\n"
            '    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);\n'
            "  g_value_unset (&return_value);\n"
        )
        self.outfile.write(
            "  for (n = 0; n < num_params + num_extra; n++)\n"
            "    g_value_unset (&paramv[n]);\n"
            "  g_free (paramv);\n"
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GVariant *\n"
            "_%s_skeleton_handle_get_property (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name G_GNUC_UNUSED,\n"
            "  const gchar *property_name,\n"
            "  GError **error,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  GValue value = G_VALUE_INIT;\n"
            "  GParamSpec *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  GVariant *ret;\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = NULL;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      g_value_init (&value, pspec->value_type);\n"
            "      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));\n"
            "      g_value_unset (&value);\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static gboolean\n"
            "_%s_skeleton_handle_set_property (\n"
            "  GDBusConnection *connection G_GNUC_UNUSED,\n"
            "  const gchar *sender G_GNUC_UNUSED,\n"
            "  const gchar *object_path G_GNUC_UNUSED,\n"
            "  const gchar *interface_name G_GNUC_UNUSED,\n"
            "  const gchar *property_name,\n"
            "  GVariant *variant,\n"
            "  GError **error,\n"
            "  gpointer user_data)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
            "  GValue value = G_VALUE_INIT;\n"
            "  GParamSpec *pspec;\n"
            "  _ExtendedGDBusPropertyInfo *info;\n"
            "  gboolean ret;\n" % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "  ret = FALSE;\n"
            "  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_%s_interface_info.parent_struct, property_name);\n"
            "  g_assert (info != NULL);\n"
            "  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);\n"
            "  if (pspec == NULL)\n"
            "    {\n"
            '      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %%s", property_name);\n'
            "    }\n"
            "  else\n"
            "    {\n"
            "      if (info->use_gvariant)\n"
            "        g_value_set_variant (&value, variant);\n"
            "      else\n"
            "        g_dbus_gvariant_to_gvalue (variant, &value);\n"
            "      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);\n"
            "      g_value_unset (&value);\n"
            "      ret = TRUE;\n"
            "    }\n"
            "  return ret;\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        self.outfile.write(
            "static const GDBusInterfaceVTable _%s_skeleton_vtable =\n"
            "{\n"
            "  _%s_skeleton_handle_method_call,\n"
            "  _%s_skeleton_handle_get_property,\n"
            "  _%s_skeleton_handle_set_property,\n"
            "  {NULL}\n"
            "};\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower)
        )

        self.outfile.write(
            "static GDBusInterfaceInfo *\n"
            "%s_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return %s_interface_info ();\n" % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GDBusInterfaceVTable *\n"
            "%s_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)\n"
            "{\n"
            "  return (GDBusInterfaceVTable *) &_%s_skeleton_vtable;\n"
            % (i.name_lower, i.name_lower)
        )
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static GVariant *\n"
            "%s_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)\n"
            "{\n"
            "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
            % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
        )
        self.outfile.write(
            "\n"
            "  GVariantBuilder builder;\n"
            "  guint n;\n"
            '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
            "  if (_%s_interface_info.parent_struct.properties == NULL)\n"
            "    goto out;\n"
            "  for (n = 0; _%s_interface_info.parent_struct.properties[n] != NULL; n++)\n"
            "    {\n"
            "      GDBusPropertyInfo *info = _%s_interface_info.parent_struct.properties[n];\n"
            "      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)\n"
            "        {\n"
            "          GVariant *value;\n"
            '          value = _%s_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", info->name, NULL, skeleton);\n'
            "          if (value != NULL)\n"
            "            {\n"
            "              g_variant_take_ref (value);\n"
            '              g_variant_builder_add (&builder, "{sv}", info->name, value);\n'
            "              g_variant_unref (value);\n"
            "            }\n"
            "        }\n"
            "    }\n"
            "out:\n"
            "  return g_variant_builder_end (&builder);\n"
            "}\n"
            "\n" % (i.name_lower, i.name_lower, i.name_lower, i.name_lower, i.name)
        )

        if len(i.properties) > 0:
            self.outfile.write(
                "static gboolean _%s_emit_changed (gpointer user_data);\n"
                "\n" % (i.name_lower)
            )

        self.outfile.write(
            "static void\n"
            "%s_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton"
            % (i.name_lower)
        )
        if len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        if len(i.properties) > 0:
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (_skeleton);\n"
                "  gboolean emit_changed = FALSE;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
                "    {\n"
                "      g_source_destroy (skeleton->priv->changed_properties_idle_source);\n"
                "      skeleton->priv->changed_properties_idle_source = NULL;\n"
                "      emit_changed = TRUE;\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "\n"
                "  if (emit_changed)\n"
                "    _%s_emit_changed (skeleton);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, i.name_lower)
            )
        self.outfile.write("}\n" "\n")

        for s in i.signals:
            self.outfile.write(
                "static void\n"
                "_%s_on_signal_%s (\n"
                "    %s *object" % (i.name_lower, s.name_lower, i.camel_name)
            )
            for a in s.args:
                self.outfile.write(",\n    %sarg_%s" % (a.ctype_in, a.name))
            self.outfile.write(
                ")\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n\n"
                "  GList      *connections, *l;\n"
                "  GVariant   *signal_variant;\n"
                "  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "\n" '  signal_variant = g_variant_ref_sink (g_variant_new ("('
            )
            for a in s.args:
                self.outfile.write("%s" % (a.format_in))
            self.outfile.write(')"')
            for a in s.args:
                self.outfile.write(",\n                   arg_%s" % (a.name))
            self.outfile.write("));\n")

            self.outfile.write(
                "  for (l = connections; l != NULL; l = l->next)\n"
                "    {\n"
                "      GDBusConnection *connection = l->data;\n"
                "      g_dbus_connection_emit_signal (connection,\n"
                '        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "%s", "%s",\n'
                "        signal_variant, NULL);\n"
                "    }\n" % (i.name, s.name)
            )
            self.outfile.write("  g_variant_unref (signal_variant);\n")
            self.outfile.write("  g_list_free_full (connections, g_object_unref);\n")
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void %s_skeleton_iface_init (%sIface *iface);\n"
            % (i.name_lower, i.camel_name)
        )

        self.outfile.write("#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_ADD_PRIVATE (%sSkeleton)\n" % (i.camel_name)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#else\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sSkeleton, %s_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,\n"
            % (i.camel_name, i.name_lower)
        )
        self.outfile.write(
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_%s, %s_skeleton_iface_init))\n\n"
            % (i.ns_upper, i.name_upper, i.name_lower)
        )
        self.outfile.write("#endif\n")

        # finalize
        self.outfile.write(
            "static void\n"
            "%s_skeleton_finalize (GObject *object)\n"
            "{\n" % (i.name_lower)
        )
        self.outfile.write(
            "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
            % (i.camel_name, i.ns_upper, i.name_upper)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  guint n;\n"
                "  for (n = 0; n < %d; n++)\n"
                "    g_value_unset (&skeleton->priv->properties[n]);\n"
                % (len(i.properties))
            )
            self.outfile.write("  g_free (skeleton->priv->properties);\n")
        self.outfile.write(
            "  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n"
        )
        self.outfile.write(
            "  if (skeleton->priv->changed_properties_idle_source != NULL)\n"
        )
        self.outfile.write(
            "    g_source_destroy (skeleton->priv->changed_properties_idle_source);\n"
        )
        self.outfile.write("  g_main_context_unref (skeleton->priv->context);\n")
        self.outfile.write("  g_mutex_clear (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  G_OBJECT_CLASS (%s_skeleton_parent_class)->finalize (object);\n"
            "}\n"
            "\n" % (i.name_lower)
        )

        # property accessors (TODO: generate PropertiesChanged signals in setter)
        if len(i.properties) > 0:
            self.outfile.write(
                "static void\n"
                "%s_skeleton_get_property (GObject      *object,\n"
                "  guint         prop_id,\n"
                "  GValue       *value,\n"
                "  GParamSpec   *pspec G_GNUC_UNUSED)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  g_value_copy (&skeleton->priv->properties[prop_id - 1], value);\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (i.camel_name, i.ns_upper, i.name_upper, len(i.properties))
            )
            self.outfile.write("}\n" "\n")

            # if property is already scheduled then re-use entry.. though it could be
            # that the user did
            #
            #  foo_set_prop_bar (object, "");
            #  foo_set_prop_bar (object, "blah");
            #
            # say, every update... In this case, where nothing happens, we obviously
            # don't want a PropertiesChanged() event. We can easily check for this
            # by comparing against the _original value_ recorded before the first
            # change event. If the latest value is not different from the original
            # one, we can simply ignore the ChangedProperty
            #
            self.outfile.write(
                "static gboolean\n"
                "_%s_emit_changed (gpointer user_data)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (user_data);\n"
                % (i.name_lower, i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  GList *l;\n"
                "  GVariantBuilder builder;\n"
                "  GVariantBuilder invalidated_builder;\n"
                "  guint num_changes;\n"
                "\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                '  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));\n'
                '  g_variant_builder_init (&invalidated_builder, G_VARIANT_TYPE ("as"));\n'
                "  for (l = skeleton->priv->changed_properties, num_changes = 0; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *cp = l->data;\n"
                "      GVariant *variant;\n"
                "      const GValue *cur_value;\n"
                "\n"
                "      cur_value = &skeleton->priv->properties[cp->prop_id - 1];\n"
                "      if (!_g_value_equal (cur_value, &cp->orig_value))\n"
                "        {\n"
                "          variant = g_dbus_gvalue_to_gvariant (cur_value, G_VARIANT_TYPE (cp->info->parent_struct.signature));\n"
                '          g_variant_builder_add (&builder, "{sv}", cp->info->parent_struct.name, variant);\n'
                "          g_variant_unref (variant);\n"
                "          num_changes++;\n"
                "        }\n"
                "    }\n"
                "  if (num_changes > 0)\n"
                "    {\n"
                "      GList *connections, *ll;\n"
                "      GVariant *signal_variant;"
                "\n"
                '      signal_variant = g_variant_ref_sink (g_variant_new ("(sa{sv}as)", "%s",\n'
                "                                           &builder, &invalidated_builder));\n"
                "      connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));\n"
                "      for (ll = connections; ll != NULL; ll = ll->next)\n"
                "        {\n"
                "          GDBusConnection *connection = ll->data;\n"
                "\n"
                "          g_dbus_connection_emit_signal (connection,\n"
                "                                         NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)),\n"
                '                                         "org.freedesktop.DBus.Properties",\n'
                '                                         "PropertiesChanged",\n'
                "                                         signal_variant,\n"
                "                                         NULL);\n"
                "        }\n"
                "      g_variant_unref (signal_variant);\n"
                "      g_list_free_full (connections, g_object_unref);\n"
                "    }\n"
                "  else\n"
                "    {\n"
                "      g_variant_builder_clear (&builder);\n"
                "      g_variant_builder_clear (&invalidated_builder);\n"
                "    }\n" % (i.name)
            )
            self.outfile.write(
                "  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);\n"
            )
            self.outfile.write("  skeleton->priv->changed_properties = NULL;\n")
            self.outfile.write(
                "  skeleton->priv->changed_properties_idle_source = NULL;\n"
            )
            self.outfile.write("  g_mutex_unlock (&skeleton->priv->lock);\n")
            self.outfile.write("  return FALSE;\n" "}\n" "\n")
            # holding lock while being called
            self.outfile.write(
                "static void\n"
                "_%s_schedule_emit_changed (%sSkeleton *skeleton, const _ExtendedGDBusPropertyInfo *info, guint prop_id, const GValue *orig_value)\n"
                "{\n"
                "  ChangedProperty *cp;\n"
                "  GList *l;\n"
                "  cp = NULL;\n"
                "  for (l = skeleton->priv->changed_properties; l != NULL; l = l->next)\n"
                "    {\n"
                "      ChangedProperty *i_cp = l->data;\n"
                "      if (i_cp->info == info)\n"
                "        {\n"
                "          cp = i_cp;\n"
                "          break;\n"
                "        }\n"
                "    }\n" % (i.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  if (cp == NULL)\n"
                "    {\n"
                "      cp = g_new0 (ChangedProperty, 1);\n"
                "      cp->prop_id = prop_id;\n"
                "      cp->info = info;\n"
                "      skeleton->priv->changed_properties = g_list_prepend (skeleton->priv->changed_properties, cp);\n"
                "      g_value_init (&cp->orig_value, G_VALUE_TYPE (orig_value));\n"
                "      g_value_copy (orig_value, &cp->orig_value);\n"
                "    }\n"
                "}\n"
                "\n"
            )

            # Postpone setting up the refresh source until the ::notify signal is emitted as
            # this allows use of g_object_freeze_notify()/g_object_thaw_notify() ...
            # This is useful when updating several properties from another thread than
            # where the idle will be emitted from
            self.outfile.write(
                "static void\n"
                "%s_skeleton_notify (GObject      *object,\n"
                "  GParamSpec *pspec G_GNUC_UNUSED)\n"
                "{\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  if (skeleton->priv->changed_properties != NULL &&\n"
                "      skeleton->priv->changed_properties_idle_source == NULL)\n"
                "    {\n"
                "      skeleton->priv->changed_properties_idle_source = g_idle_source_new ();\n"
                "      g_source_set_priority (skeleton->priv->changed_properties_idle_source, G_PRIORITY_DEFAULT);\n"
                "      g_source_set_callback (skeleton->priv->changed_properties_idle_source, _%s_emit_changed, g_object_ref (skeleton), (GDestroyNotify) g_object_unref);\n"
                '      g_source_set_name (skeleton->priv->changed_properties_idle_source, "[generated] _%s_emit_changed");\n'
                "      g_source_attach (skeleton->priv->changed_properties_idle_source, skeleton->priv->context);\n"
                "      g_source_unref (skeleton->priv->changed_properties_idle_source);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "}\n"
                "\n"
                % (
                    i.name_lower,
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    i.name_lower,
                    i.name_lower,
                )
            )

            self.outfile.write(
                "static void\n"
                "%s_skeleton_set_property (GObject      *object,\n"
                "  guint         prop_id,\n"
                "  const GValue *value,\n"
                "  GParamSpec   *pspec)\n"
                "{\n" % (i.name_lower)
            )
            self.outfile.write(
                "  const _ExtendedGDBusPropertyInfo *info;\n"
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                "  g_assert (prop_id != 0 && prop_id - 1 < %d);\n"
                "  info = (const _ExtendedGDBusPropertyInfo *) _%s_property_info_pointers[prop_id - 1];\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  g_object_freeze_notify (object);\n"
                "  if (!_g_value_equal (value, &skeleton->priv->properties[prop_id - 1]))\n"
                "    {\n"
                "      if (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)) != NULL &&\n"
                "          info->emits_changed_signal)\n"
                "        _%s_schedule_emit_changed (skeleton, info, prop_id, &skeleton->priv->properties[prop_id - 1]);\n"
                "      g_value_copy (value, &skeleton->priv->properties[prop_id - 1]);\n"
                "      g_object_notify_by_pspec (object, pspec);\n"
                "    }\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                "  g_object_thaw_notify (object);\n"
                % (
                    i.camel_name,
                    i.ns_upper,
                    i.name_upper,
                    len(i.properties),
                    i.name_lower,
                    i.name_lower,
                )
            )
            self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_init (%sSkeleton *skeleton)\n"
            "{\n"
            "#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38\n"
            "  skeleton->priv = %s_skeleton_get_instance_private (skeleton);\n"
            "#else\n"
            "  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, %sTYPE_%s_SKELETON, %sSkeletonPrivate);\n"
            "#endif\n\n"
            % (
                i.name_lower,
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.camel_name,
            )
        )
        self.outfile.write("  g_mutex_init (&skeleton->priv->lock);\n")
        self.outfile.write(
            "  skeleton->priv->context = g_main_context_ref_thread_default ();\n"
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  skeleton->priv->properties = g_new0 (GValue, %d);\n"
                % (len(i.properties))
            )
            n = 0
            for p in i.properties:
                self.outfile.write(
                    "  g_value_init (&skeleton->priv->properties[%d], %s);\n"
                    % (n, p.arg.gtype)
                )
                n += 1
        self.outfile.write("}\n" "\n")

        # property vfuncs
        n = 0
        for p in i.properties:
            self.outfile.write(
                "static %s\n"
                "%s_skeleton_get_%s (%s *object)\n"
                "{\n" % (p.arg.ctype_in, i.name_lower, p.name_lower, i.camel_name)
            )
            self.outfile.write(
                "  %sSkeleton *skeleton = %s%s_SKELETON (object);\n"
                % (i.camel_name, i.ns_upper, i.name_upper)
            )
            self.outfile.write(
                "  %svalue;\n"
                "  g_mutex_lock (&skeleton->priv->lock);\n"
                "  value = %s (&(skeleton->priv->properties[%d]));\n"
                "  g_mutex_unlock (&skeleton->priv->lock);\n"
                % (p.arg.ctype_in_g, p.arg.gvalue_get, n)
            )
            self.outfile.write("  return value;\n")
            self.outfile.write("}\n")
            self.outfile.write("\n")
            n += 1

        self.outfile.write(
            "static void\n"
            "%s_skeleton_class_init (%sSkeletonClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class;\n"
            "  GDBusInterfaceSkeletonClass *skeleton_class;\n"
            "\n"
            "  gobject_class = G_OBJECT_CLASS (klass);\n"
            "  gobject_class->finalize = %s_skeleton_finalize;\n"
            % (i.name_lower, i.camel_name, i.name_lower)
        )
        if len(i.properties) > 0:
            self.outfile.write(
                "  gobject_class->get_property = %s_skeleton_get_property;\n"
                "  gobject_class->set_property = %s_skeleton_set_property;\n"
                "  gobject_class->notify       = %s_skeleton_notify;\n"
                "\n" % (i.name_lower, i.name_lower, i.name_lower)
            )
            self.outfile.write(
                "\n" "  %s_override_properties (gobject_class, 1);\n" % (i.name_lower)
            )
        self.outfile.write(
            "\n" "  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);\n"
        )
        self.outfile.write(
            "  skeleton_class->get_info = %s_skeleton_dbus_interface_get_info;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_properties = %s_skeleton_dbus_interface_get_properties;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->flush = %s_skeleton_dbus_interface_flush;\n"
            % (i.name_lower)
        )
        self.outfile.write(
            "  skeleton_class->get_vtable = %s_skeleton_dbus_interface_get_vtable;\n"
            % (i.name_lower)
        )

        self.outfile.write(
            "\n"
            "#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38\n"
            "  g_type_class_add_private (klass, sizeof (%sSkeletonPrivate));\n"
            "#endif\n" % (i.camel_name)
        )

        self.outfile.write("}\n" "\n")

        self.outfile.write(
            "static void\n"
            "%s_skeleton_iface_init (%sIface *iface" % (i.name_lower, i.camel_name)
        )
        if len(i.signals) == 0 and len(i.properties) == 0:
            self.outfile.write(" G_GNUC_UNUSED)\n")
        else:
            self.outfile.write(")\n")
        self.outfile.write("{\n")
        for s in i.signals:
            self.outfile.write(
                "  iface->%s = _%s_on_signal_%s;\n"
                % (s.name_lower, i.name_lower, s.name_lower)
            )
        for p in i.properties:
            self.outfile.write(
                "  iface->get_%s = %s_skeleton_get_%s;\n"
                % (p.name_lower, i.name_lower, p.name_lower)
            )
        self.outfile.write("}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %s_skeleton_new:\n"
                " *\n"
                " * Creates a skeleton object for the D-Bus interface #%s.\n"
                " *\n"
                " * Returns: (transfer full) (type %sSkeleton): The skeleton object.\n"
                % (i.name_lower, i.name, i.camel_name),
                False,
            )
        )
        self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
        self.outfile.write(
            "%s *\n"
            "%s_skeleton_new (void)\n"
            "{\n"
            "  return %s%s (g_object_new (%sTYPE_%s_SKELETON, NULL));\n"
            "}\n"
            "\n"
            % (
                i.camel_name,
                i.name_lower,
                i.ns_upper,
                i.name_upper,
                i.ns_upper,
                i.name_upper,
            )
        )

    # ---------------------------------------------------------------------------------------------------

    def generate_object(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for Object, ObjectProxy and ObjectSkeleton\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObject\n"
                " * @title: %sObject\n"
                " * @short_description: Specialized GDBusObject types\n"
                " *\n"
                " * This section contains the #%sObject, #%sObjectProxy, and #%sObjectSkeleton types which make it easier to work with objects implementing generated types for D-Bus interfaces.\n"
                " */\n"
                % (
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                    self.namespace,
                ),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObject:\n"
                " *\n"
                " * The #%sObject type is a specialized container of interfaces.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectIface:\n"
                " * @parent_iface: The parent interface.\n"
                " *\n"
                " * Virtual table for the #%sObject interface.\n"
                " */\n" % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            "typedef %sObjectIface %sObjectInterface;\n"
            % (self.namespace, self.namespace)
        )
        self.outfile.write(
            "G_DEFINE_INTERFACE_WITH_CODE (%sObject, %sobject, G_TYPE_OBJECT, g_type_interface_add_prerequisite (g_define_type_id, G_TYPE_DBUS_OBJECT);)\n"
            % (self.namespace, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_default_init (%sObjectIface *iface)\n"
            "{\n" % (self.ns_lower, self.namespace)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "  /**\n"
                    "   * %sObject:%s:\n"
                    "   *\n"
                    "   * The #%s instance corresponding to the D-Bus interface #%s, if any.\n"
                    "   *\n"
                    "   * Connect to the #GObject::notify signal to get informed of property changes.\n"
                    % (self.namespace, i.name_hyphen, i.camel_name, i.name),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 2)
            flags = "G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS"
            if i.deprecated:
                flags = "G_PARAM_DEPRECATED | " + flags
            self.outfile.write(
                '  g_object_interface_install_property (iface, g_param_spec_object ("%s", "%s", "%s", %sTYPE_%s, %s));\n'
                "\n"
                % (
                    i.name_hyphen,
                    i.name_hyphen,
                    i.name_hyphen,
                    self.ns_upper,
                    i.name_upper,
                    flags,
                )
            )
        self.outfile.write("}\n" "\n")

        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_get_%s:\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Gets the #%s instance for the D-Bus interface #%s on @object, if any.\n"
                    " *\n"
                    " * Returns: (transfer full) (nullable): A #%s that must be freed with g_object_unref() or %%NULL if @object does not implement the interface.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.name,
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_get_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  GDBusInterface *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_peek_%s: (skip)\n"
                    " * @object: A #%sObject.\n"
                    " *\n"
                    " * Like %sobject_get_%s() but doesn't increase the reference count on the returned object.\n"
                    " *\n"
                    " * It is not safe to use the returned object if you are on another thread than the one where the #GDBusObjectManagerClient or #GDBusObjectManagerServer for @object is running.\n"
                    " *\n"
                    " * Returns: (transfer none) (nullable): A #%s or %%NULL if @object does not implement the interface. Do not free the returned object, it is owned by @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        self.ns_lower,
                        i.name_upper.lower(),
                        i.camel_name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "%s *%sobject_peek_%s (%sObject *object)\n"
                % (i.camel_name, self.ns_lower, i.name_upper.lower(), self.namespace)
            )
            self.outfile.write(
                "{\n"
                "  GDBusInterface *ret;\n"
                '  ret = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "  if (ret == NULL)\n"
                "    return NULL;\n"
                "  g_object_unref (ret);\n"
                "  return %s%s (ret);\n"
                "}\n"
                "\n" % (i.name, self.ns_upper, i.name_upper)
            )
        self.outfile.write("\n")
        # shared by ObjectProxy and ObjectSkeleton classes
        self.outfile.write(
            "static void\n"
            "%sobject_notify (GDBusObject *object, GDBusInterface *interface)\n"
            "{\n"
            "  _ExtendedGDBusInterfaceInfo *info = (_ExtendedGDBusInterfaceInfo *) g_dbus_interface_get_info (interface);\n"
            "  /* info can be NULL if the other end is using a D-Bus interface we don't know\n"
            "   * anything about, for example old generated code in this process talking to\n"
            "   * newer generated code in the other process. */\n"
            "  if (info != NULL)\n"
            "    g_object_notify (G_OBJECT (object), info->hyphen_name);\n"
            "}\n"
            "\n" % (self.ns_lower)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxy:\n"
                " *\n"
                " * The #%sObjectProxy structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectProxyClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectProxy.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy__g_dbus_object_iface_init (GDBusObjectIface *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectProxy, %sobject_proxy, G_TYPE_DBUS_OBJECT_PROXY,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_proxy__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, %sobject_proxy__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_init (%sObjectProxy *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_set_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  const GValue *value G_GNUC_UNUSED,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            % (self.ns_lower)
        )
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_get_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  GValue       *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectProxy *object = %sOBJECT_PROXY (gobject);\n"
            "  GDBusInterface *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      g_value_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_proxy_class_init (%sObjectProxyClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_proxy_set_property;\n"
            "  gobject_class->get_property = %sobject_proxy_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  g_object_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_proxy_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new proxy object.\n"
                " *\n"
                " * Returns: (transfer full): The proxy object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectProxy *\n"
            "%sobject_proxy_new (GDBusConnection *connection,\n"
            "  const gchar *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (G_IS_DBUS_CONNECTION (connection), NULL);\n"
            "  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_PROXY (g_object_new (%sTYPE_OBJECT_PROXY, "g-connection", connection, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeleton:\n"
                " *\n"
                " * The #%sObjectSkeleton structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectSkeletonClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectSkeleton.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__%sobject_iface_init (%sObjectIface *iface G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write("\n")
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton__g_dbus_object_iface_init (GDBusObjectIface *iface)\n"
            "{\n"
            "  iface->interface_added = %sobject_notify;\n"
            "  iface->interface_removed = %sobject_notify;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_lower, self.ns_lower)
        )
        self.outfile.write(
            "G_DEFINE_TYPE_WITH_CODE (%sObjectSkeleton, %sobject_skeleton, G_TYPE_DBUS_OBJECT_SKELETON,\n"
            "                         G_IMPLEMENT_INTERFACE (%sTYPE_OBJECT, %sobject_skeleton__%sobject_iface_init)\n"
            "                         G_IMPLEMENT_INTERFACE (G_TYPE_DBUS_OBJECT, %sobject_skeleton__g_dbus_object_iface_init))\n"
            "\n"
            % (
                self.namespace,
                self.ns_lower,
                self.ns_upper,
                self.ns_lower,
                self.ns_lower,
                self.ns_lower,
            )
        )
        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_init (%sObjectSkeleton *object G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_set_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  const GValue *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  GDBusInterfaceSkeleton *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                "      interface = g_value_get_object (value);\n"
                "      if (interface != NULL)\n"
                "        {\n"
                "          g_warn_if_fail (%sIS_%s (interface));\n"
                "          g_dbus_object_skeleton_add_interface (G_DBUS_OBJECT_SKELETON (object), interface);\n"
                "        }\n"
                "      else\n"
                "        {\n"
                '          g_dbus_object_skeleton_remove_interface_by_name (G_DBUS_OBJECT_SKELETON (object), "%s");\n'
                "        }\n"
                "      break;\n"
                "\n" % (n, self.ns_upper, i.name_upper, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_get_property (GObject      *gobject,\n"
            "  guint         prop_id,\n"
            "  GValue       *value,\n"
            "  GParamSpec   *pspec)\n"
            "{\n"
            "  %sObjectSkeleton *object = %sOBJECT_SKELETON (gobject);\n"
            "  GDBusInterface *interface;\n"
            "\n"
            "  switch (prop_id)\n"
            "    {\n" % (self.ns_lower, self.namespace, self.ns_upper)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                "    case %d:\n"
                '      interface = g_dbus_object_get_interface (G_DBUS_OBJECT (object), "%s");\n'
                "      g_value_take_object (value, interface);\n"
                "      break;\n"
                "\n" % (n, i.name)
            )
            n += 1
        self.outfile.write(
            "    default:\n"
            "      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);\n"
            "      break;\n"
            "  }\n"
            "}\n"
            "\n"
        )
        self.outfile.write(
            "static void\n"
            "%sobject_skeleton_class_init (%sObjectSkeletonClass *klass)\n"
            "{\n"
            "  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
            "\n"
            "  gobject_class->set_property = %sobject_skeleton_set_property;\n"
            "  gobject_class->get_property = %sobject_skeleton_get_property;\n"
            "\n" % (self.ns_lower, self.namespace, self.ns_lower, self.ns_lower)
        )
        n = 1
        for i in self.ifaces:
            self.outfile.write(
                '  g_object_class_override_property (gobject_class, %d, "%s");'
                "\n" % (n, i.name_hyphen)
            )
            n += 1
        self.outfile.write("}\n" "\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_skeleton_new:\n"
                " * @object_path: An object path.\n"
                " *\n"
                " * Creates a new skeleton object.\n"
                " *\n"
                " * Returns: (transfer full): The skeleton object.\n"
                " */\n" % (self.ns_lower),
                False,
            )
        )
        self.outfile.write(
            "%sObjectSkeleton *\n"
            "%sobject_skeleton_new (const gchar *object_path)\n"
            "{\n"
            "  g_return_val_if_fail (g_variant_is_object_path (object_path), NULL);\n"
            '  return %sOBJECT_SKELETON (g_object_new (%sTYPE_OBJECT_SKELETON, "g-object-path", object_path, NULL));\n'
            "}\n"
            "\n" % (self.namespace, self.ns_lower, self.ns_upper, self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                self.docbook_gen.expand(
                    "/**\n"
                    " * %sobject_skeleton_set_%s:\n"
                    " * @object: A #%sObjectSkeleton.\n"
                    " * @interface_: (nullable): A #%s or %%NULL to clear the interface.\n"
                    " *\n"
                    " * Sets the #%s instance for the D-Bus interface #%s on @object.\n"
                    % (
                        self.ns_lower,
                        i.name_upper.lower(),
                        self.namespace,
                        i.camel_name,
                        i.camel_name,
                        i.name,
                    ),
                    False,
                )
            )
            self.write_gtkdoc_deprecated_and_since_and_close(i, self.outfile, 0)
            self.outfile.write(
                "void %sobject_skeleton_set_%s (%sObjectSkeleton *object, %s *interface_)\n"
                % (self.ns_lower, i.name_upper.lower(), self.namespace, i.camel_name)
            )
            self.outfile.write(
                "{\n"
                '  g_object_set (G_OBJECT (object), "%s", interface_, NULL);\n'
                "}\n"
                "\n" % (i.name_hyphen)
            )
        self.outfile.write("\n")

    def generate_object_manager_client(self):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for ObjectManager client\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n"
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%sObjectManagerClient\n"
                " * @title: %sObjectManagerClient\n"
                " * @short_description: Generated GDBusObjectManagerClient type\n"
                " *\n"
                " * This section contains a #GDBusObjectManagerClient that uses %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc.\n"
                " */\n" % (self.namespace, self.namespace, self.ns_lower),
                False,
            )
        )
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClient:\n"
                " *\n"
                " * The #%sObjectManagerClient structure contains only private data and should only be accessed using the provided API.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sObjectManagerClientClass:\n"
                " * @parent_class: The parent class.\n"
                " *\n"
                " * Class structure for #%sObjectManagerClient.\n"
                % (self.namespace, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write("\n")

        # class boilerplate
        self.outfile.write(
            "G_DEFINE_TYPE (%sObjectManagerClient, %sobject_manager_client, G_TYPE_DBUS_OBJECT_MANAGER_CLIENT)\n"
            "\n" % (self.namespace, self.ns_lower)
        )

        # class boilerplate
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_init (%sObjectManagerClient *manager G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )
        self.outfile.write(
            "static void\n"
            "%sobject_manager_client_class_init (%sObjectManagerClientClass *klass G_GNUC_UNUSED)\n"
            "{\n"
            "}\n"
            "\n" % (self.ns_lower, self.namespace)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_get_proxy_type:\n"
                " * @manager: A #GDBusObjectManagerClient.\n"
                " * @object_path: The object path of the remote object (unused).\n"
                " * @interface_name: (nullable): Interface name of the remote object or %%NULL to get the object proxy #GType.\n"
                " * @user_data: User data (unused).\n"
                " *\n"
                " * A #GDBusProxyTypeFunc that maps @interface_name to the generated #GDBusObjectProxy derived and #GDBusProxy derived types.\n"
                " *\n"
                " * Returns: A #GDBusProxy derived #GType if @interface_name is not %%NULL, otherwise the #GType for #%sObjectProxy.\n"
                % (self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GType\n"
            "%sobject_manager_client_get_proxy_type (GDBusObjectManagerClient *manager G_GNUC_UNUSED, const gchar *object_path G_GNUC_UNUSED, const gchar *interface_name, gpointer user_data G_GNUC_UNUSED)\n"
            "{\n" % (self.ns_lower)
        )
        self.outfile.write(
            "  static gsize once_init_value = 0;\n"
            "  static GHashTable *lookup_hash;\n"
            "  GType ret;\n"
            "\n"
            "  if (interface_name == NULL)\n"
            "    return %sTYPE_OBJECT_PROXY;\n"
            "  if (g_once_init_enter (&once_init_value))\n"
            "    {\n"
            "      lookup_hash = g_hash_table_new (g_str_hash, g_str_equal);\n"
            % (self.ns_upper)
        )
        for i in self.ifaces:
            self.outfile.write(
                '      g_hash_table_insert (lookup_hash, (gpointer) "%s", GSIZE_TO_POINTER (%sTYPE_%s_PROXY));\n'
                % (i.name, i.ns_upper, i.name_upper)
            )
        self.outfile.write("      g_once_init_leave (&once_init_value, 1);\n" "    }\n")
        self.outfile.write(
            "  ret = (GType) GPOINTER_TO_SIZE (g_hash_table_lookup (lookup_hash, interface_name));\n"
            "  if (ret == (GType) 0)\n"
            "    ret = G_TYPE_DBUS_PROXY;\n"
        )
        self.outfile.write("  return ret;\n" "}\n" "\n")

        # constructors
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Asynchronously creates #GDBusObjectManagerClient using %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new() for more details.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new (\n"
            "    GDBusConnection        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GAsyncReadyCallback     callback,\n"
            "    gpointer                user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %sobject_manager_client_new().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_sync:\n"
                " * @connection: A #GDBusConnection.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: (nullable): A bus name (well-known or unique) or %%NULL if @connection is not a message bus connection.\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Synchronously creates #GDBusObjectManagerClient using %sobject_manager_client_get_proxy_type() as the #GDBusProxyTypeFunc. See g_dbus_object_manager_client_new_sync() for more details.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_sync (\n"
            "    GDBusConnection        *connection,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GError                **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "connection", connection, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n"
                " * @user_data: User data to pass to @callback.\n"
                " *\n"
                " * Like %sobject_manager_client_new() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * When the operation is finished, @callback will be invoked in the thread-default main loop of the thread you are calling this method from (see g_main_context_push_thread_default()).\n"
                " * You can then call %sobject_manager_client_new_for_bus_finish() to get the result of the operation.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus_sync() for the synchronous, blocking version of this constructor.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.ns_lower),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "void\n"
            "%sobject_manager_client_new_for_bus (\n"
            "    GBusType                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GAsyncReadyCallback     callback,\n"
            "    gpointer                user_data)\n"
            "{\n"
            '  g_async_initable_new_async (%sTYPE_OBJECT_MANAGER_CLIENT, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write(
            "/**\n"
            " * %sobject_manager_client_new_for_bus_finish:\n"
            " * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to %sobject_manager_client_new_for_bus().\n"
            " * @error: Return location for error or %%NULL\n"
            " *\n"
            " * Finishes an operation started with %sobject_manager_client_new_for_bus().\n"
            " *\n"
            " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
            % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace)
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_for_bus_finish (\n"
            "    GAsyncResult        *res,\n"
            "    GError             **error)\n"
            "{\n"
            "  GObject *ret;\n"
            "  GObject *source_object;\n"
            "  source_object = g_async_result_get_source_object (res);\n"
            "  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);\n"
            "  g_object_unref (source_object);\n"
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower)
        )
        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * %sobject_manager_client_new_for_bus_sync:\n"
                " * @bus_type: A #GBusType.\n"
                " * @flags: Flags from the #GDBusObjectManagerClientFlags enumeration.\n"
                " * @name: A bus name (well-known or unique).\n"
                " * @object_path: An object path.\n"
                " * @cancellable: (nullable): A #GCancellable or %%NULL.\n"
                " * @error: Return location for error or %%NULL\n"
                " *\n"
                " * Like %sobject_manager_client_new_sync() but takes a #GBusType instead of a #GDBusConnection.\n"
                " *\n"
                " * The calling thread is blocked until a reply is received.\n"
                " *\n"
                " * See %sobject_manager_client_new_for_bus() for the asynchronous version of this constructor.\n"
                " *\n"
                " * Returns: (transfer full) (type %sObjectManagerClient): The constructed object manager client or %%NULL if @error is set.\n"
                % (self.ns_lower, self.ns_lower, self.ns_lower, self.namespace),
                False,
            )
        )
        self.outfile.write(" */\n")
        self.outfile.write(
            "GDBusObjectManager *\n"
            "%sobject_manager_client_new_for_bus_sync (\n"
            "    GBusType                bus_type,\n"
            "    GDBusObjectManagerClientFlags  flags,\n"
            "    const gchar            *name,\n"
            "    const gchar            *object_path,\n"
            "    GCancellable           *cancellable,\n"
            "    GError                **error)\n"
            "{\n"
            "  GInitable *ret;\n"
            '  ret = g_initable_new (%sTYPE_OBJECT_MANAGER_CLIENT, cancellable, error, "flags", flags, "name", name, "bus-type", bus_type, "object-path", object_path, "get-proxy-type-func", %sobject_manager_client_get_proxy_type, NULL);\n'
            "  if (ret != NULL)\n"
            "    return G_DBUS_OBJECT_MANAGER (ret);\n"
            "  else\n"
            "    return NULL;\n"
            "}\n"
            "\n" % (self.ns_lower, self.ns_upper, self.ns_lower)
        )
        self.outfile.write("\n")

    # ---------------------------------------------------------------------------------------------------

    def write_gtkdoc_deprecated_and_since_and_close(self, obj, f, indent):
        if len(obj.since) > 0:
            f.write("%*s *\n" "%*s * Since: %s\n" % (indent, "", indent, "", obj.since))
        if obj.deprecated:
            if isinstance(obj, dbustypes.Interface):
                thing = "The D-Bus interface"
            elif isinstance(obj, dbustypes.Method):
                thing = "The D-Bus method"
            elif isinstance(obj, dbustypes.Signal):
                thing = "The D-Bus signal"
            elif isinstance(obj, dbustypes.Property):
                thing = "The D-Bus property"
            else:
                print_error('Cannot handle object "{}"'.format(obj))
            f.write(
                self.docbook_gen.expand(
                    "%*s *\n"
                    "%*s * Deprecated: %s has been deprecated.\n"
                    % (indent, "", indent, "", thing),
                    False,
                )
            )
        f.write("%*s */\n" % (indent, ""))

    # ---------------------------------------------------------------------------------------------------

    def generate_interface_intro(self, i):
        self.outfile.write(
            "/* ------------------------------------------------------------------------\n"
            " * Code for interface %s\n"
            " * ------------------------------------------------------------------------\n"
            " */\n"
            "\n" % (i.name)
        )

        self.outfile.write(
            self.docbook_gen.expand(
                "/**\n"
                " * SECTION:%s\n"
                " * @title: %s\n"
                " * @short_description: Generated C code for the %s D-Bus interface\n"
                " *\n"
                " * This section contains code for working with the #%s D-Bus interface in C.\n"
                " */\n" % (i.camel_name, i.camel_name, i.name, i.name),
                False,
            )
        )
        self.outfile.write("\n")

    def generate(self):
        self.generate_body_preamble()
        for i in self.ifaces:
            self.generate_generic_marshallers(i)
        for i in self.ifaces:
            self.generate_interface_intro(i)
            self.generate_signals_enum_for_interface(i)
            self.generate_introspection_for_interface(i)
            self.generate_signal_marshallers(i)
            self.generate_method_marshallers(i)
            self.generate_interface(i)
            self.generate_property_accessors(i)
            self.generate_signal_emitters(i)
            self.generate_method_calls(i)
            self.generate_method_completers(i)
            self.generate_proxy(i)
            self.generate_skeleton(i)
        if self.generate_objmanager:
            self.generate_object()
            self.generate_object_manager_client()
