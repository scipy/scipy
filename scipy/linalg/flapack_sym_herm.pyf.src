! Signatures for f2py-wrappers of FORTRAN LAPACK Symmetric/Hermitian Matrix functions.
!

subroutine <prefix2>syev(compute_v,lower,n,w,a,work,lwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,&info)
    callprotoargument char*,char*,int*,<ctype2>*,int*,<ctype2>*,<ctype2>*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    <ftype2> dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    <ftype2> dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(3*n-1,1)
    check(lwork>=3*n-1) :: lwork
    <ftype2> dimension(lwork),intent(hide),depend(lwork) :: work

    integer intent(out) :: info

end subroutine <prefix2>syev

subroutine <prefix2c>heev(compute_v,lower,n,w,a,work,lwork,rwork,info)
    ! w,v,info = syev(a,compute_v=1,lower=0,lwork=3*n-1,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2c>*,int*,<ctype2>*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    <ftype2c> dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    <ftype2> dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n) :: lwork=max(2*n-1,1)
    check(lwork>=2*n-1) :: lwork
    <ftype2c> dimension(lwork),intent(hide),depend(lwork) :: work

    <ftype2> dimension(3*n-1),intent(hide),depend(n) :: rwork

    integer intent(out) :: info

end subroutine <prefix2c>heev

subroutine <prefix2>syevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,info)
    ! w,v,info = syevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! real symmetric matrix A using D&C.
    !
    ! Performance tip:
    !   If compute_v=0 then set also overwrite_a=1.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,<ctype2>*,int*,<ctype2>*,<ctype2>*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    <ftype2> dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    <ftype2> dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?1+6*n+2*n*n:2*n+1),1)
    check(lwork>=(compute_v?1+6*n+2*n*n:2*n+1)) :: lwork
    <ftype2> dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(out) :: info

end subroutine <prefix2>syevd

subroutine <prefix2c>heevd(compute_v,lower,n,w,a,work,lwork,iwork,liwork,rwork,lrwork,info)
    ! w,v,info = heevd(a,compute_v=1,lower=0,lwork=min_lwork,overwrite_a=0)
    ! Compute all eigenvalues and, optionally, eigenvectors of a
    ! complex Hermitian matrix A using D&C.
    !
    ! Warning:
    !   If compute_v=0 and overwrite_a=1, the contents of a is destroyed.

    callstatement (*f2py_func)((compute_v?"V":"N"),(lower?"L":"U"),&n,a,&n,w,work,&lwork,rwork,&lrwork,iwork,&liwork,&info)
    callprotoargument char*,char*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2c>*,int*,<ctype2>*,int*,int*,int*,int*

    integer optional,intent(in):: compute_v = 1
    check(compute_v==1||compute_v==0) compute_v
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(a):: n = shape(a,0)
    <ftype2c> dimension(n,n),check(shape(a,0)==shape(a,1)) :: a
    intent(in,copy,out,out=v) :: a

    <ftype2> dimension(n),intent(out),depend(n) :: w

    integer optional,intent(in),depend(n,compute_v) :: lwork=max((compute_v?2*n+n*n:n+1),1)
    check(lwork>=(compute_v?2*n+n*n:n+1)) :: lwork
    <ftype2c> dimension(lwork),intent(hide,cache),depend(lwork) :: work

    integer intent(hide),depend(n,compute_v) :: liwork = (compute_v?3+5*n:1)
    integer dimension(liwork),intent(hide,cache),depend(liwork) :: iwork

    integer intent(hide),depend(n,compute_v) :: lrwork = (compute_v?1+5*n+2*n*n:n)
    <ftype2> dimension(lrwork),intent(hide,cache),depend(n,lrwork) :: rwork
    integer intent(out) :: info

end subroutine <prefix2c>heevd

   subroutine <prefix>sytf2(lower,n,a,lda,ipiv,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&info)
     callprotoargument char*,int*,<ctype>*,int*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     <ftype> dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer intent(out):: info

   end subroutine<prefix>sytf2

  subroutine <prefix2>sygst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = sygst(a,b)
    ! Transforms the generalized symmetric eigenvalue problem to standard.
    ! A = inv(U^T) * A * inv(U), if itype == 1
    ! A = U^T * A * U or L^T * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,<ctype2>*,int*,<ctype2>*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     <ftype2> dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     <ftype2> dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine <prefix2>sygst

   subroutine <prefix>sytrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a symmetric matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?SYTF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,<ctype>*,int*,int*,<ctype>*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     <ftype> dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     <ftype> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine <prefix>sytrf


   subroutine <prefix>sytrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?SYTRF

     fortranname <prefix>sytrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,<ctype>*,int*,int*,<ctype>*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     <ftype> intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     <ftype> intent(out):: work
     integer intent(out):: info

   end subroutine <prefix>sytrf_lwork


   subroutine <prefix>sysv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solve A * X = B for symmetric A matrix

     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,<ctype>*,int*,int*,<ctype>*,int*,<ctype>*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     <ftype> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=udut):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     <ftype> dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     <ftype> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine <prefix>sysv

   subroutine <prefix>sysv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for ?SYSV

     fortranname <prefix>sysv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,<ctype>*,int*,int*,<ctype>*,int*,<ctype>*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide):: nrhs = 1
     <ftype> intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     integer intent(hide):: ipiv
     <ftype> intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     integer intent(hide):: lwork = -1

     <ftype> intent(out):: work
     integer intent(out):: info

   end subroutine <prefix>sysv_lwork

   subroutine <prefix>sysvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! Solve A * X = B for symmetric A matrix
   ! The expert driver of ?SYSV with condition number, backward,forward error estimates and iterative refinement
   ! The (c,z) versions assume only symmetric complex matrices. For Hermitian matrices, routine (c,z)HESVX is used
     threadsafe
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,irwork,&info)
     callprotoargument char*,char*,int*,int*,<ctype>*,int*,<ctype>*,int*,int*,<ctype>*,int*,<ctype>*,int*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,int*,<int,int,float,double>*,int*

     integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     <ftype> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy,out,out=a_s):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     <ftype> optional,dimension(n,n),depend(n),intent(in,out,out=udut):: af
     integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
     integer optional,dimension(n),depend(n),intent(in,out):: ipiv
     <ftype> depend(n),dimension(n,nrhs),intent(in,copy,out,out=b_s):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     <ftype> dimension(n,nrhs),intent(out):: x
     integer depend(b),intent(hide):: ldx = n
     <ftypereal> intent(out):: rcond
     <ftypereal> intent(out),dimension(nrhs),depend(nrhs):: ferr
     <ftypereal> intent(out),dimension(nrhs),depend(nrhs):: berr
     integer optional,intent(in),check(lwork>=<3*n,3*n,2*n,2*n>||lwork==-1):: lwork = max(3*n,1)
     <ftype> dimension(MAX(lwork,1)),intent(hide,cache),depend(lwork) :: work
     <integer,integer,real,double precision> intent(hide,cache),dimension(n),depend(n) :: irwork
     integer intent(out):: info

   end subroutine <prefix>sysvx

   subroutine <prefix>sysvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,irwork,info,factored,lower)

   ! lwork computation for ?SYSVX

     fortranname <prefix>sysvx
     callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&irwork,&info)
     callprotoargument char*,char*,int*,int*,<ctype>*,int*,<ctype>*,int*,int*,<ctype>*,int*,<ctype>*,int*,<ctypereal>*,<ctypereal>*,<ctypereal>*,<ctype>*,int*,<int,int,float,double>*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     integer intent(hide) :: factored = 0
     integer intent(hide):: nrhs = 1
     <ftype> intent(hide):: a
     integer depend(n),intent(hide):: lda = n
     <ftype> intent(hide):: af
     integer depend(n),intent(hide):: ldaf = n
     integer intent(hide):: ipiv
     <ftype> intent(hide):: b
     integer depend(n),intent(hide):: ldb = n
     <ftype> intent(hide):: x
     integer depend(n),intent(hide):: ldx = n
     <ftypereal> intent(hide):: rcond
     <ftypereal> intent(hide):: ferr
     <ftypereal> intent(hide):: berr
     integer intent(hide):: lwork = -1
     <integer,integer,real,double precision> intent(hide):: irwork

     <ftype> intent(out) :: work
     integer intent(out):: info

   end subroutine <prefix>sysvx_lwork


  subroutine <prefix2>sycon(n,a,lda,ipiv,anorm,rcond,work,iwork,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a real symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (S/D)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,iwork,&info)
    callprotoargument char*,int*,<ctype2>*,int*,int*,<ctype2>*,<ctype2>*,<ctype2>*,int*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    <ftype2> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    <ftype2> intent(in) :: anorm
    <ftype2> intent(out) :: rcond
    <ftype2> intent(hide),dimension(2*n),depend(n) :: work
    integer intent(hide),dimension(n),depend(n) :: iwork
    integer intent(out) :: info

  end subroutine <prefix2>sycon


  subroutine <c,z,c,z><sy,\0,he,\2>con(n,a,lda,ipiv,anorm,rcond,work,info,lower)
  !   Estimates the reciprocal of the condition number (in the
  !   1-norm) of a complex symmetric matrix A using the factorization
  !   A = U*D*U**T or A = L*D*L**T computed by (C/Z)SYTRF.
  !
  !   An estimate is obtained for norm(inv(A)), and the reciprocal of the
  !   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,&anorm,&rcond,work,&info)
    callprotoargument char*,int*,<ctypecomplex>*,int*,int*,<ctypereal>*,<ctypereal>*,<ctypecomplex>*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    <ftypecomplex> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    <ftypereal> intent(in) :: anorm
    <ftypereal> intent(out) :: rcond
    <ftypecomplex> intent(hide),dimension(2*n),depend(n) :: work
    integer intent(out) :: info

  end subroutine <c,z,c,z><sy,\0,he,\2>con


  subroutine <prefix>syconv(lower,way,n,a,lda,ipiv,e,info)
  ! ?SYCONV converts A given by ???TRF into L and D and vice-versa.
  ! Get Non-diag elements of D (returned in workspace) and apply or reverse permutation done in TRF.

    callstatement (*f2py_func)((lower?"L":"U"),(way?"R":"C"),&n,a,&lda,ipiv,e,&info)
    callprotoargument char*,char*,int*,<ctype>*,int*,int*,<ctype>*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer optional,intent(in),check(way==0||way==1) :: way = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    <ftype> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=a):: a
    integer intent(hide),depend(a) :: lda = max(shape(a,0),1)
    integer intent(in),dimension(n),depend(n) :: ipiv
    <ftype> intent(out),dimension(n),depend(n):: e
    integer intent(out) :: info
  
  end subroutine <prefix>syconv

  subroutine <prefix2c>hegst(n,a,lda,b,ldb,info,itype,lower)

    ! c, info = hegst(a,b)
    ! Transforms the generalized Hermitian eigenvalue problem to standard.
    ! A = inv(U^H) * A * inv(U), if itype == 1
    ! A = U^H * A * U or L^H * A * L, if itype == 2 or 3, respectively
    ! B must contain the factorized U and L from potrf

     callstatement (*f2py_func)(&itype,(lower?"L":"U"),&n,a,&lda,b,&ldb,&info)
     callprotoargument int*,char*,int*,<ctype2c>*,int*,<ctype2c>*,int*,int*

     integer optional,intent(in),check(itype==1||itype==2||itype==3):: itype = 1
     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     <ftype2c> dimension(n,n),intent(in,out,copy,out=c):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     <ftype2c> dimension(n,n),intent(in):: b
     integer depend(b),intent(hide):: ldb = max(shape(b,0),1)
     integer intent(out):: info

   end subroutine <prefix2c>hegst


   subroutine <prefix2c>hetrf(lower,n,a,lda,ipiv,work,lwork,info)

     ! Compute the factorization of a hermitian matrix such that
     ! A = L * D * L^T if lower = 1
     ! A = U * D * U^T if lower = 0
     ! This is similar to ?HETF2 but uses BLAS3 blocked calls

     callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,ipiv,work,&lwork,&info)
     callprotoargument char*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1):: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     <ftype2c> dimension(n,n),intent(in,out,copy,out=ldu):: a
     integer depend(a),intent(hide):: lda = max(shape(a,0),1)
     integer dimension(n),depend(n),intent(out):: ipiv
     integer optional,intent(in),depend(n),check(lwork>=n||lwork==-1):: lwork = max(n,1)
     <ftype2c> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine <prefix2c>hetrf


   subroutine <prefix2c>hetrf_lwork(lower,n,a,lda,ipiv,work,lwork,info)
     ! lwork computation for ?HETRF

     fortranname <prefix2c>hetrf

     callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&ipiv,&work,&lwork,&info)
     callprotoargument char*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,int*

     integer intent(in):: n
     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

     <ftype2c> intent(hide):: a
     integer depend(n),intent(hide):: lda = max(n,1)
     integer intent(hide):: ipiv
     integer intent(hide):: lwork = -1

     <ftype2c> intent(out):: work
     integer intent(out):: info

   end subroutine <prefix2c>hetrf_lwork


   subroutine <prefix2c>hesv(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! Solves A * X = B for X
   ! A is hermitian. For symmetric A see ?SYSV
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
     threadsafe
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,a,&lda,ipiv,b,&ldb,work,&lwork,&info)
     callprotoargument char*,int*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer depend(a),intent(hide):: n = shape(a,0)
     integer depend(b),intent(hide):: nrhs = shape(b,1)
     <ftype2c> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=uduh):: a
     integer depend(a),intent(hide):: lda = shape(a,0)
     integer dimension(n),depend(n),intent(out):: ipiv
     <ftype2c> dimension(n,nrhs),check(shape(b,0)==n),depend(n),intent(in,out,copy,out=x):: b
     integer depend(b),intent(hide):: ldb = shape(b,0)
     integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(n,1)
     <ftype2c> depend(lwork),dimension(MAX(lwork,1)),intent(hide,cache):: work
     integer intent(out):: info

   end subroutine <prefix2c>hesv

   subroutine <prefix2c>hesv_lwork(n,nrhs,a,lda,ipiv,b,ldb,work,lwork,info,lower)

   ! lwork computation for C/ZHESV

     fortranname <prefix2c>hesv
     callstatement (*f2py_func)((lower?"L":"U"),&n,&nrhs,&a,&lda,&ipiv,&b,&ldb,&work,&lwork,&info)
     callprotoargument char*,int*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,int*

     integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
     integer intent(in):: n

     integer intent(hide):: nrhs = 1
     <ftype2c> intent(hide):: a
     integer intent(hide),depend(n):: lda = n
     integer intent(hide):: ipiv
     <ftype2c> intent(hide):: b
     integer intent(hide),depend(n):: ldb = n
     integer intent(hide):: lwork = -1

     <ftype2c> intent(out):: work
     integer intent(out):: info

   end subroutine <prefix2c>hesv_lwork

subroutine <prefix2c>hesvx(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
   ! Solves A * X = B for X
   ! Expert driver for ?HESV
   ! A is hermitian. For symmetric A see ?SYSVX
   ! A = U * D * U**H if lower = 0
   ! A = L * D * L**H if lower = 1
    threadsafe
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,a,&lda,af,&ldaf,ipiv,b,&ldb,x,&ldx,&rcond,ferr,berr,work,&lwork,rwork,&info)
    callprotoargument char*,char*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,int*,<ctype2>*,int*

    integer optional,intent(in),check(factored==0||factored==1) :: factored = 0
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer depend(a),intent(hide):: n = shape(a,0)
    integer depend(b),intent(hide):: nrhs = shape(b,1)
    <ftype2c> dimension(n,n),check(shape(a,0)==shape(a,1)),intent(in,copy) :: a
    integer depend(a),intent(hide):: lda = shape(a,0)
    <ftype2c> optional,dimension(n,n),depend(n),intent(in,out,out=uduh) :: af
    integer optional,depend(af),intent(hide):: ldaf = shape(af,0)
    integer optional,depend(n),dimension(n),intent(in,out):: ipiv
    <ftype2c> depend(n),dimension(n,nrhs),intent(in,copy) :: b
    integer depend(b),intent(hide):: ldb = shape(b,0)
    <ftype2c> depend(n,nrhs),dimension(n,nrhs),intent(out) :: x
    integer depend(x),intent(hide):: ldx = shape(x,0)
    <ftype2> intent(out):: rcond
    <ftype2> intent(out),dimension(nrhs),depend(nrhs):: ferr
    <ftype2> intent(out),dimension(nrhs),depend(nrhs):: berr
    <ftype2c> dimension(MAX(1,lwork)),depend(lwork),intent(hide,cache):: work
    integer optional,intent(in),depend(n),check(lwork>=1||lwork==-1):: lwork = max(2*n,1)
    <ftype2> intent(hide,cache),dimension(n),depend(n) :: rwork
    integer intent(out):: info

end subroutine <prefix2c>hesvx

subroutine <prefix2c>hesvx_lwork(n,nrhs,a,lda,af,ldaf,ipiv,b,ldb,x,ldx,rcond,ferr,berr,work,lwork,rwork,info,factored,lower)
    ! lwork computation for ?HESVX
    fortranname <prefix2c>hesvx
    callstatement (*f2py_func)((factored?"F":"N"),(lower?"L":"U"),&n,&nrhs,&a,&lda,&af,&ldaf,&ipiv,&b,&ldb,&x,&ldx,&rcond,&ferr,&berr,&work,&lwork,&rwork,&info)
    callprotoargument char*,char*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,int*,<ctype2c>*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2c>*,int*,<ctype2>*,int*

    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0
    integer intent(in):: n

    integer intent(hide) :: factored = 0
    integer depend(b),intent(hide):: nrhs = 1
    <ftype2c> intent(hide) :: a
    integer depend(n),intent(hide):: lda = n
    <ftype2c> intent(hide) :: af
    integer depend(n),intent(hide):: ldaf = n
    integer intent(hide):: ipiv
    <ftype2c> intent(hide) :: b
    integer depend(n),intent(hide):: ldb = n
    <ftype2c> intent(hide) :: x
    integer depend(n),intent(hide):: ldx = n
    <ftype2> intent(hide):: rcond
    <ftype2> intent(hide):: ferr
    <ftype2> intent(hide):: berr
    integer intent(hide):: lwork = -1
    <ftype2> intent(hide):: rwork

    <ftype2c> intent(out):: work
    integer intent(out):: info

end subroutine <prefix2c>hesvx_lwork

subroutine <prefix2>sytrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a real symmetric matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**T * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,<ctype2>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    <ftype2> dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    <ftype2> dimension(n),intent(out),depend(n) :: d
    <ftype2> dimension(n-1),intent(out),depend(n) :: e
    <ftype2> dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    <ftype2> dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine <prefix2>sytrd

subroutine <prefix2>sytrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for sytrd
    fortranname <prefix2>sytrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,<ctype2>*,int*,<ctype2>*,<ctype2>*,<ctype2>*,<ctype2>*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    <ftype2> intent(hide) :: a
    <ftype2> intent(hide) :: d
    <ftype2> intent(hide) :: e
    <ftype2> intent(hide) :: tau
    <ftype2> intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine <prefix2>sytrd_lwork

subroutine <prefix2c>hetrd(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! Reduce a complex hermitian matrix A to real symmetric
    ! tridiagonal form T by an orthogonal similarity transformation:
    ! Q**H * A * Q = T.

    callstatement (*f2py_func)((lower?"L":"U"),&n,a,&lda,d,e,tau,work,&lwork,&info);
    callprotoargument char*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,int*,int*

    integer intent(hide),depend(a) :: lda=MAX(shape(a,0),1)
    integer intent(hide),depend(a) :: n=shape(a,1)
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    <ftype2c> dimension(lda,n),check(shape(a,0)==shape(a,1)),intent(in,out,copy,out=c) :: a
    <ftype2> dimension(n),intent(out),depend(n) :: d
    <ftype2> dimension(n-1),intent(out),depend(n) :: e
    <ftype2c> dimension(n-1),intent(out),depend(n) :: tau
    integer intent(in),optional,depend(n),check(lwork>=1||lwork==-1) :: lwork = MAX(n,1)
    <ftype2c> dimension(lwork),intent(cache,hide),depend(lwork) :: work
    integer intent(out) :: info

end subroutine <prefix2c>hetrd

subroutine <prefix2c>hetrd_lwork(lower,n,a,lda,d,e,tau,work,lwork,info)
    ! lwork computation for hetrd
    fortranname <prefix2c>hetrd
    callstatement (*f2py_func)((lower?"L":"U"),&n,&a,&lda,&d,&e,&tau,&work,&lwork,&info);
    callprotoargument char*,int*,<ctype2c>*,int*,<ctype2>*,<ctype2>*,<ctype2c>*,<ctype2c>*,int*,int*

    integer intent(in) :: n
    integer optional,intent(in),check(lower==0||lower==1) :: lower = 0

    integer intent(hide),depend(n) :: lda=MAX(n,1)
    <ftype2c> intent(hide) :: a
    <ftype2> intent(hide) :: d
    <ftype2> intent(hide) :: e
    <ftype2c> intent(hide) :: tau
    <ftype2c> intent(out) :: work
    integer intent(hide) :: lwork = -1
    integer intent(out) :: info

end subroutine <prefix2c>hetrd_lwork

subroutine <prefix2>syevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Real - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2> intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2> intent(hide) :: vl=0
    <ftype2> intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    <ftype2> intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    <ftype2> intent(out),dimension(n),depend(n) :: w
    <ftype2> intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(26*n,1)
    <ftype2>  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine <prefix2>syevr

subroutine <prefix2c>heevr(jobz,range,uplo,n,a,lda,vl,vu,il,iu,abstol,m,w,z,ldz,isuppz,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Standard Eigenvalue Problem
    ! simple/expert driver: all eigenvectors or optionally selected eigenvalues
    ! algorithm: Relatively Robust Representation
    ! matrix storage
    ! Complex - Single precision
    character intent(in) :: jobz='V'
    character intent(in) :: range='A'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2c> intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2> intent(hide) :: vl=0
    <ftype2> intent(hide) :: vu=1
    integer optional,intent(in) :: il=1
    integer optional,intent(in),depend(n) :: iu=n
    <ftype2> intent(hide) :: abstol=0.
    integer  intent(hide),depend(iu) :: m=iu-il+1
    <ftype2> intent(out),dimension(n),depend(n) :: w
    <ftype2c> intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(hide),dimension(2*m) :: isuppz
    integer intent(in),depend(n) :: lwork=max(18*n,1)
    <ftype2c>  intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=24*n
    <ftype2> intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n):: liwork=10*n
    integer intent(hide),dimension(liwork) :: iwork
    integer  intent(out) :: info

end subroutine <prefix2c>heevr

subroutine <prefix2>sygv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2> intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(3*n-1,1)
    <ftype2> intent(hide),dimension(lwork) :: work
    integer intent(out) :: info

end subroutine <prefix2>sygv

subroutine <prefix2c>hegv(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2c> intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2c> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(out),dimension(n),depend(n) :: w
    integer intent(hide) :: lwork=max(18*n-1,1)
    <ftype2c> intent(hide),dimension(lwork) :: work
    <ftype2> intent(hide),dimension(3*n-2) :: rwork
    integer intent(out) :: info

end subroutine <prefix2c>hegv

!
! Divide and conquer routines for generalized eigenvalue problem
!
subroutine <prefix2>sygvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2> intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(1+6*n+2*n*n,1)
    <ftype2> intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine <prefix2>sygvd

subroutine <prefix2c>hegvd(itype,jobz,uplo,n,a,lda,b,ldb,w,work,lwork,rwork,lrwork,iwork,liwork,info)
    ! Generalized Eigenvalue Problem
    ! simple driver (all eigenvectors)
    ! algorithm: divide and conquer
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2c> intent(in,copy,out,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2c> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(out),dimension(n),depend(n) :: w
    integer intent(in),depend(n) :: lwork=max(2*n+n*n,1)
    <ftype2c> intent(hide),dimension(lwork) :: work
    integer intent(hide),depend(n) :: lrwork=1+5*n+2*n*n
    <ftype2> intent(hide),dimension(lrwork) :: rwork
    integer intent(hide),depend(n) :: liwork=3+5*n
    integer intent(hide),dimension(liwork) :: iwork
    integer intent(out) :: info

end subroutine <prefix2c>hegvd

!
! Expert routines for generalized eigenvalue problem
!
subroutine <prefix2>sygvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Real - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2> intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(hide) :: vl=0.
    <ftype2> intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    <ftype2> intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    <ftype2> intent(out),dimension(n),depend(n) :: w
    <ftype2> intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(8*n,1)
    <ftype2> intent(hide),dimension(lwork),depend(n,lwork) :: work
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info

end subroutine <prefix2>sygvx

subroutine <prefix2c>hegvx(itype,jobz,range,uplo,n,a,lda,b,ldb,vl,vu,il,iu,abstol,m,w,z,ldz,work,lwork,rwork,iwork,ifail,info)
    ! Generalized Eigenvalue Problem
    ! expert driver (selected eigenvectors)
    ! algorithm: standard
    ! matrix storage
    ! Complex - Single precision
    integer optional,intent(in) :: itype=1
    character intent(in) :: jobz='V'
    character intent(hide) :: range='I'
    character intent(in) :: uplo='L'
    integer intent(hide) :: n=shape(a,0)
    <ftype2c> intent(in,copy,aligned8),dimension(n,n) :: a
    integer intent(hide),depend(n,a) :: lda=n
    <ftype2c> intent(in,copy,aligned8),dimension(n,n) :: b
    integer intent(hide),depend(n,b) :: ldb=n
    <ftype2> intent(hide) :: vl=0.
    <ftype2> intent(hide) :: vu=0.
    integer optional,intent(in) :: il=1
    integer intent(in) :: iu
    <ftype2> intent(hide) :: abstol=0.
    integer intent(hide),depend(iu) :: m=iu-il+1
    <ftype2> intent(out),dimension(n),depend(n) :: w
    <ftype2c> intent(out),dimension(n,m),depend(n,m) :: z
    integer intent(hide),check(shape(z,0)==ldz),depend(n,z) :: ldz=n
    integer intent(in),depend(n) :: lwork=max(18*n-1,1)
    <ftype2c> intent(hide),dimension(lwork),depend(n,lwork) :: work
    <ftype2> intent(hide),dimension(7*n) :: rwork
    integer intent(hide),dimension(5*n) :: iwork
    integer intent(out),dimension(n),depend(n) :: ifail
    integer intent(out) :: info
end subroutine <prefix2c>hegvx
