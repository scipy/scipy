# Last Change: Mon Nov 19 07:00 PM 2007 J
# vim:syntax=python

#import os
#import sys
#from os.path import join as pjoin, basename as pbasename, dirname as pdirname
#from copy import deepcopy
 
from numpy.distutils.misc_util import get_numpy_include_dirs
from numpy.distutils.scons import get_python_inc#, get_pythonlib_dir
from numpy.distutils.scons import GetNumpyEnvironment
from numpy.distutils.scons import CheckCBLAS, CheckF77BLAS, CheckF77LAPACK,\
                                  CheckCLAPACK
#from numpy.distutils.scons.configuration import write_info

#from scons_support import CheckBrokenMathlib, define_no_smp, \
#    generate_config_header, generate_config_header_emitter

#-------------------
# To skip wrapping single precision atlas/lapack/blas routines, set
# the following flag to True:
skip_single_routines = 0

# Some OS distributions (e.g. Redhat, Suse) provide a blas library that
# is built using incomplete blas sources that come with lapack tar-ball.
# In order to use such a library in scipy.linalg, the following flag
# must be set to True:
using_lapack_blas = 0

env = GetNumpyEnvironment(ARGUMENTS)
env.Append(CPPPATH = [get_python_inc(), get_numpy_include_dirs()])
#if os.name == 'nt':
#    # NT needs the pythonlib to run any code importing Python.h, including
#    # simple code using only typedef and so on, so we need it for configuration
#    # checks
#    env.AppendUnique(LIBPATH = [get_pythonlib_dir()])

#=======================
# Starting Configuration
#=======================
# XXX: separate env for configuration
config = env.NumpyConfigure(custom_tests = {'CheckCBLAS' : CheckCBLAS,
                                            'CheckBLAS' : CheckF77BLAS,
                                            'CheckCLAPACK' : CheckCLAPACK,
                                            'CheckLAPACK' : CheckF77LAPACK})

#--------------
# Checking Blas
#--------------
st = config.CheckBLAS()
if not st:
    raise RuntimeError("no blas found, necessary for linalg module")

st = config.CheckLAPACK()
if not st:
    raise RuntimeError("no lapack found, necessary for linalg module")

if config.CheckCBLAS():
    has_cblas = 1
else:
    has_cblas = 0

if config.CheckCLAPACK():
    has_clapack = 1
else:
    has_clapack = 0

config.Finish()
#write_info(env)

#==========
#  Build
#==========

# XXX: handle cblas wrapper for complex (check in numpy.scons or here ?)
import os
from os.path import join as pjoin

from interface_gen import generate_interface

env.AppendUnique(CPPPATH = env['F2PYINCLUDEDIR'])

def do_generate_interface(target, source, env):
    """Generate a .pyf file from another pyf file (!)."""
    # XXX: do this correctly
    target_name = str(target[0])
    source_name = str(source[0])

    # XXX handle skip names
    name = os.path.splitext(os.path.basename(target_name))[0]
    generate_interface(name, source_name, target_name)
    return 0

def generate_interface_emitter(target, source, env):
    source = [pjoin(env['build_dir'], str(i)) for i in source]
    target = [pjoin(env['build_dir'], str(i)) for i in target]
    base = str(target[0])
    return (['%s.pyf' % base], source)

def do_generate_fake_interface(target, source, env):
    """Generate a (fake) .pyf file from another pyf file (!)."""
    # XXX: do this correctly
    target_name = str(target[0])
    source_name = str(source[0])

    # XXX handle skip names
    name = os.path.splitext(os.path.basename(target_name))[0]
    generate_interface(name, source_name, target_name)
        
    f = open(target_name, 'w')
    f.write('python module '+name+'\n')
    f.write('usercode void empty_module(void) {}\n')
    f.write('interface\n')
    f.write('subroutine empty_module()\n')
    f.write('intent(c) empty_module\n')
    f.write('end subroutine empty_module\n')
    f.write('end interface\nend python module'+name+'\n')
    f.close()

    return 0

env['BUILDERS']['haha'] = Builder(action = do_generate_interface,
                                  emitter = generate_interface_emitter)

env['BUILDERS']['hihi'] = Builder(action = do_generate_fake_interface,
                                  emitter = generate_interface_emitter)

# fblas:
# XXX: handle Accelerate problem
env.haha('fblas', 'generic_fblas.pyf')
env.NumpyPythonExtension('fblas', source = ['fblas.pyf', pjoin('src', 'fblaswrap.f')])

# cblas:
if has_cblas:
    env.haha('cblas', 'generic_cblas.pyf')
else:
    env.hihi('cblas', 'generic_cblas.pyf')
env.NumpyPythonExtension('cblas', source = 'cblas.pyf')

# flapack
env.haha('flapack', 'generic_flapack.pyf')
env.NumpyPythonExtension('flapack', source = 'flapack.pyf')

# # clapack
# if has_clapack:
#     env.haha('build/scons/clapack', 'generic_clapack.pyf')
# else:
#     env.hihi('build/scons/clapack', 'generic_clapack.pyf')
# env.NumpyPythonExtension('clapack', source = 'clapack.pyf')
# 
# # _flinalg
# env.NumpyPythonExtension('_flinalg', source = [join('src', 'det.f'), 
#                                                join('src', 'lu.f')])
