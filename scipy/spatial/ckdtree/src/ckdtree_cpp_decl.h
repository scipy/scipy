#ifndef CKDTREE_CPP_DECL
#define CKDTREE_CPP_DECL

/*
 * Make sure that these declarations are correct
 * by looking at the header file ckdtree.h which 
 * is generated by running
 *
 * $ cython ckdtree.pyx
 *
 * Unless you add fields to cKDTree there will be 
 * no change in struct ckdtree. The fields are layed
 * out in the same order they are defined in Cython.
 */

struct ckdtreenode {
    npy_intp      split_dim;
    npy_intp      children;
    npy_float64   split;
    npy_intp      start_idx;
    npy_intp      end_idx;
    ckdtreenode   *less;
    ckdtreenode   *greater;
    npy_intp      _less;
    npy_intp      _greater;
};

struct ckdtreebox {
    npy_float64 * fbox; /* full box */
    npy_float64 * hbox; /* half box */
    const void allocate(const int m, const npy_float64* fbox) {
        int i;
        this->fbox = new npy_float64[m];
        this->hbox = new npy_float64[m];
        for(i=0; i<m; i++) {
            this->fbox[i] = fbox[i];
            this->hbox[i] = 0.5 * fbox[i];
        }
    }
    const void free() {
        if (this->fbox) {
            delete [] this->fbox;
            delete [] this->hbox;
        }
        this->fbox = NULL;
    }
};

#ifdef CKDTREE_METHODS_IMPL


struct ckdtree {
    PyObject_HEAD
    // vtab pointer is present as long as cKDTree has cdef methods
    const void          *vtab; 
    // tree structure
    const std::vector<ckdtreenode>  *tree_buffer;
    const ckdtreenode   *ctree;
    const PyObject      *dummy;
    // meta data
    const PyArrayObject *data;
    const npy_float64   *raw_data;
    const npy_intp      n;
    const npy_intp      m;
    const npy_intp      leafsize;
    const PyArrayObject *maxes;
    const npy_float64   *raw_maxes;
    const PyArrayObject *mins;
    const npy_float64   *raw_mins;
    const PyArrayObject *indices;
    const npy_intp      *raw_indices;
    const PyArrayObject *_median_workspace;
};

#endif
#endif
