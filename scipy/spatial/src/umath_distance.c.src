#define NPY_NO_DEPRECATED_API NPY_API_VERSION

#include "Python.h"
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_3kcompat.h"
#include "numpy/npy_math.h"
#include<stdlib.h>
#include<stdio.h>
#include <math.h>

/* The C preprocessor requires these double indirection levels to allow
 * stringification and concatenation of a macro value, i.e. MODULE_NAME
 */
#define EXPAND_AND_QUOTE(str) QUOTE(str)
#define QUOTE(str) #str
#define PASTE(a, b) a ## b
#define JOIN(a, b) PASTE(a, b)

#define MODULE_NAME _umath_distance /* edit this line with the module name */
#define VERSION 0.1

#define MODULE_NAME_STR EXPAND_AND_QUOTE(MODULE_NAME)
#define VERSION_STR EXPAND_AND_QUOTE(VERSION)
#define APPEND_MODULE(name) JOIN(name, MODULE_NAME)
#define PREPEND_MODULE(name) JOIN(MODULE_NAME, name)

/*
 *****************************************************************************
 **                        GUFUNC OUTER LOOP MACROS                         **
 *****************************************************************************
 */
 
#define INIT_OUTER_LOOP_1(dimensions, steps) \
    npy_intp _loop_len = *dimensions++; \
    npy_intp _n; \
    npy_intp _s0 = *steps++;

#define INIT_OUTER_LOOP_2(dimensions, steps) \
    INIT_OUTER_LOOP_1(dimensions, steps) \
    npy_intp _s1 = *steps++;

#define INIT_OUTER_LOOP_3(dimensions, steps) \
    INIT_OUTER_LOOP_2(dimensions, steps) \
    npy_intp _s2 = *steps++;

#define INIT_OUTER_LOOP_4(dimensions, steps) \
    INIT_OUTER_LOOP_3(dimensions, steps) \
    npy_intp _s3 = *steps++;

#define INIT_OUTER_LOOP_5(dimensions, steps) \
    INIT_OUTER_LOOP_4(dimensions, steps) \
    npy_intp _s4 = *steps++;

#define INIT_OUTER_LOOP_6(dimensions, steps) \
    INIT_OUTER_LOOP_5(dimensions, steps) \
    npy_intp _s5 = *steps++;

#define INIT_OUTER_LOOP_7(dimensions, steps) \
    INIT_OUTER_LOOP_6(dimensions, steps) \
    npy_intp _s6 = *steps++;

#define INIT_OUTER_LOOP_8(dimensions, steps) \
    INIT_OUTER_LOOP_7(dimensions, steps) \
    npy_intp s7 = *steps++;

#define BEGIN_OUTER_LOOP_1(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0) {

#define BEGIN_OUTER_LOOP_2(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1) {

#define BEGIN_OUTER_LOOP_3(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2) {

#define BEGIN_OUTER_LOOP_4(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3) {

#define BEGIN_OUTER_LOOP_5(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4) {

#define BEGIN_OUTER_LOOP_6(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5) {

#define BEGIN_OUTER_LOOP_7(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5, \
                                args[6] += _s6) {

#define BEGIN_OUTER_LOOP_8(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5, \
                                args[6] += _s6, \
                                args[7] += _s7) {

#define END_OUTER_LOOP  }

/*
 *****************************************************************************
 **                             SOME CONSTANTS                              **
 *****************************************************************************
 */
 
 static npy_double d_nan;
 static npy_double d_inf;
 static npy_double d_ninf;
 
 static void init_constants(void)
 {
    /* It seems that NPY_INFINITY and NPY_NAN macros can't be used as
       initializers, or so says numpy.linalg.umath_linalg.c.src */
    d_nan = NPY_NAN;
    d_inf = NPY_INFINITY;
    d_ninf = -NPY_INFINITY;
}
    
/*
 *****************************************************************************
 **                          DISTANCE FUNCTIONS                            **
 *****************************************************************************
 */
 
/* The definitions of some distance functions are a little unclear. The
 * following references are cited in the comments in the code below:
 *
 * [Deza 2013]
 * Deza, M. M., & Deza, E. (2013). Encyclopedia of Distances. Springer. 
 * 
 * [Zhang 2003]
 * Zhang, B., & Srihari, S. N. (2003, January). Binary vector dissimilarity
 * measures for handwriting identification. In Electronic Imaging 2003
 * (pp. 28-38). International Society for Optics and Photonics.
 * http://www.cedar.buffalo.edu/papers/articles/SPIE03_hwidiss.pdf
 * http://www.cedar.buffalo.edu/~srihari/papers/DRR03-Binary.pdf
 *
 * [Choi 2010]
 * Choi, S. S., Cha, S. H., & Tappert, C. (2010). A survey of binary
 * similarity and distance measures. Journal of Systemics, Cybernetics
 * and Informatics, 8(1), 43-48.
 * http://www.iiisci.org/Journal/CV$/sci/pdfs/GS315JG.pdf
 * http://www.iiisci.org/Journal/SCI/FullText.asp?var=&id=GS315JG
 *
 * [Cha 2007]
 * Cha, S. H. (2007). Comprehensive survey on distance/similarity measures
 * between probability density functions. City, 1(2), 1.
 * http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&type=pdf&doi=10.1.1.154.8446
 *
 * [McCune 2002]
 * McCune, B., Grace, J. B., & Urban, D. L. (2002). Analysis of ecological
 * communities (Vol. 28). Gleneden Beach, Oregon: MjM software design.
 * http://www.umass.edu/landeco/teaching/multivariate/readings/McCune.and.Grace.2002.chapter6.pdf
 * http://people.oregonstate.edu/~mccuneb/bookpowerpoints.htm
 *
 * [Faith 1987]
 * Faith, D. P., Minchin, P. R., & Belbin, L. (1987). Compositional
 * dissimilarity as a robust measure of ecological distance. Vegetatio,
 * 69(1-3), 57-68.
 * http://www.ohio.edu/plantbio/staff/mccarthy/multivariate/FaithEtAl1987.pdf
 *
 * [Lance 1966]
 * Lance, G. N., & Williams, W. T. (1966). Computer programs for hierarchical
 * polythetic classification ("similarity analyses"). The Computer Journal,
 * 9(1), 60-64.
 * http://comjnl.oxfordjournals.org/content/9/1/60.full.pdf
 *
 * [Lance 1968]
 * Lance, G. N., & Williams, W. T. (1968). Note on a New Information Statistic
 * Classificatory Program. The Computer Journal, 11(2), 195-195.
 * http://comjnl.oxfordjournals.org/content/9/4/381.full.pdf
 */

/* The Bray-Curtis or Sorensen distance.
 *
 * The definition in [Deza 2013] and [Cha 2007] does not include taking
 * the absolute value of the denominator, which is also how it is described
 * in [Lance 1966] as the non-metric coefficient, probably because it is
 * only defined for non-negative vectors. Kept it unchanged for backwards
 * compatibility.
 *
 * [Lance 1966] specifies that the return should be zero if the denominator
 * is zero, but BrayCurtisDistance in Mathematica 9 returns positive infinity
 * whenever that happens regardless of the value of the denominator. The code
 * below follows [Lance 1966] if both vectors are all zeros, and Mathematica
 * if the denominator is zero but the numerator is not.
 */

static npy_double
DOUBLE_bray_curtis_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double num = 0, denom = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u,
                   v_val = *(npy_double *)v;
        num += fabs(u_val - v_val);
        denom += fabs(u_val + v_val);
    }
    return denom == 0 ? (num == 0 ? 0 : d_inf) : num / denom;
}

/* The Canberra distance.
 *
 * Definition taken from [Deza 2013]. In [Cha 2007] there is no absolute
 * value for the denominator terms, probably because it only considers
 * non-negative vectors. Wikipedia does include them. Keeping them for
 * backwards compatibility.
 *
 * Skipping terms with zero denominator is specified in [Lance 1968] and
 * is consistent with the handling of CanberraDistance in Mathematica 9.
 */

static npy_double
DOUBLE_canberra_distance(const char *u, const char *v, npy_intp dim,
                         npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = fabs(*(npy_double *)u),
                   v_val = fabs(*(npy_double *)v),
                   num = fabs(u_val - v_val),
                   denom = fabs(u_val) + fabs(v_val);
        if (denom != 0) {
            dist += num / denom;
        }
    }
    return dist;
}

/* The Chebyshev distance */

static npy_double
DOUBLE_chebyshev_distance(const char *u, const char *v, npy_intp dim,
                          npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = fabs(*(npy_double *)u - *(npy_double *)v);
        if (delta > dist) {
            dist = delta;
        }
    }
    return dist;
}

static npy_double
DOUBLE_weighted_chebyshev_distance(const char *u, const char *v,
                                   const char *w, npy_intp dim,
                                   npy_intp u_str, npy_intp v_str,
                                   npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta = *(npy_double *)w * fabs(*(npy_double *)u -
                                                   *(npy_double *)v);
        if (delta > dist) {
            dist = delta;
        }
    }
    return dist;
}


static npy_double
DOUBLE_minimum_chebyshev_distance(const char *u, const char *v, npy_intp dim,
                                  npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = fabs(*(npy_double *)u - *(npy_double *)v);
    
    for (u += u_str,
         v += v_str,
         j = 1; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = fabs(*(npy_double *)u - *(npy_double *)v);
        if (delta < dist) {
            dist = delta;
        }
        if (dist == 0) {
            break;
        }
    }
    return dist;
}

static npy_double
DOUBLE_weighted_minimum_chebyshev_distance(const char *u, const char *v,
                                           const char *w, npy_intp dim,
                                           npy_intp u_str, npy_intp v_str,
                                           npy_intp w_str) {
    npy_intp j;
    npy_double dist = *(npy_double *)w * fabs(*(npy_double *)u -
                                              *(npy_double *)v);
    for (u += u_str,
         v += v_str,
         w += w_str,
         j = 1; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta = *(npy_double *)w * fabs(*(npy_double *)u -
                                                   *(npy_double *)v);
        if (delta < dist) {
            dist = delta;
        }
        if (dist == 0) {
            break;
        }
    }
    return dist;
}

/* The City Block or Manhattan distance */

static npy_double
DOUBLE_city_block_distance(const char *u, const char *v, npy_intp dim,
                           npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        dist += fabs(*(npy_double *)u - *(npy_double *)v);
    }
    return dist;
}

static npy_double
DOUBLE_weighted_city_block_distance(const char *u, const char *v,
                                    const char *w, npy_intp dim,
                                    npy_intp u_str, npy_intp v_str,
                                    npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        dist += *(npy_double *)w * fabs(*(npy_double *)u - *(npy_double *)v);
    }
    return dist;
}

/* The correlation distance
 * 
 * Haven't found any reference specifying what to return whenever the
 * denominator comes out to zero. The code follows what Mathematica 9
 * does in CorrelationDistance, which returns zero distance for all such
 * cases. 
 */

static npy_double
DOUBLE_correlation_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double u2 = 0, v2 = 0, uv = 0,
               u_mean = 0, v_mean = 0, denom;
    const char *u_ptr, *v_ptr;
    for (u_ptr = u,
         v_ptr = v,
         j = 0; j < dim; j++,
                         u_ptr += u_str,
                         v_ptr += v_str) {
        u_mean += *(npy_double *)u_ptr;
        v_mean += *(npy_double *)v_ptr;
    }
    u_mean /= dim;
    v_mean /= dim;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u - u_mean,
                   v_val = *(npy_double *)v - v_mean;
        u2 += u_val * u_val;
        v2 += v_val * v_val;
        uv += u_val * v_val;
    }
    denom = u2 * v2;
    return denom == 0 ? 0 : 1 - uv / sqrt(denom);
}

static npy_double
DOUBLE_cached_correlation_distance(const char *u, const char *v,
                                   const char *u_mean, const char *v_mean,
                                   const char *u_ssqdm, const char *v_ssqdm,
                                   npy_intp dim,
                                   npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double uv = 0,
               u_mean_val = *(npy_double *)u_mean,
               v_mean_val = *(npy_double *)v_mean,
               denom = *(npy_double *)u_ssqdm * *(npy_double *)v_ssqdm;
    if (denom == 0) {
        return 0;
    }
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u - u_mean_val,
                   v_val = *(npy_double *)v - v_mean_val;
       uv += (*(npy_double *)u - u_mean_val) *
             (*(npy_double *)v - v_mean_val);
    }
    return 1 - uv / denom;
}

/* The cosine distance
 * 
 * Haven't found any reference specifying what to return whenever the
 * denominator comes out to zero. The code follows what Mathematica 9
 * does in CosineDistance, which returns zero distance for all such
 * cases. This is not consistent with what is done, for instance, in
 * sklearn.metrics.pairwise.cosine_similarity, which returns zero for
 * the similarity, not the distance
 */
static npy_double
DOUBLE_cosine_distance(const char *u, const char *v, npy_intp dim,
                       npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double u2 = 0, v2 = 0, uv = 0, denom;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u,
                   v_val = *(npy_double *)v;
        u2 += u_val * u_val;
        v2 += v_val * v_val;
        uv += u_val * v_val;
    }
    denom = u2 * v2;
    return denom == 0 ? 0 : 1 - uv / sqrt(denom);
}

static npy_double
DOUBLE_cached_cosine_distance(const char *u, const char *v,
                              const char *u_norm, const char *v_norm,
                              npy_intp dim,
                              npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double uv = 0,
               denom = *(npy_double *)u_norm * *(npy_double *)v_norm;
    if (denom == 0) {
        return 0;
    }
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        uv += *(npy_double *)u * *(npy_double *)v;
    }
    return 1 - uv / denom;
}

/* The Euclidean and squared Euclidean distances */

/**begin repeat
 * #SQ = sq,#
 * #do_sqrt = 0,1#
 */
 
static npy_double
DOUBLE_@SQ@euclidean_distance(const char *u, const char *v, npy_intp dim,
                              npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = *(npy_double *)u - *(npy_double *)v;
        dist += delta * delta;
    }
    #if @do_sqrt@
        dist = sqrt(dist);
    #endif
    return dist;
}

static npy_double
DOUBLE_weighted_@SQ@euclidean_distance(const char *u, const char *v,
                                       const char *w, npy_intp dim,
                                       npy_intp u_str, npy_intp v_str,
                                       npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta =  *(npy_double *)w * (*(npy_double *)u -
                                                *(npy_double *)v);
        dist += delta * delta;
    }
    #if @do_sqrt@
        dist = sqrt(dist);
    #endif
    return dist;
}

/**end repeat**/

/**begin repeat
 * #TYPE = BOOL,INTP,DOUBLE#
 * #type = npy_bool,npy_intp,npy_double#
 * #isbool = 1,0,0#
 */

 
/* The Hamming distance.
 *
 * The formula used in scipy.spatial.distance is normalized by the length
 * of the vector. Kept it unchanged for backwards compatibility.
 *
 * For boolean data, the Hamming distance as defined here is equivalent to
 * one minus the definitions in [Deza 2013] and [Choi 2010] of the
 * Rand, or Sokal-Michener simple matching similarity. No need to implement
 * any of those separately.
 *
 * The definition of scipy.spatial.distance.sokalmichener is, by the way,
 * equivalent to scipy.spatial.distance.rogerstanimoto, which is wrong.
 */
 
static npy_double
@TYPE@_hamming_distance(const char *u, const char *v, npy_intp dim,
                        npy_intp u_str, npy_intp v_str) {
    npy_intp j, dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @isbool@
            dist += *(npy_bool *)u ^ *(npy_bool *)v;
        #else
            dist += *(@type@ *)u != *(@type@ *)v;
        #endif
    }
    
    return dist / (npy_double) dim;
}

/**end repeat**/

static npy_double
DOUBLE_weighted_hamming_distance(const char *u, const char *v,
                                 const char *w, npy_intp dim,
                                 npy_intp u_str, npy_intp v_str,
                                 npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        if (*(npy_double *)u != *(npy_double *)v) {
            dist += *(npy_double *)w;
        }
    }
    return dist / dim;
}

/**begin repeat
 * #TYPE = BOOL,INTP,DOUBLE#
 * #type = npy_bool,npy_intp,npy_double#
 * #cast2bool = 0,1,1#
 */

/* The Dice or Czekanowsky distance.
 *
 * Definition taken from [Deza 2013], matches [Zhang 2003] and the
 * implementation of DiceDissimilarity in Mathematica 9:
 *.http://reference.wolfram.com/mathematica/ref/DiceDissimilarity.html
 *
 * In [Zhang 2003] it is specified that the return should be zero when
 * both vectors are all zeros, which is what Mathematica does.
 */

static npy_double
@TYPE@_dice_distance(const char *u, const char *v, npy_intp dim,
                      npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0, ntf_plus_nft = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    denom = 2 * ntt  + ntf_plus_nft;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* The Jaccard, Needham, Tanimoto, biotope or similarity distance.
 *
 * Definition taken froom [Deza 2013], matches [Zhang 2003] and the
 * implementation of JaccardDissimilarity in Mathematica 9:
 *.http://reference.wolfram.com/mathematica/ref/JaccardDissimilarity.html
 *
 * In [Zhang 2003] it is specified that the return should be zero when
 * both vectors are all zeros, which is what Mathematica does.
 */

static npy_double
@TYPE@_jaccard_distance(const char *u, const char *v, npy_intp dim,
                        npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntf_plus_nft = 0, ntt = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntf_plus_nft += u_bool ^ v_bool;
        ntt += u_bool & v_bool;
    }
    denom = ntt + ntf_plus_nft;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* A distance based on the Kulczynski similarity 1.
 *
 * In [Deza 2013], [Choi 2010], [Cha 2007] and [Zhang 2003] there is a
 * common definition for the Kulczynski similarity 1. [Deza 2013] and
 * [Cha 2007] specify that, for numerical (non-binary) data, the
 * corresponding distance is the inverse of the similarity, not one
 * minus it. [Choi 2010] makes no attempt to define a distance based
 * on this similarity. But [Zhang 2003] defines, with no supporting
 * citation, the Kulzinsky distance by taking one minus the similarity,
 * and then adding the length of the vectors to both the numerator and
 * denominator of the resulting expression. Apparently it is an attempt
 * to normalize the return to [0, 1]. This is the expression that made
 * it into scipy.spatial.distance. Keeping it for backwards compatibility,
 * although it is probably wrong.
 */
 
static npy_double
@TYPE@_kulsinski_distance(const char *u, const char *v, npy_intp dim,
                          npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0, ntf_plus_nft = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    ntf_plus_nft += dim;
    return (ntf_plus_nft - ntt) / (npy_double) ntf_plus_nft;
}

/* The Rogers-Tanimoto distance.
 *
 * Or more precisely, one minus the Rogers-Tanimoto similarity, according
 * to the definition found in [Deza 2013], [Choi 2010] and [Zhang 2003].
 * [Zhang 2003] is the only one giving an explicit definition of it as
 * a distance, but it matches the implementation in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/RogersTanimotoDissimilarity.html
 */

static npy_double
@TYPE@_rogers_tanimoto_distance(const char *u, const char *v, npy_intp dim,
                                npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntf_plus_nft = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntf_plus_nft += u_bool ^ v_bool;
    }
    return 2 * ntf_plus_nft / (npy_double) (dim + ntf_plus_nft);
}

/* The Russell-Rao distance.
 *
 * Defined as one minus the corresponding similarity, as defined in
 * [Deza 2013], [Choi 2010] and [Zhang 2003]. It also matches the
 * implementation in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/RussellRaoDissimilarity.html
 */

static npy_double
@TYPE@_russell_rao_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
    }
    return (dim - ntt) / (npy_double) dim;
}

/* A distance based on Sokal-Sneath similarity 2
 *
 * The value below matches one minus the Sokal-Sneath similarity 2, as
 * defined in [Deza 2013] and [Choi 2010], and the implementation of
 * SokalSneathDissimilarity in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/SokalSneathDissimilarity.html
 *
 * No description found of what to do if the denominator is zero, i.e. if
 * both vectors are all zeros. Mathematica returns zero, so going with that.
 */

static npy_double
@TYPE@_sokal_sneath_distance(const char *u, const char *v, npy_intp dim,
                             npy_intp u_str, npy_intp v_str)
{
    npy_intp j, ntt = 0, ntf_plus_nft = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    ntf_plus_nft *= 2;
    denom = ntf_plus_nft + ntt;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* 
 * The Yule Q distance.
 *
 * Matches the definition in [Choi 2010], one minus the definition in
 * [Deza 2013] of the corresponding similarity, and the implementation of
 * YuleDissimilarity in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/YuleDissimilarity.html
 *
 * [Zhang 2003] defines it as half the above values, in what I think is an
 * erroneous attempt to normalize the return to [0, 1]. Also in [Zhang 2003]
 * the return is defined to be zero if both vectors are all zeros or all ones,
 * and to be one if one is all zeros and the other all ones. While this makes
 * sense, it doesn't address all the possible sources of an undefined value,
 * e.g. a vector of all ones, and the other half ones, half zeros. Mathematica
 * returns zero for all such cases, so going with that.
 */

static npy_double
@TYPE@_yule_distance(const char *u, const char *v, npy_intp dim,
                     npy_intp u_str, npy_intp v_str)
{
    npy_intp j, ntt = 0, ntf = 0, ntf_plus_nft = 0, nff, nft, ntfxnft, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif

        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
        ntf += u_bool & !v_bool;
    }
    nft = ntf_plus_nft - ntf;
    nff = dim - ntf_plus_nft - ntt;
    ntfxnft = ntf * nft;
    denom = ntt * nff + ntfxnft;
    return  denom == 0? 0 : 2 * ntfxnft / (npy_double) denom;
}

/**end repeat**/ 

/* The great-circle distance on the surface of a sphere
 *
 * The code below uses the spherical law of cosines in most settings, but
 * reverts to the Haversine formula for very close points, for better
 * numerical accuracy.
 *
 * http://en.wikipedia.org/wiki/Great-circle_distance#Formulas
 */

static npy_double
great_circle_distance(npy_double lat1, npy_double lon1,
                      npy_double lat2, npy_double lon2)
{
    npy_double lat_d = lat2 - lat1, lon_d = lon2 - lon1;
    /* The largest relative error with this threshold is ~1.9e-11 */
    if (lat_d > 0.001 && lon_d > 0.001) {
        /* spherical law of cosines */
        return acos(cos(lat_d) - cos(lat1) * cos(lat2) * (1 - cos(lon_d)));
    }
    else {
        /* law of haversines */
        npy_double sin_lat_d_2 = sin(lat_d / 2),
                   sin_lon_d_2 = sin(lon_d / 2);
        return 2 * asin(sqrt(sin_lat_d_2 * sin_lat_d_2 +
                             cos(lat1) * cos(lat2) *
                             sin_lon_d_2 * sin_lon_d_2));
    }
}
static npy_double
DOUBLE_great_circle_distance_radians(const char *u, const char *v,
                                     npy_intp dim,
                                     npy_intp u_str, npy_intp v_str)
{
    if (dim != 2) {
        return d_nan;
    }
    return great_circle_distance(*(npy_double *)u,
                                 *(npy_double *)(u + u_str),
                                 *(npy_double *)v,
                                 *(npy_double *)(v + v_str));
}

static npy_double
DOUBLE_great_circle_distance_degrees(const char *u, const char *v,
                                     npy_intp dim,
                                     npy_intp u_str, npy_intp v_str)
{
    static npy_double deg2rad = NPY_PI / 180;

    if (dim != 2) {
        return d_nan;
    }
    return great_circle_distance(*(npy_double *)u * deg2rad,
                                 *(npy_double *)(u + u_str) * deg2rad,
                                 *(npy_double *)v * deg2rad,
                                 *(npy_double *)(v + v_str) * deg2rad);
}
 
/*
 *****************************************************************************
 **                         AUXILIARY GUFUNC LOOPS                          **
 *****************************************************************************
 */ 

/* Computes (and returns) Euclidean norm over the last dimension of the
 * input.
 */
 
static void
norm_kernel(char **args, npy_intp *dimensions,
            npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_2(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps;
    
    BEGIN_OUTER_LOOP_2(args)
        const char *u = args[0];
        char *norm = args[1];
        npy_intp j;
        npy_double u_norm = 0;
        
        for(j = 0; j < vec_dim; j++,
                                u += u_str) {
            npy_double u_val = *(npy_double *)u;
            u_norm += u_val * u_val;
        }
        *(npy_double *)norm = sqrt(u_norm);
    END_OUTER_LOOP
} /* End of norm_kernel function */
 
/* Computes (and returns) both the mean and the square root of the sum of
 * squared differences from the mean (ssqdm) over the last dimension
 * of the input.
 */
 
static void
mean_ssqdm_kernel(char **args, npy_intp *dimensions,
                  npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u;
        char *mean = args[1], *ssqdm = args[2];
        npy_intp j;
        npy_double u_mean = 0, u_ssqdm = 0;
        
        for (u = args[0],
             j = 0; j < vec_dim; j++,
                                 u  += u_str) {
            u_mean += *(npy_double *)u;
        }
        u_mean /= vec_dim;
        for(u = args[0],
            j = 0; j < vec_dim; j++,
                                u += u_str) {
            npy_double u_val = *(npy_double *)u - u_mean;
            u_ssqdm += u_val * u_val;
        }
        *(npy_double *)mean = u_mean;
        *(npy_double *)ssqdm = sqrt(u_ssqdm);
    END_OUTER_LOOP
} /* End of mean_ssqdm_kernel function */

/* Computes both the mean and the square root of the sum of squared
 * differences from the mean (ssqdm) over the last dimension. Returns
 * the input centered, i.e. subtracts the mean from each entry, and the
 * ssqdm.
 */

static void
center_ssqdm_kernel(char **args, npy_intp *dimensions,
                    npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_i_str = *steps++,
             u_o_str = *steps++;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u_in;
        char *u_out,
             *ssqdm = args[2];
        npy_intp j;
        npy_double u_mean = 0, u_ssqdm = 0;
        
        for (u_in = args[0],
             j = 0; j < vec_dim; j++,
                                 u_in += u_i_str) {
            u_mean += *(npy_double *)u_in;
        }
        u_mean /= vec_dim;
        for(u_in = args[0],
            u_out = args[1],
            j = 0; j < vec_dim; j++,
                                u_in += u_i_str,
                                u_out += u_o_str) {
            npy_double u_val = *(npy_double *)u_in - u_mean;
            u_ssqdm += u_val * u_val;
            *(npy_double *)u_out = u_val;
        }
        *(npy_double *)ssqdm = sqrt(u_ssqdm);
    END_OUTER_LOOP
} /* End of center_ssqdm_kernel function */

/*
 *****************************************************************************
 **                          GENERIC GUFUNC LOOPS                           **
 *****************************************************************************
 */

/* Generic GUFUNC kernel for distances of two arguments */
 
static void
distance_uv_kernel(char **args, npy_intp *dimensions,
                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*, npy_intp,
                                        npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u_vec = args[0],
                   *v_vec = args[1];
        char *dist = args[2];
        
        *(npy_double *)dist = func(u_vec, v_vec, vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments */

static void
pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                            npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_2(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*, npy_intp,
                                        npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_2(args)
        const char *u, *v;
        char *pdist;
        npy_intp j, k;
        
        for (u = args[0],
             pdist = args[1],
             j = 0; j < u_len; j++,
                               u += u_len_str) {
            for (v = u + u_len_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of pairwise_distance_uv_kernel function */

/* Generic GUFUNC kernel for distances of two arguments with one cached
 * value.
 */

static void
cached_distance_uv_kernel(char **args, npy_intp *dimensions,
                          npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_5(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_5(args)
        const char *u_vec = args[0],
                   *v_vec = args[1],
                   *u_cache = args[2],
                   *v_cache = args[3];
        char *dist = args[4];
        
        *(npy_double *)dist = func(u_vec, v_vec, u_cache, v_cache,
                                   vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of cached_distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments with one
 * cached value.
 */

static void
cached_pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             u_cache_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_3(args)
        const char *u, *u_cache,
                   *v, *v_cache;
        char *pdist;
        npy_intp j, k;
        for (u = args[0],
             u_cache = args[1],
             pdist = args[2],
             j = 0; j < u_len; j++,
                               u += u_len_str,
                               u_cache += u_cache_str) {
            for (v = u + u_len_str,
                 v_cache = u_cache + u_cache_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       v_cache += u_cache_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, u_cache, v_cache,
                                            vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of cached_pairwise_distance_uv_kernel function */

/* Generic GUFUNC kernel for distances of two arguments with two cached
 * values.
 */

static void
cached2_distance_uv_kernel(char **args, npy_intp *dimensions,
                          npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_7(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_7(args)
        const char *u_vec = args[0],
                   *v_vec = args[1],
                   *u_cache1 = args[2],
                   *v_cache1 = args[3],
                   *u_cache2 = args[4],
                   *v_cache2 = args[5];
        char *dist = args[6];
        
        *(npy_double *)dist = func(u_vec, v_vec, u_cache1, v_cache1,
                                   u_cache2, v_cache2, vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of cached2_distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments with two
 * cached values.
 */

static void
cached2_pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_4(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             u_cache1_str = *steps++,
             u_cache2_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_4(args)
        const char *u, *u_cache1, *u_cache2,
                   *v, *v_cache1, *v_cache2;
        char *pdist;
        npy_intp j, k;
        for (u = args[0],
             u_cache1 = args[1],
             u_cache2 = args[2],
             pdist = args[3],
             j = 0; j < u_len; j++,
                               u += u_len_str,
                               u_cache1 += u_cache1_str,
                               u_cache2 += u_cache2_str) {
            for (v = u + u_len_str,
                 v_cache1 = u_cache1 + u_cache1_str,
                 v_cache2 = u_cache2 + u_cache2_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       v_cache1 += u_cache1_str,
                                       v_cache2 += u_cache2_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, u_cache1, v_cache1,
                                            u_cache2, v_cache2,
                                            vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of cached2_pairwise_distance_uv_kernel function */

/*
 *****************************************************************************
 **                           GUFUNC REGISTRATION                           **
 *****************************************************************************
 */

static void *null_data[] = {
    (void *) NULL, (void *) NULL, (void *) NULL,
};

/* DOUBLE only distance functions */

static void *bray_curtis_data[] = {
    (void *) &DOUBLE_bray_curtis_distance,
};

static void *canberra_data[] = {
    (void *) &DOUBLE_canberra_distance,
};

static void *chebyshev_data[] = {
    (void *) &DOUBLE_chebyshev_distance,
};

static void *min_chebyshev_data[] = {
    (void *) &DOUBLE_minimum_chebyshev_distance,
};

static void *city_block_data[] = {
    (void *) &DOUBLE_city_block_distance,
};

static void *correlation_data[] = {
    (void *) &DOUBLE_correlation_distance,
};

static void *cached_correlation_data[] = {
    (void *) &DOUBLE_cached_correlation_distance,
};

static void *cosine_data[] = {
    (void *) &DOUBLE_cosine_distance,
};

static void *cached_cosine_data[] = {
    (void *) &DOUBLE_cached_cosine_distance,
};

static void *euclidean_data[] = {
    (void *) &DOUBLE_euclidean_distance,
};

static void *sqeuclidean_data[] = {
    (void *) &DOUBLE_sqeuclidean_distance,
};

static void *greatcircle_degrees_data[] = {
    (void *) &DOUBLE_great_circle_distance_degrees,
};

/* BOOL, INTP and DOUBLE distance functions */

static void *hamming_data[] = {
    (void *) &BOOL_hamming_distance,
    (void *) &INTP_hamming_distance,
    (void *) &DOUBLE_hamming_distance,
};

static void *dice_data[] = {
    (void *) &BOOL_dice_distance,
    (void *) &INTP_dice_distance,
    (void *) &DOUBLE_dice_distance,
};

static void *jaccard_data[] = {
    (void *) &BOOL_jaccard_distance,
    (void *) &INTP_jaccard_distance,
    (void *) &DOUBLE_jaccard_distance,
};

static void *kulsinski_data[] = {
    (void *) &BOOL_kulsinski_distance,
    (void *) &INTP_kulsinski_distance,
    (void *) &DOUBLE_kulsinski_distance,
};

static void *rogers_tanimoto_data[] = {
    (void *) &BOOL_rogers_tanimoto_distance,
    (void *) &INTP_rogers_tanimoto_distance,
    (void *) &DOUBLE_rogers_tanimoto_distance,
};

static void *russell_rao_data[] = {
    (void *) &BOOL_russell_rao_distance,
    (void *) &INTP_russell_rao_distance,
    (void *) &DOUBLE_russell_rao_distance,
};

static void *sokal_sneath_data[] = {
    (void *) &BOOL_sokal_sneath_distance,
    (void *) &INTP_sokal_sneath_distance,
    (void *) &DOUBLE_sokal_sneath_distance,
};

static void *yule_data[] = {
    (void *) &BOOL_yule_distance,
    (void *) &INTP_yule_distance,
    (void *) &DOUBLE_yule_distance,
};

PyUFuncGenericFunction norm_kernel_funcs[] = {
    &norm_kernel,
};

PyUFuncGenericFunction mean_ssqdm_kernel_funcs[] = {
    &mean_ssqdm_kernel,
};

PyUFuncGenericFunction center_ssqdm_kernel_funcs[] = {
    &center_ssqdm_kernel,
};

PyUFuncGenericFunction distance_uv_kernel_funcs[] = {
    &distance_uv_kernel,
    &distance_uv_kernel,
    &distance_uv_kernel,
};

PyUFuncGenericFunction pairwise_distance_uv_kernel_funcs[] = {
    &pairwise_distance_uv_kernel,
    &pairwise_distance_uv_kernel,
    &pairwise_distance_uv_kernel,
};

PyUFuncGenericFunction cached_distance_uv_kernel_funcs[] = {
    &cached_distance_uv_kernel,
    &cached_distance_uv_kernel,
    &cached_distance_uv_kernel,
};

PyUFuncGenericFunction cached_pairwise_distance_uv_kernel_funcs[] = {
    &cached_pairwise_distance_uv_kernel,
    &cached_pairwise_distance_uv_kernel,
    &cached_pairwise_distance_uv_kernel,
};

PyUFuncGenericFunction cached2_distance_uv_kernel_funcs[] = {
    &cached2_distance_uv_kernel,
    &cached2_distance_uv_kernel,
    &cached2_distance_uv_kernel,
};

PyUFuncGenericFunction cached2_pairwise_distance_uv_kernel_funcs[] = {
    &cached2_pairwise_distance_uv_kernel,
    &cached2_pairwise_distance_uv_kernel,
    &cached2_pairwise_distance_uv_kernel,
};

static char all_DOUBLE_types[] = {
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_TYPE_DOUBLE_types[] = {
    NPY_BOOL, NPY_BOOL, NPY_DOUBLE,
    NPY_INTP, NPY_INTP, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_DOUBLE_types[] = {
    NPY_BOOL, NPY_DOUBLE,
    NPY_INTP, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_TYPE_DOUBLE_DOUBLE_types[] = {
    NPY_BOOL, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE,
    NPY_INTP, NPY_INTP, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_DOUBLE_DOUBLE_types[] = {
    NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE,
    NPY_INTP, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

 typedef struct gufunc_descriptor_struct {
    char *name;
    char *signature;
    char *doc;
    int ntypes;
    int nin;
    int nout;
    PyUFuncGenericFunction *funcs;
    char *types;
    void *data;
} GUFUNC_DESCRIPTOR_t;

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    {
        "_norm",
        "(d)->()",
        "Euclidean norm on the last dimension, broadcast on the rest.\n"
        "    (d)->()\n",
        1, 1, 1,
        norm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_mean_ssqdm",
        "(d)->(),()",
        "Mean and square root of the sum of squared differences from "
        "the mean on the last dimension, broadcast on the rest.\n"
        "    (d)->(),()\n",
        1, 1, 2,
        mean_ssqdm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_center_ssqdm",
        "(d)->(d),()",
        "Centered input (mean subtracted) and square root of the sum of "
        "squared differences from the mean on the last dimension, "
        "broadcast on the rest.\n"
        "    (d)->(d),()\n",
        1, 1, 2,
        center_ssqdm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_braycurtis",
        "(d),(d)->()",
        "Bray-Curtis distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        bray_curtis_data
    },
    {
        "_pairwise_braycurtis",
        "(n,d)->(p)",
        "Bray-Curtis distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        bray_curtis_data
    },
    {
        "_canberra",
        "(d),(d)->()",
        "Canberra distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        canberra_data
    },
    {
        "_pairwise_canberra",
        "(n,d)->(p)",
        "Canberra distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        canberra_data
    },
    {
        "_chebyshev",
        "(d),(d)->()",
        "Chebyshev distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        chebyshev_data
    },
    {
        "_pairwise_chebyshev",
        "(n,d)->(p)",
        "Chebyshev distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        chebyshev_data
    },
    {
        "_min_chebyshev",
        "(d),(d)->()",
        "Minimum Chebyshev distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        min_chebyshev_data
    },
    {
        "_pairwise_min_chebyshev",
        "(n,d)->(p)",
        "Minimum Chebyshev distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        min_chebyshev_data
    },
    {
        "_cityblock",
        "(d),(d)->()",
        "City Block (Manhattan) distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        city_block_data
    },
    {
        "_pairwise_cityblock",
        "(n,d)->(p)",
        "City Block (Manhattan) distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        city_block_data
    },
    {
        "_correlation",
        "(d),(d)->()",
        "Correlation distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        correlation_data
    },
    {
        "_pairwise_correlation",
        "(n,d)->(p)",
        "Correlation distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        correlation_data
    },
    {
        "_cached_correlation",
        "(d),(d),(),(),(),()->()",
        "Buffered correlation distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d),(),(),(),()->()\n",
        1, 6, 1,
        cached2_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_correlation_data
    },
    {
        "_cached_pairwise_correlation",
        "(n,d),(n),(n)->(p)",
        "Cached correlation distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d),(n),(n)->(p)\n",
        1, 3, 1,
        cached2_pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_correlation_data
    },
    {
        "_cosine",
        "(d),(d)->()",
        "Cosine distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cosine_data
    },
    {
        "_pairwise_cosine",
        "(n,d)->(p)",
        "Cosine distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cosine_data
    },
    {
        "_cached_cosine",
        "(d),(d),(),()->()",
        "Cosine distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d),(),()->()\n",
        1, 4, 1,
        cached_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_cosine_data
    },
    {
        "_cached_pairwise_cosine",
        "(n,d),(n)->(p)",
        "Cosine distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d),(n)->(p)\n",
        1, 2, 1,
        cached_pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_cosine_data
    },
    {
        "_euclidean",
        "(d),(d)->()",
        "Euclidean distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        euclidean_data
    },
    {
        "_pairwise_euclidean",
        "(n,d)->(p)",
        "Euclidean distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        euclidean_data
    },
    {
        "_sqeuclidean",
        "(d),(d)->()",
        "Squared Euclidean distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        sqeuclidean_data
    },
    {
        "_pairwise_sqeuclidean",
        "(n,d)->(p)",
        "Squared Euclidean distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        sqeuclidean_data
    },
    {
        "_dice",
        "(d),(d)->()",
        "Dice distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        dice_data
    },
    {
        "_pairwise_dice",
        "(n,d)->(p)",
        "Dice distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        dice_data
    },
    {
        "_hamming",
        "(d),(d)->()",
        "Hamming distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        hamming_data
    },
    {
        "_pairwise_hamming",
        "(n,d)->(p)",
        "Hamming distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        hamming_data
    },
    {
        "_jaccard",
        "(d),(d)->()",
        "Jaccard distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        jaccard_data
    },
    {
        "_pairwise_jaccard",
        "(n,d)->(p)",
        "Jaccard distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        jaccard_data
    },
    {
        "_kulsinski",
        "(d),(d)->()",
        "Kulsinski distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        kulsinski_data
    },
    {
        "_pairwise_kulsinski",
        "(n,d)->(p)",
        "Kulsinski distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        kulsinski_data
    },
    {
        "_rogerstanimoto",
        "(d),(d)->()",
        "Rogers-Tanimoto distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        rogers_tanimoto_data
    },
    {
        "_pairwise_rogerstanimoto",
        "(n,d)->(p)",
        "Rogers-Tanimoto distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        rogers_tanimoto_data
    },
    {
        "_russellrao",
        "(d),(d)->()",
        "Russell-Rao distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        russell_rao_data
    },
    {
        "_pairwise_russellrao",
        "(n,d)->(p)",
        "Russell-Rao distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        russell_rao_data
    },
    {
        "_sokalsneath",
        "(d),(d)->()",
        "Sokal-Sneath distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        sokal_sneath_data
    },
    {
        "_pairwise_sokalsneath",
        "(n,d)->(p)",
        "Sokal-Sneath distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        sokal_sneath_data
    },
    {
        "_yule",
        "(d),(d)->()",
        "Yule distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        yule_data
    },
    {
        "_pairwise_yule",
        "(n,d)->(p)",
        "Yule distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        yule_data
    },
    {
        "_greatcircle",
        "(d),(d)->()",
        "Great-circle distance on a sphere on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        greatcircle_degrees_data
    },
    {
        "_pairwise_greatcircle",
        "(n,d)->(p)",
        "Great-circle distance on a sphere on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        greatcircle_degrees_data
    },
}; /* End of gufunc_descriptors declaration */

static void
addUfuncs(PyObject *dictionary) {
    PyObject *f;
    int i;
    const int gufunc_count = sizeof(gufunc_descriptors) /
                             sizeof(gufunc_descriptors[0]);
    for (i=0; i < gufunc_count; i++) {
        GUFUNC_DESCRIPTOR_t* d = &gufunc_descriptors[i];
        f = PyUFunc_FromFuncAndDataAndSignature(d->funcs,
                                                d->data,
                                                d->types,
                                                d->ntypes,
                                                d->nin,
                                                d->nout,
                                                PyUFunc_None,
                                                d->name,
                                                d->doc,
                                                0,
                                                d->signature);
        PyDict_SetItemString(dictionary, d->name, f);
    }
}

/*
 *****************************************************************************
 **                          MODULE INITIALIZATION                          **
 *****************************************************************************
 */
 
static PyMethodDef module_methods[] = {
    {NULL, NULL, 0, NULL},        /* Sentinel */
};

#if defined(NPY_PY3K)
static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        NUMPYPE_MODULE_NAME,
        NULL,
        -1,
        module_methods,
        NULL,
        NULL,
        NULL,
        NULL
};
#endif

#if defined(NPY_PY3K)
    #define RETVAL m
    PyObject*
    APPEND_MODULE(PyInit_) (void)/**PyInit__numpype(void)*/
#else
    #define RETVAL
    PyMODINIT_FUNC
    APPEND_MODULE(init) (void)
#endif
{
    PyObject *m;
    PyObject *d;
    PyObject *version;

    init_constants();
#if defined(NPY_PY3K)
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule(MODULE_NAME_STR, module_methods);
#endif
    if (m == NULL)
        return RETVAL;

    import_array();
    import_ufunc();

    d = PyModule_GetDict(m);

    version = PyString_FromString(VERSION_STR);
    PyDict_SetItemString(d, "__version__", version);
    Py_DECREF(version);

    /* Load the ufunc operators into the module's namespace */
    addUfuncs(d);

    if (PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load " MODULE_NAME_STR " module.");
    }

    return RETVAL;
}
#include "Python.h"
#include "numpy/ndarraytypes.h"
#include "numpy/ufuncobject.h"
#include "numpy/npy_3kcompat.h"
#include "numpy/npy_math.h"
#include<stdlib.h>
#include<stdio.h>
#include <math.h>

/* The C preprocessor requires these double indirection levels to allow
 * stringification and concatenation of a macro value, i.e. MODULE_NAME
 */
#define EXPAND_AND_QUOTE(str) QUOTE(str)
#define QUOTE(str) #str
#define PASTE(a, b) a ## b
#define JOIN(a, b) PASTE(a, b)

#define MODULE_NAME _umath_distance /* edit this line with the module name */
#define VERSION 0.1

#define MODULE_NAME_STR EXPAND_AND_QUOTE(MODULE_NAME)
#define VERSION_STR EXPAND_AND_QUOTE(VERSION)
#define APPEND_MODULE(name) JOIN(name, MODULE_NAME)
#define PREPEND_MODULE(name) JOIN(MODULE_NAME, name)

/*
 *****************************************************************************
 **                        GUFUNC OUTER LOOP MACROS                         **
 *****************************************************************************
 */
 
#define INIT_OUTER_LOOP_1(dimensions, steps) \
    npy_intp _loop_len = *dimensions++; \
    npy_intp _n; \
    npy_intp _s0 = *steps++;

#define INIT_OUTER_LOOP_2(dimensions, steps) \
    INIT_OUTER_LOOP_1(dimensions, steps) \
    npy_intp _s1 = *steps++;

#define INIT_OUTER_LOOP_3(dimensions, steps) \
    INIT_OUTER_LOOP_2(dimensions, steps) \
    npy_intp _s2 = *steps++;

#define INIT_OUTER_LOOP_4(dimensions, steps) \
    INIT_OUTER_LOOP_3(dimensions, steps) \
    npy_intp _s3 = *steps++;

#define INIT_OUTER_LOOP_5(dimensions, steps) \
    INIT_OUTER_LOOP_4(dimensions, steps) \
    npy_intp _s4 = *steps++;

#define INIT_OUTER_LOOP_6(dimensions, steps) \
    INIT_OUTER_LOOP_5(dimensions, steps) \
    npy_intp _s5 = *steps++;

#define INIT_OUTER_LOOP_7(dimensions, steps) \
    INIT_OUTER_LOOP_6(dimensions, steps) \
    npy_intp _s6 = *steps++;

#define INIT_OUTER_LOOP_8(dimensions, steps) \
    INIT_OUTER_LOOP_7(dimensions, steps) \
    npy_intp s7 = *steps++;

#define BEGIN_OUTER_LOOP_1(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0) {

#define BEGIN_OUTER_LOOP_2(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1) {

#define BEGIN_OUTER_LOOP_3(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2) {

#define BEGIN_OUTER_LOOP_4(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3) {

#define BEGIN_OUTER_LOOP_5(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4) {

#define BEGIN_OUTER_LOOP_6(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5) {

#define BEGIN_OUTER_LOOP_7(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5, \
                                args[6] += _s6) {

#define BEGIN_OUTER_LOOP_8(args) \
    for (_n = 0; _n < _loop_len; _n++, \
                                args[0] += _s0, \
                                args[1] += _s1, \
                                args[2] += _s2, \
                                args[3] += _s3, \
                                args[4] += _s4, \
                                args[5] += _s5, \
                                args[6] += _s6, \
                                args[7] += _s7) {

#define END_OUTER_LOOP  }

/*
 *****************************************************************************
 **                             SOME CONSTANTS                              **
 *****************************************************************************
 */
 
 static npy_double d_nan;
 static npy_double d_inf;
 static npy_double d_ninf;
 
 static void init_constants(void)
 {
    /* It seems that NPY_INFINITY and NPY_NAN macros can't be used as
       initializers, or so says numpy.linalg.umath_linalg.c.src */
    d_nan = NPY_NAN;
    d_inf = NPY_INFINITY;
    d_ninf = -NPY_INFINITY;
}
    
/*
 *****************************************************************************
 **                          DISTANCE FUNCTIONS                            **
 *****************************************************************************
 */
 
/* The definitions of some distance functions are a little unclear. The
 * following references are cited in the comments in the code below:
 *
 * [Deza 2013]
 * Deza, M. M., & Deza, E. (2013). Encyclopedia of Distances. Springer. 
 * 
 * [Zhang 2003]
 * Zhang, B., & Srihari, S. N. (2003, January). Binary vector dissimilarity
 * measures for handwriting identification. In Electronic Imaging 2003
 * (pp. 28-38). International Society for Optics and Photonics.
 * http://www.cedar.buffalo.edu/papers/articles/SPIE03_hwidiss.pdf
 * http://www.cedar.buffalo.edu/~srihari/papers/DRR03-Binary.pdf
 *
 * [Choi 2010]
 * Choi, S. S., Cha, S. H., & Tappert, C. (2010). A survey of binary
 * similarity and distance measures. Journal of Systemics, Cybernetics
 * and Informatics, 8(1), 43-48.
 * http://www.iiisci.org/Journal/CV$/sci/pdfs/GS315JG.pdf
 * http://www.iiisci.org/Journal/SCI/FullText.asp?var=&id=GS315JG
 *
 * [Cha 2007]
 * Cha, S. H. (2007). Comprehensive survey on distance/similarity measures
 * between probability density functions. City, 1(2), 1.
 * http://citeseerx.ist.psu.edu/viewdoc/download?rep=rep1&type=pdf&doi=10.1.1.154.8446
 *
 * [McCune 2002]
 * McCune, B., Grace, J. B., & Urban, D. L. (2002). Analysis of ecological
 * communities (Vol. 28). Gleneden Beach, Oregon: MjM software design.
 * http://www.umass.edu/landeco/teaching/multivariate/readings/McCune.and.Grace.2002.chapter6.pdf
 * http://people.oregonstate.edu/~mccuneb/bookpowerpoints.htm
 *
 * [Faith 1987]
 * Faith, D. P., Minchin, P. R., & Belbin, L. (1987). Compositional
 * dissimilarity as a robust measure of ecological distance. Vegetatio,
 * 69(1-3), 57-68.
 * http://www.ohio.edu/plantbio/staff/mccarthy/multivariate/FaithEtAl1987.pdf
 *
 * [Lance 1966]
 * Lance, G. N., & Williams, W. T. (1966). Computer programs for hierarchical
 * polythetic classification (similarity analyses). The Computer Journal,
 * 9(1), 60-64.
 * http://comjnl.oxfordjournals.org/content/9/1/60.full.pdf
 *
 * [Lance 1968]
 * Lance, G. N., & Williams, W. T. (1968). Note on a New InformationStatistic
 * Classificatory Program. The Computer Journal, 11(2), 195-195.
 * http://comjnl.oxfordjournals.org/content/9/4/381.full.pdf
 */

/* The Bray-Curtis or Sorensen distance.
 *
 * The definition in [Deza 2013] and [Cha 2007] does not include taking
 * the absolute value of the denominator, which is also how it is described
 * in [Lance 1966] as the non-metric coefficient, probably because it is
 * only defined for non-negative vectors. Kept it unchanged for backwards
 * compatibility.
 *
 * [Lance 1966] specifies that the return should be zero if the denominator
 * is zero, but BrayCurtisDistance in Mathematica 9 returns positive infinity
 * whenever that happens regardless of the value of the denominator. The code
 * below follows [Lance 1966] if both vectors are all zeros, and Mathematica
 * if the denominator is zero but the numerator is not.
 */

static npy_double
DOUBLE_bray_curtis_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double num = 0, denom = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u,
                   v_val = *(npy_double *)v;
        num += fabs(u_val - v_val);
        denom += fabs(u_val + v_val);
    }
    return denom == 0 ? (num == 0 ? 0 : d_inf) : num / denom;
}

/* The Canberra distance.
 *
 * Definition taken from [Deza 2013]. In [Cha 2007] there is no absolute
 * value for the denominator terms, probably because it only considers
 * non-negative vectors. Wikipedia does include them. Keeping them for
 * backwards compatibility.
 *
 * Skipping terms with zero denominator is specified in [Lance 1968] and
 * is consistent with the handling of CanberraDistance in Mathematica 9.
 */

static npy_double
DOUBLE_canberra_distance(const char *u, const char *v, npy_intp dim,
                         npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = fabs(*(npy_double *)u),
                   v_val = fabs(*(npy_double *)v),
                   num = fabs(u_val - v_val),
                   denom = fabs(u_val) + fabs(v_val);
        if (denom != 0) {
            dist += num / denom;
        }
    }
    return dist;
}

/* The Chebyshev distance */

static npy_double
DOUBLE_chebyshev_distance(const char *u, const char *v, npy_intp dim,
                          npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = fabs(*(npy_double *)u - *(npy_double *)v);
        if (delta > dist) {
            dist = delta;
        }
    }
    return dist;
}

static npy_double
DOUBLE_weighted_chebyshev_distance(const char *u, const char *v,
                                   const char *w, npy_intp dim,
                                   npy_intp u_str, npy_intp v_str,
                                   npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta = *(npy_double *)w * fabs(*(npy_double *)u -
                                                   *(npy_double *)v);
        if (delta > dist) {
            dist = delta;
        }
    }
    return dist;
}


static npy_double
DOUBLE_minimum_chebyshev_distance(const char *u, const char *v, npy_intp dim,
                                  npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = fabs(*(npy_double *)u - *(npy_double *)v);
    
    for (u += u_str,
         v += v_str,
         j = 1; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = fabs(*(npy_double *)u - *(npy_double *)v);
        if (delta < dist) {
            dist = delta;
        }
        if (dist == 0) {
            break;
        }
    }
    return dist;
}

static npy_double
DOUBLE_weighted_minimum_chebyshev_distance(const char *u, const char *v,
                                           const char *w, npy_intp dim,
                                           npy_intp u_str, npy_intp v_str,
                                           npy_intp w_str) {
    npy_intp j;
    npy_double dist = *(npy_double *)w * fabs(*(npy_double *)u -
                                              *(npy_double *)v);
    for (u += u_str,
         v += v_str,
         w += w_str,
         j = 1; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta = *(npy_double *)w * fabs(*(npy_double *)u -
                                                   *(npy_double *)v);
        if (delta < dist) {
            dist = delta;
        }
        if (dist == 0) {
            break;
        }
    }
    return dist;
}

/* The City Block or Manhattan distance */

static npy_double
DOUBLE_city_block_distance(const char *u, const char *v, npy_intp dim,
                           npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        dist += fabs(*(npy_double *)u - *(npy_double *)v);
    }
    return dist;
}

static npy_double
DOUBLE_weighted_city_block_distance(const char *u, const char *v,
                                    const char *w, npy_intp dim,
                                    npy_intp u_str, npy_intp v_str,
                                    npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        dist += *(npy_double *)w * fabs(*(npy_double *)u - *(npy_double *)v);
    }
    return dist;
}

/* The correlation distance
 * 
 * Haven't found any reference specifying what to return whenever the
 * denominator comes out to zero. The code follows what Mathematica 9
 * does in CorrelationDistance, which returns zero distance for all such
 * cases. 
 */

static npy_double
DOUBLE_correlation_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double u2 = 0, v2 = 0, uv = 0,
               u_mean = 0, v_mean = 0, denom;
    const char *u_ptr, *v_ptr;
    for (u_ptr = u,
         v_ptr = v,
         j = 0; j < dim; j++,
                         u_ptr += u_str,
                         v_ptr += v_str) {
        u_mean += *(npy_double *)u_ptr;
        v_mean += *(npy_double *)v_ptr;
    }
    u_mean /= dim;
    v_mean /= dim;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u - u_mean,
                   v_val = *(npy_double *)v - v_mean;
        u2 += u_val * u_val;
        v2 += v_val * v_val;
        uv += u_val * v_val;
    }
    denom = u2 * v2;
    return denom == 0 ? 0 : 1 - uv / sqrt(denom);
}

static npy_double
DOUBLE_cached_correlation_distance(const char *u, const char *v,
                                   const char *u_mean, const char *v_mean,
                                   const char *u_ssqdm, const char *v_ssqdm,
                                   npy_intp dim,
                                   npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double uv = 0,
               u_mean_val = *(npy_double *)u_mean,
               v_mean_val = *(npy_double *)v_mean,
               denom = *(npy_double *)u_ssqdm * *(npy_double *)v_ssqdm;
    if (denom == 0) {
        return 0;
    }
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u - u_mean_val,
                   v_val = *(npy_double *)v - v_mean_val;
       uv += (*(npy_double *)u - u_mean_val) *
             (*(npy_double *)v - v_mean_val);
    }
    return 1 - uv / denom;
}

/* The cosine distance
 * 
 * Haven't found any reference specifying what to return whenever the
 * denominator comes out to zero. The code follows what Mathematica 9
 * does in CosineDistance, which returns zero distance for all such
 * cases. This is not consistent with what is done, for instance, in
 * sklearn.metrics.pairwise.cosine_similarity, which returns zero for
 * the similarity, not the distance
 */
static npy_double
DOUBLE_cosine_distance(const char *u, const char *v, npy_intp dim,
                       npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double u2 = 0, v2 = 0, uv = 0, denom;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double u_val = *(npy_double *)u,
                   v_val = *(npy_double *)v;
        u2 += u_val * u_val;
        v2 += v_val * v_val;
        uv += u_val * v_val;
    }
    denom = u2 * v2;
    return denom == 0 ? 0 : 1 - uv / sqrt(denom);
}

static npy_double
DOUBLE_cached_cosine_distance(const char *u, const char *v,
                              const char *u_norm, const char *v_norm,
                              npy_intp dim,
                              npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double uv = 0,
               denom = *(npy_double *)u_norm * *(npy_double *)v_norm;
    if (denom == 0) {
        return 0;
    }
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        uv += *(npy_double *)u * *(npy_double *)v;
    }
    return 1 - uv / denom;
}

/* The Euclidean and squared Euclidean distances */

/**begin repeat
 * #SQ = sq,#
 * #do_sqrt = 0,1#
 */
 
static npy_double
DOUBLE_@SQ@euclidean_distance(const char *u, const char *v, npy_intp dim,
                              npy_intp u_str, npy_intp v_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        npy_double delta = *(npy_double *)u - *(npy_double *)v;
        dist += delta * delta;
    }
    #if @do_sqrt@
        dist = sqrt(dist);
    #endif
    return dist;
}

static npy_double
DOUBLE_weighted_@SQ@euclidean_distance(const char *u, const char *v,
                                       const char *w, npy_intp dim,
                                       npy_intp u_str, npy_intp v_str,
                                       npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        npy_double delta =  *(npy_double *)w * (*(npy_double *)u -
                                                *(npy_double *)v);
        dist += delta * delta;
    }
    #if @do_sqrt@
        dist = sqrt(dist);
    #endif
    return dist;
}

/**end repeat**/

/**begin repeat
 * #TYPE = BOOL,INTP,DOUBLE#
 * #type = npy_bool,npy_intp,npy_double#
 * #isbool = 1,0,0#
 */

 
/* The Hamming distance.
 *
 * The formula used in scipy.spatial.distance is normalized by the length
 * of the vector. Kept it unchanged for backwards compatibility.
 *
 * For boolean data, the Hamming distance as defined here is equivalent to
 * one minus the definitions in [Deza 2013] and [Choi 2010] of the
 * Rand, or Sokal-Michener simple matching similarity. No need to implement
 * any of those separately.
 *
 * The definition of scipy.spatial.distance.sokalmichener is, by the way,
 * equivalent to scipy.spatial.distance.rogerstanimoto, which is wrong.
 */
 
static npy_double
@TYPE@_hamming_distance(const char *u, const char *v, npy_intp dim,
                        npy_intp u_str, npy_intp v_str) {
    npy_intp j, dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @isbool@
            dist += *(npy_bool *)u ^ *(npy_bool *)v;
        #else
            dist += *(@type@ *)u != *(@type@ *)v;
        #endif
    }
    
    return dist / (npy_double) dim;
}

/**end repeat**/

static npy_double
DOUBLE_weighted_hamming_distance(const char *u, const char *v,
                                 const char *w, npy_intp dim,
                                 npy_intp u_str, npy_intp v_str,
                                 npy_intp w_str) {
    npy_intp j;
    npy_double dist = 0;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str,
                         w += w_str) {
        if (*(npy_double *)u != *(npy_double *)v) {
            dist += *(npy_double *)w;
        }
    }
    return dist / dim;
}

/**begin repeat
 * #TYPE = BOOL,INTP,DOUBLE#
 * #type = npy_bool,npy_intp,npy_double#
 * #cast2bool = 0,1,1#
 */

/* The Dice or Czekanowsky distance.
 *
 * Definition taken from [Deza 2013], matches [Zhang 2003] and the
 * implementation of DiceDissimilarity in Mathematica 9:
 *.http://reference.wolfram.com/mathematica/ref/DiceDissimilarity.html
 *
 * In [Zhang 2003] it is specified that the return should be zero when
 * both vectors are all zeros, which is what Mathematica does.
 */

static npy_double
@TYPE@_dice_distance(const char *u, const char *v, npy_intp dim,
                      npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0, ntf_plus_nft = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    denom = 2 * ntt  + ntf_plus_nft;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* The Jaccard, Needham, Tanimoto, biotope or similarity distance.
 *
 * Definition taken froom [Deza 2013], matches [Zhang 2003] and the
 * implementation of JaccardDissimilarity in Mathematica 9:
 *.http://reference.wolfram.com/mathematica/ref/JaccardDissimilarity.html
 *
 * In [Zhang 2003] it is specified that the return should be zero when
 * both vectors are all zeros, which is what Mathematica does.
 */

static npy_double
@TYPE@_jaccard_distance(const char *u, const char *v, npy_intp dim,
                        npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntf_plus_nft = 0, ntt = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntf_plus_nft += u_bool ^ v_bool;
        ntt += u_bool & v_bool;
    }
    denom = ntt + ntf_plus_nft;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* A distance based on the Kulczynski similarity 1.
 *
 * In [Deza 2013], [Choi 2010], [Cha 2007] and [Zhang 2003] there is a
 * common definition for the Kulczynski similarity 1. [Deza 2013] and
 * [Cha 2007] specify that, for numerical (non-binary) data, the
 * corresponding distance is the inverse of the similarity, not one
 * minus it. [Choi 2010] makes no attempt to define a distance based
 * on this similarity. But [Zhang 2003] defines, with no supporting
 * citation, the Kulzinsky distance by taking one minus the similarity,
 * and then adding the length of the vectors to both the numerator and
 * denominator of the resulting expression. Apparently it is an attempt
 * to normalize the return to [0, 1]. This is the expression that made
 * it into scipy.spatial.distance. Keeping it for backwards compatibility,
 * although it is probably wrong.
 */
 
static npy_double
@TYPE@_kulsinski_distance(const char *u, const char *v, npy_intp dim,
                          npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0, ntf_plus_nft = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    ntf_plus_nft += dim;
    return (ntf_plus_nft - ntt) / (npy_double) ntf_plus_nft;
}

/* The Rogers-Tanimoto distance.
 *
 * Or more precisely, one minus the Rogers-Tanimoto similarity, according
 * to the definition found in [Deza 2013], [Choi 2010] and [Zhang 2003].
 * [Zhang 2003] is the only one giving an explicit definition of it as
 * a distance, but it matches the implementation in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/RogersTanimotoDissimilarity.html
 */

static npy_double
@TYPE@_rogers_tanimoto_distance(const char *u, const char *v, npy_intp dim,
                                npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntf_plus_nft = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntf_plus_nft += u_bool ^ v_bool;
    }
    return 2 * ntf_plus_nft / (npy_double) (dim + ntf_plus_nft);
}

/* The Russell-Rao distance.
 *
 * Defined as one minus the corresponding similarity, as defined in
 * [Deza 2013], [Choi 2010] and [Zhang 2003]. It also matches the
 * implementation in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/RussellRaoDissimilarity.html
 */

static npy_double
@TYPE@_russell_rao_distance(const char *u, const char *v, npy_intp dim,
                            npy_intp u_str, npy_intp v_str) {
    npy_intp j, ntt = 0;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
    }
    return (dim - ntt) / (npy_double) dim;
}

/* A distance based on Sokal-Sneath similarity 2
 *
 * The value below matches one minus the Sokal-Sneath similarity 2, as
 * defined in [Deza 2013] and [Choi 2010], and the implementation of
 * SokalSneathDissimilarity in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/SokalSneathDissimilarity.html
 *
 * No description found of what to do if the denominator is zero, i.e. if
 * both vectors are all zeros. Mathematica returns zero, so going with that.
 */

static npy_double
@TYPE@_sokal_sneath_distance(const char *u, const char *v, npy_intp dim,
                             npy_intp u_str, npy_intp v_str)
{
    npy_intp j, ntt = 0, ntf_plus_nft = 0, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif
        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
    }
    ntf_plus_nft *= 2;
    denom = ntf_plus_nft + ntt;
    return denom == 0 ? 0 : ntf_plus_nft / (npy_double) denom;
}

/* 
 * The Yule Q distance.
 *
 * Matches the definition in [Choi 2010], one minus the definition in
 * [Deza 2013] of the corresponding similarity, and the implementation of
 * YuleDissimilarity in Mathematica 9:
 * http://reference.wolfram.com/mathematica/ref/YuleDissimilarity.html
 *
 * [Zhang 2003] defines it as half the above values, in what I think is an
 * erroneous attempt to normalize the return to [0, 1]. Also in [Zhang 2003]
 * the return is defined to be zero if both vectors are all zeros or all ones,
 * and to be one if one is all zeros and the other all ones. While this makes
 * sense, it doesn't address all the possible sources of an undefined value,
 * e.g. a vector of all ones, and the other half ones, half zeros. Mathematica
 * returns zero for all such cases, so going with that.
 */

static npy_double
@TYPE@_yule_distance(const char *u, const char *v, npy_intp dim,
                     npy_intp u_str, npy_intp v_str)
{
    npy_intp j, ntt = 0, ntf = 0, ntf_plus_nft = 0, nff, nft, ntfxnft, denom;
    npy_bool u_bool, v_bool;
    for (j = 0; j < dim; j++,
                         u += u_str,
                         v += v_str) {
        #if @cast2bool@
            u_bool = *(@type@ *)u != 0;
            v_bool = *(@type@ *)v != 0;
        #else
            u_bool = *(npy_bool *)u;
            v_bool = *(npy_bool *)v;
        #endif

        ntt += u_bool & v_bool;
        ntf_plus_nft += u_bool ^ v_bool;
        ntf += u_bool & !v_bool;
    }
    nft = ntf_plus_nft - ntf;
    nff = dim - ntf_plus_nft - ntt;
    ntfxnft = ntf * nft;
    denom = ntt * nff + ntfxnft;
    return  denom == 0? 0 : 2 * ntfxnft / (npy_double) denom;
}

/**end repeat**/ 

/* The great-circle distance on the surface of a sphere
 *
 * The code below uses the spherical law of cosines in most settings, but
 * reverts to the Haversine formula for very close points, for better
 * numerical accuracy.
 *
 * http://en.wikipedia.org/wiki/Great-circle_distance#Formulas
 */

static npy_double
great_circle_distance(npy_double lat1, npy_double lon1,
                      npy_double lat2, npy_double lon2)
{
    npy_double lat_d = lat2 - lat1, lon_d = lon2 - lon1;
    /* The largest relative error with this threshold is ~1.9e-11 */
    if (lat_d > 0.001 && lon_d > 0.001) {
        /* spherical law of cosines */
        return acos(cos(lat_d) - cos(lat1) * cos(lat2) * (1 - cos(lon_d)));
    }
    else {
        /* law of haversines */
        npy_double sin_lat_d_2 = sin(lat_d / 2),
                   sin_lon_d_2 = sin(lon_d / 2);
        return 2 * asin(sqrt(sin_lat_d_2 * sin_lat_d_2 +
                             cos(lat1) * cos(lat2) *
                             sin_lon_d_2 * sin_lon_d_2));
    }
}
static npy_double
DOUBLE_great_circle_distance_radians(const char *u, const char *v,
                                     npy_intp dim,
                                     npy_intp u_str, npy_intp v_str)
{
    if (dim != 2) {
        return d_nan;
    }
    return great_circle_distance(*(npy_double *)u,
                                 *(npy_double *)(u + u_str),
                                 *(npy_double *)v,
                                 *(npy_double *)(v + v_str));
}

static npy_double
DOUBLE_great_circle_distance_degrees(const char *u, const char *v,
                                     npy_intp dim,
                                     npy_intp u_str, npy_intp v_str)
{
    static npy_double deg2rad = NPY_PI / 180;

    if (dim != 2) {
        return d_nan;
    }
    return great_circle_distance(*(npy_double *)u * deg2rad,
                                 *(npy_double *)(u + u_str) * deg2rad,
                                 *(npy_double *)v * deg2rad,
                                 *(npy_double *)(v + v_str) * deg2rad);
}
 
/*
 *****************************************************************************
 **                         AUXILIARY GUFUNC LOOPS                          **
 *****************************************************************************
 */ 

/* Computes (and returns) Euclidean norm over the last dimension of the
 * input.
 */
 
static void
norm_kernel(char **args, npy_intp *dimensions,
            npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_2(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps;
    
    BEGIN_OUTER_LOOP_2(args)
        const char *u = args[0];
        char *norm = args[1];
        npy_intp j;
        npy_double u_norm = 0;
        
        for(j = 0; j < vec_dim; j++,
                                u += u_str) {
            npy_double u_val = *(npy_double *)u;
            u_norm += u_val * u_val;
        }
        *(npy_double *)norm = sqrt(u_norm);
    END_OUTER_LOOP
} /* End of norm_kernel function */
 
/* Computes (and returns) both the mean and the square root of the sum of
 * squared differences from the mean (ssqdm) over the last dimension
 * of the input.
 */
 
static void
mean_ssqdm_kernel(char **args, npy_intp *dimensions,
                  npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u;
        char *mean = args[1], *ssqdm = args[2];
        npy_intp j;
        npy_double u_mean = 0, u_ssqdm = 0;
        
        for (u = args[0],
             j = 0; j < vec_dim; j++,
                                 u  += u_str) {
            u_mean += *(npy_double *)u;
        }
        u_mean /= vec_dim;
        for(u = args[0],
            j = 0; j < vec_dim; j++,
                                u += u_str) {
            npy_double u_val = *(npy_double *)u - u_mean;
            u_ssqdm += u_val * u_val;
        }
        *(npy_double *)mean = u_mean;
        *(npy_double *)ssqdm = sqrt(u_ssqdm);
    END_OUTER_LOOP
} /* End of mean_ssqdm_kernel function */

/* Computes both the mean and the square root of the sum of squared
 * differences from the mean (ssqdm) over the last dimension. Returns
 * the input centered, i.e. subtracts the mean from each entry, and the
 * ssqdm.
 */

static void
center_ssqdm_kernel(char **args, npy_intp *dimensions,
                    npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_i_str = *steps++,
             u_o_str = *steps++;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u_in;
        char *u_out,
             *ssqdm = args[2];
        npy_intp j;
        npy_double u_mean = 0, u_ssqdm = 0;
        
        for (u_in = args[0],
             j = 0; j < vec_dim; j++,
                                 u_in += u_i_str) {
            u_mean += *(npy_double *)u_in;
        }
        u_mean /= vec_dim;
        for(u_in = args[0],
            u_out = args[1],
            j = 0; j < vec_dim; j++,
                                u_in += u_i_str,
                                u_out += u_o_str) {
            npy_double u_val = *(npy_double *)u_in - u_mean;
            u_ssqdm += u_val * u_val;
            *(npy_double *)u_out = u_val;
        }
        *(npy_double *)ssqdm = sqrt(u_ssqdm);
    END_OUTER_LOOP
} /* End of center_ssqdm_kernel function */

/*
 *****************************************************************************
 **                          GENERIC GUFUNC LOOPS                           **
 *****************************************************************************
 */

/* Generic GUFUNC kernel for distances of two arguments */
 
static void
distance_uv_kernel(char **args, npy_intp *dimensions,
                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*, npy_intp,
                                        npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_3(args)
        const char *u_vec = args[0],
                   *v_vec = args[1];
        char *dist = args[2];
        
        *(npy_double *)dist = func(u_vec, v_vec, vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments */

static void
pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                            npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_2(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*, npy_intp,
                                        npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_2(args)
        const char *u, *v;
        char *pdist;
        npy_intp j, k;
        
        for (u = args[0],
             pdist = args[1],
             j = 0; j < u_len; j++,
                               u += u_len_str) {
            for (v = u + u_len_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of pairwise_distance_uv_kernel function */

/* Generic GUFUNC kernel for distances of two arguments with one cached
 * value.
 */

static void
cached_distance_uv_kernel(char **args, npy_intp *dimensions,
                          npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_5(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_5(args)
        const char *u_vec = args[0],
                   *v_vec = args[1],
                   *u_cache = args[2],
                   *v_cache = args[3];
        char *dist = args[4];
        
        *(npy_double *)dist = func(u_vec, v_vec, u_cache, v_cache,
                                   vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of cached_distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments with one
 * cached value.
 */

static void
cached_pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_3(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             u_cache_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_3(args)
        const char *u, *u_cache,
                   *v, *v_cache;
        char *pdist;
        npy_intp j, k;
        for (u = args[0],
             u_cache = args[1],
             pdist = args[2],
             j = 0; j < u_len; j++,
                               u += u_len_str,
                               u_cache += u_cache_str) {
            for (v = u + u_len_str,
                 v_cache = u_cache + u_cache_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       v_cache += u_cache_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, u_cache, v_cache,
                                            vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of cached_pairwise_distance_uv_kernel function */

/* Generic GUFUNC kernel for distances of two arguments with two cached
 * values.
 */

static void
cached2_distance_uv_kernel(char **args, npy_intp *dimensions,
                          npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_7(dimensions, steps)
    
    npy_intp vec_dim = *dimensions;
    npy_intp u_str = *steps++,
             v_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func) data;
    
    BEGIN_OUTER_LOOP_7(args)
        const char *u_vec = args[0],
                   *v_vec = args[1],
                   *u_cache1 = args[2],
                   *v_cache1 = args[3],
                   *u_cache2 = args[4],
                   *v_cache2 = args[5];
        char *dist = args[6];
        
        *(npy_double *)dist = func(u_vec, v_vec, u_cache1, v_cache1,
                                   u_cache2, v_cache2, vec_dim, u_str, v_str);
    END_OUTER_LOOP
} /* End of cached2_distance_uv_kernel function */

/* Generic GUFUNC kernel for pairwise distances of two arguments with two
 * cached values.
 */

static void
cached2_pairwise_distance_uv_kernel(char **args, npy_intp *dimensions,
                                   npy_intp *steps, void *data)
{
    INIT_OUTER_LOOP_4(dimensions, steps)
    
    npy_intp u_len = *dimensions++, 
             vec_dim = *dimensions++;
    npy_intp u_len_str = *steps++,
             u_str = *steps++,
             u_cache1_str = *steps++,
             u_cache2_str = *steps++,
             pdist_str = *steps;
             
    typedef npy_double (*distance_func)(const char*, const char*,
                                        const char*, const char*,
                                        const char*, const char*,
                                        npy_intp, npy_intp, npy_intp);
    
    distance_func func = (distance_func)data;
   
    BEGIN_OUTER_LOOP_4(args)
        const char *u, *u_cache1, *u_cache2,
                   *v, *v_cache1, *v_cache2;
        char *pdist;
        npy_intp j, k;
        for (u = args[0],
             u_cache1 = args[1],
             u_cache2 = args[2],
             pdist = args[3],
             j = 0; j < u_len; j++,
                               u += u_len_str,
                               u_cache1 += u_cache1_str,
                               u_cache2 += u_cache2_str) {
            for (v = u + u_len_str,
                 v_cache1 = u_cache1 + u_cache1_str,
                 v_cache2 = u_cache2 + u_cache2_str,
                 k = j + 1; k < u_len; k++,
                                       v += u_len_str,
                                       v_cache1 += u_cache1_str,
                                       v_cache2 += u_cache2_str,
                                       pdist += pdist_str) {
                *(npy_double *)pdist = func(u, v, u_cache1, v_cache1,
                                            u_cache2, v_cache2,
                                            vec_dim, u_str, u_str);
            }
        }
    END_OUTER_LOOP
} /* End of cached2_pairwise_distance_uv_kernel function */

/*
 *****************************************************************************
 **                           GUFUNC REGISTRATION                           **
 *****************************************************************************
 */

static void *null_data[] = {
    (void *) NULL, (void *) NULL, (void *) NULL,
};

/* DOUBLE only distance functions */

static void *bray_curtis_data[] = {
    (void *) &DOUBLE_bray_curtis_distance,
};

static void *canberra_data[] = {
    (void *) &DOUBLE_canberra_distance,
};

static void *chebyshev_data[] = {
    (void *) &DOUBLE_chebyshev_distance,
};

static void *min_chebyshev_data[] = {
    (void *) &DOUBLE_minimum_chebyshev_distance,
};

static void *city_block_data[] = {
    (void *) &DOUBLE_city_block_distance,
};

static void *correlation_data[] = {
    (void *) &DOUBLE_correlation_distance,
};

static void *cached_correlation_data[] = {
    (void *) &DOUBLE_cached_correlation_distance,
};

static void *cosine_data[] = {
    (void *) &DOUBLE_cosine_distance,
};

static void *cached_cosine_data[] = {
    (void *) &DOUBLE_cached_cosine_distance,
};

static void *euclidean_data[] = {
    (void *) &DOUBLE_euclidean_distance,
};

static void *sqeuclidean_data[] = {
    (void *) &DOUBLE_sqeuclidean_distance,
};

static void *greatcircle_degrees_data[] = {
    (void *) &DOUBLE_great_circle_distance_degrees,
};

/* BOOL, INTP and DOUBLE distance functions */

static void *hamming_data[] = {
    (void *) &BOOL_hamming_distance,
    (void *) &INTP_hamming_distance,
    (void *) &DOUBLE_hamming_distance,
};

static void *dice_data[] = {
    (void *) &BOOL_dice_distance,
    (void *) &INTP_dice_distance,
    (void *) &DOUBLE_dice_distance,
};

static void *jaccard_data[] = {
    (void *) &BOOL_jaccard_distance,
    (void *) &INTP_jaccard_distance,
    (void *) &DOUBLE_jaccard_distance,
};

static void *kulsinski_data[] = {
    (void *) &BOOL_kulsinski_distance,
    (void *) &INTP_kulsinski_distance,
    (void *) &DOUBLE_kulsinski_distance,
};

static void *rogers_tanimoto_data[] = {
    (void *) &BOOL_rogers_tanimoto_distance,
    (void *) &INTP_rogers_tanimoto_distance,
    (void *) &DOUBLE_rogers_tanimoto_distance,
};

static void *russell_rao_data[] = {
    (void *) &BOOL_russell_rao_distance,
    (void *) &INTP_russell_rao_distance,
    (void *) &DOUBLE_russell_rao_distance,
};

static void *sokal_sneath_data[] = {
    (void *) &BOOL_sokal_sneath_distance,
    (void *) &INTP_sokal_sneath_distance,
    (void *) &DOUBLE_sokal_sneath_distance,
};

static void *yule_data[] = {
    (void *) &BOOL_yule_distance,
    (void *) &INTP_yule_distance,
    (void *) &DOUBLE_yule_distance,
};

PyUFuncGenericFunction norm_kernel_funcs[] = {
    &norm_kernel,
};

PyUFuncGenericFunction mean_ssqdm_kernel_funcs[] = {
    &mean_ssqdm_kernel,
};

PyUFuncGenericFunction center_ssqdm_kernel_funcs[] = {
    &center_ssqdm_kernel,
};

PyUFuncGenericFunction distance_uv_kernel_funcs[] = {
    &distance_uv_kernel,
    &distance_uv_kernel,
    &distance_uv_kernel,
};

PyUFuncGenericFunction pairwise_distance_uv_kernel_funcs[] = {
    &pairwise_distance_uv_kernel,
    &pairwise_distance_uv_kernel,
    &pairwise_distance_uv_kernel,
};

PyUFuncGenericFunction cached_distance_uv_kernel_funcs[] = {
    &cached_distance_uv_kernel,
    &cached_distance_uv_kernel,
    &cached_distance_uv_kernel,
};

PyUFuncGenericFunction cached_pairwise_distance_uv_kernel_funcs[] = {
    &cached_pairwise_distance_uv_kernel,
    &cached_pairwise_distance_uv_kernel,
    &cached_pairwise_distance_uv_kernel,
};

PyUFuncGenericFunction cached2_distance_uv_kernel_funcs[] = {
    &cached2_distance_uv_kernel,
    &cached2_distance_uv_kernel,
    &cached2_distance_uv_kernel,
};

PyUFuncGenericFunction cached2_pairwise_distance_uv_kernel_funcs[] = {
    &cached2_pairwise_distance_uv_kernel,
    &cached2_pairwise_distance_uv_kernel,
    &cached2_pairwise_distance_uv_kernel,
};

static char all_DOUBLE_types[] = {
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_TYPE_DOUBLE_types[] = {
    NPY_BOOL, NPY_BOOL, NPY_DOUBLE,
    NPY_INTP, NPY_INTP, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_DOUBLE_types[] = {
    NPY_BOOL, NPY_DOUBLE,
    NPY_INTP, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_TYPE_DOUBLE_DOUBLE_types[] = {
    NPY_BOOL, NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE,
    NPY_INTP, NPY_INTP, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

static char TYPE_DOUBLE_DOUBLE_types[] = {
    NPY_BOOL, NPY_DOUBLE, NPY_DOUBLE,
    NPY_INTP, NPY_DOUBLE, NPY_DOUBLE,
    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE,
};

 typedef struct gufunc_descriptor_struct {
    char *name;
    char *signature;
    char *doc;
    int ntypes;
    int nin;
    int nout;
    PyUFuncGenericFunction *funcs;
    char *types;
    void *data;
} GUFUNC_DESCRIPTOR_t;

GUFUNC_DESCRIPTOR_t gufunc_descriptors[] = {
    {
        "_norm",
        "(d)->()",
        "Euclidean norm on the last dimension, broadcast on the rest.\n"
        "    (d)->()\n",
        1, 1, 1,
        norm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_mean_ssqdm",
        "(d)->(),()",
        "Mean and square root of the sum of squared differences from "
        "the mean on the last dimension, broadcast on the rest.\n"
        "    (d)->(),()\n",
        1, 1, 2,
        mean_ssqdm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_center_ssqdm",
        "(d)->(d),()",
        "Centered input (mean subtracted) and square root of the sum of "
        "squared differences from the mean on the last dimension, "
        "broadcast on the rest.\n"
        "    (d)->(d),()\n",
        1, 1, 2,
        center_ssqdm_kernel_funcs,
        all_DOUBLE_types,
        null_data
    },
    {
        "_braycurtis",
        "(d),(d)->()",
        "Bray-Curtis distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        bray_curtis_data
    },
    {
        "_pairwise_braycurtis",
        "(n,d)->(p)",
        "Bray-Curtis distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        bray_curtis_data
    },
    {
        "_canberra",
        "(d),(d)->()",
        "Canberra distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        canberra_data
    },
    {
        "_pairwise_canberra",
        "(n,d)->(p)",
        "Canberra distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        canberra_data
    },
    {
        "_chebyshev",
        "(d),(d)->()",
        "Chebyshev distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        chebyshev_data
    },
    {
        "_pairwise_chebyshev",
        "(n,d)->(p)",
        "Chebyshev distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        chebyshev_data
    },
    {
        "_min_chebyshev",
        "(d),(d)->()",
        "Minimum Chebyshev distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        min_chebyshev_data
    },
    {
        "_pairwise_min_chebyshev",
        "(n,d)->(p)",
        "Minimum Chebyshev distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        min_chebyshev_data
    },
    {
        "_cityblock",
        "(d),(d)->()",
        "City Block (Manhattan) distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        city_block_data
    },
    {
        "_pairwise_cityblock",
        "(n,d)->(p)",
        "City Block (Manhattan) distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        city_block_data
    },
    {
        "_correlation",
        "(d),(d)->()",
        "Correlation distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        correlation_data
    },
    {
        "_pairwise_correlation",
        "(n,d)->(p)",
        "Correlation distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        correlation_data
    },
    {
        "_cached_correlation",
        "(d),(d),(),(),(),()->()",
        "Buffered correlation distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d),(),(),(),()->()\n",
        1, 6, 1,
        cached2_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_correlation_data
    },
    {
        "_cached_pairwise_correlation",
        "(n,d),(n),(n)->(p)",
        "Cached correlation distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d),(n),(n)->(p)\n",
        1, 3, 1,
        cached2_pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_correlation_data
    },
    {
        "_cosine",
        "(d),(d)->()",
        "Cosine distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cosine_data
    },
    {
        "_pairwise_cosine",
        "(n,d)->(p)",
        "Cosine distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cosine_data
    },
    {
        "_cached_cosine",
        "(d),(d),(),()->()",
        "Cosine distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d),(),()->()\n",
        1, 4, 1,
        cached_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_cosine_data
    },
    {
        "_cached_pairwise_cosine",
        "(n,d),(n)->(p)",
        "Cosine distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d),(n)->(p)\n",
        1, 2, 1,
        cached_pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        cached_cosine_data
    },
    {
        "_euclidean",
        "(d),(d)->()",
        "Euclidean distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        euclidean_data
    },
    {
        "_pairwise_euclidean",
        "(n,d)->(p)",
        "Euclidean distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        euclidean_data
    },
    {
        "_sqeuclidean",
        "(d),(d)->()",
        "Squared Euclidean distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        sqeuclidean_data
    },
    {
        "_pairwise_sqeuclidean",
        "(n,d)->(p)",
        "Squared Euclidean distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        sqeuclidean_data
    },
    {
        "_dice",
        "(d),(d)->()",
        "Dice distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        dice_data
    },
    {
        "_pairwise_dice",
        "(n,d)->(p)",
        "Dice distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        dice_data
    },
    {
        "_hamming",
        "(d),(d)->()",
        "Hamming distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        hamming_data
    },
    {
        "_pairwise_hamming",
        "(n,d)->(p)",
        "Hamming distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        hamming_data
    },
    {
        "_jaccard",
        "(d),(d)->()",
        "Jaccard distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        jaccard_data
    },
    {
        "_pairwise_jaccard",
        "(n,d)->(p)",
        "Jaccard distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        jaccard_data
    },
    {
        "_kulsinski",
        "(d),(d)->()",
        "Kulsinski distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        kulsinski_data
    },
    {
        "_pairwise_kulsinski",
        "(n,d)->(p)",
        "Kulsinski distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        kulsinski_data
    },
    {
        "_rogerstanimoto",
        "(d),(d)->()",
        "Rogers-Tanimoto distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        rogers_tanimoto_data
    },
    {
        "_pairwise_rogerstanimoto",
        "(n,d)->(p)",
        "Rogers-Tanimoto distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        rogers_tanimoto_data
    },
    {
        "_russellrao",
        "(d),(d)->()",
        "Russell-Rao distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        russell_rao_data
    },
    {
        "_pairwise_russellrao",
        "(n,d)->(p)",
        "Russell-Rao distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        russell_rao_data
    },
    {
        "_sokalsneath",
        "(d),(d)->()",
        "Sokal-Sneath distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        sokal_sneath_data
    },
    {
        "_pairwise_sokalsneath",
        "(n,d)->(p)",
        "Sokal-Sneath distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        sokal_sneath_data
    },
    {
        "_yule",
        "(d),(d)->()",
        "Yule distance on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        3, 2, 1,
        distance_uv_kernel_funcs,
        TYPE_TYPE_DOUBLE_types,
        yule_data
    },
    {
        "_pairwise_yule",
        "(n,d)->(p)",
        "Yule distance on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        3, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        TYPE_DOUBLE_types,
        yule_data
    },
    {
        "_greatcircle",
        "(d),(d)->()",
        "Great-circle distance on a sphere on the last dimension, "
        "broadcast on the rest.\n"
        "    (d),(d)->()\n",
        1, 2, 1,
        distance_uv_kernel_funcs,
        all_DOUBLE_types,
        greatcircle_degrees_data
    },
    {
        "_pairwise_greatcircle",
        "(n,d)->(p)",
        "Great-circle distance on a sphere on all pairs of vectors over the "
        "last two dimensions, broadcast on the rest.\n"
        "    (n,d)->(p)\n",
        1, 1, 1,
        pairwise_distance_uv_kernel_funcs,
        all_DOUBLE_types,
        greatcircle_degrees_data
    },
}; /* End of gufunc_descriptors declaration */

static void
addUfuncs(PyObject *dictionary) {
    PyObject *f;
    int i;
    const int gufunc_count = sizeof(gufunc_descriptors) /
                             sizeof(gufunc_descriptors[0]);
    for (i=0; i < gufunc_count; i++) {
        GUFUNC_DESCRIPTOR_t* d = &gufunc_descriptors[i];
        f = PyUFunc_FromFuncAndDataAndSignature(d->funcs,
                                                d->data,
                                                d->types,
                                                d->ntypes,
                                                d->nin,
                                                d->nout,
                                                PyUFunc_None,
                                                d->name,
                                                d->doc,
                                                0,
                                                d->signature);
        PyDict_SetItemString(dictionary, d->name, f);
    }
}

/*
 *****************************************************************************
 **                          MODULE INITIALIZATION                          **
 *****************************************************************************
 */
 
static PyMethodDef module_methods[] = {
    {NULL, NULL, 0, NULL},        /* Sentinel */
};

#if defined(NPY_PY3K)
static struct PyModuleDef moduledef = {
        PyModuleDef_HEAD_INIT,
        NUMPYPE_MODULE_NAME,
        NULL,
        -1,
        module_methods,
        NULL,
        NULL,
        NULL,
        NULL
};
#endif

#if defined(NPY_PY3K)
    #define RETVAL m
    PyObject*
    APPEND_MODULE(PyInit_) (void)/**PyInit__numpype(void)*/
#else
    #define RETVAL
    PyMODINIT_FUNC
    APPEND_MODULE(init) (void)
#endif
{
    PyObject *m;
    PyObject *d;
    PyObject *version;

    init_constants();
#if defined(NPY_PY3K)
    m = PyModule_Create(&moduledef);
#else
    m = Py_InitModule(MODULE_NAME_STR, module_methods);
#endif
    if (m == NULL)
        return RETVAL;

    import_array();
    import_ufunc();

    d = PyModule_GetDict(m);

    version = PyString_FromString(VERSION_STR);
    PyDict_SetItemString(d, "__version__", version);
    Py_DECREF(version);

    /* Load the ufunc operators into the module's namespace */
    addUfuncs(d);

    if (PyErr_Occurred()) {
        PyErr_SetString(PyExc_RuntimeError,
                        "cannot load " MODULE_NAME_STR " module.");
    }

    return RETVAL;
}