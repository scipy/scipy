<TITLE> Overview of functions in the cephes module for numerical python </TITLE>

Any time a function allows a complex number z it also allows a real number x.

<h1> Airy Functions </h1>
<DL>
<DT>(Ai,Aip,Bi,Bip) = airy(z)
<DD>airy(z) calculates the Airy functions and their derivatives
evaluated at real or complex number z.  The Airy functions Ai and Bi 
are two independent solutions of y''(x)=xy.  Aip and Bip are the first derivatives
evaluated at x of Ai and Bi respectively.

<DT>(Aie,Aipe,Bie,Bipe) = airye(z)
<DD>airye(z) calculates the exponentially scaled Airy functions and 
their derivatives evaluated at real or complex number z.  
airye(z)[0:1] = airy(z)[0:1] * exp(2.0/3.0*z*sqrt(z))
airye(z)[2:3] = airy(z)[2:3] * exp(-abs((2.0/3.0*z*sqrt(z)).real))
</DL>

<DT>(Apt,Bpt,Ant,Bnt) = itairy(x)
<DD>itairy(x) calculates the integral of Airy functions from 0 to x
for positive (Apt, Bpt) and negative (Ant, Bnt) arguments.

<h1> Elliptic Functions and Integrals </h1>
<DL>
<DT>(sn,cn,dn,ph) = ellipj(u,m)
<DD>ellipj(u,m) calculates the Jacobian elliptic functions of
parameter m between 0 and 1, and real u.  The returned functions are
often written sn(u|m), cn(u|m), and dn(u|m).  The value of ph is such
that if u = ellik(ph,m), then sn(u|m) = sin(ph) and cn(u|m) = cos(ph).

<DT>y = ellipe(m)
<DD>ellipe(m) returns the complete integral of the second kind:
integral(sqrt(1-m*sin(t)**2),t=0..pi/2)

<DT>y = ellipeinc(phi,m)
<DD>ellipeinc(phi,m) returns the incomplete elliptic integral of the
second kind: integral(sqrt(1-m*sin(t)**2),t=0..phi)

<DT>y = ellipk(m)
<DD>ellipk(m) returns the complete integral of the first kind:
integral(1/sqrt(1-m*sin(t)**2),t=0..pi/2)

<DT>y = ellipkinc(phi,m)
<DD>ellipkinc(phi,m) returns the incomplete elliptic integral of the first
kind: integral(1/sqrt(1-m*sin(t)**2),t=0..phi)
</DL>


<h1> Bessel Functions </h1>
<DL>
<DT>y = jn(n,x)
<DD>jn(n,x) returns the Bessel function of integer order n at  x.

<DT>y = jv(v,z)
<DD>jv(v,z) returns the Bessel function of real order v at complex z.

<DT>y = jve(v,z)
<DD>jve(v,z) returns the exponentially scaled Bessel function of real order
v at complex z: jve(v,z) = jv(v,z) * exp(-abs(z.imag))

<DT>y = yn(n,x)
<DD>yn(n,x) returns the Bessel function of the second kind of integer
order n at x. 

<DT>y = yv(n,z)
<DD>yv(v,z) returns the Bessel function of the second kind of real
order v at complex z.

<DT>y = yve(n,z)
<DD>yve(v,z) returns the exponentially scaled Bessel function of the second 
kind of real order v at complex z: yve(v,z) = yv(v,z) * exp(-abs(z.imag))


<DT>y = kn(n,x)
<DD>kn(n,x) returns the modified Bessel function of the third kind for
integer order n at x.

<DT>y = kv(v,z)
<DD>kv(v,z) returns the modified Bessel function of the third kind for
real order v at complex z.

<DT>y = kve(v,z)
<DD>kve(v,z) returns the exponentially scaled, modified Bessel function
of the third kind for real order v at complex z: kve(v,z) = kv(v,z) * exp(z)

<DT>y = iv(v,z)
<DD>iv(v,z) returns the modified Bessel function of real order v of
z.  If z is of real type and negative, v must be integer valued.

<DT>y = ive(v,z)
<DD>ive(v,z) returns the exponentially scaled modified Bessel function of 
real order v and complex z: ive(v,z) = iv(v,z) * exp(-abs(z.real))

<DT>y = hankel1(v,z)
<DD>hankel1(v,z) returns the Hankel function of the first kind for real order v and complex argument z.  

<DT>y = hankel1e(v,z)
<DD>hankel1e(v,z) returns the exponentially scaled Hankel function of the first
kind for real order v and complex argument z:
hankel1e(v,z) = hankel1(v,z) * exp(-1j * z)

<DT>y = hankel2(v,z)
<DD>hankel2(v,z) returns the Hankel function of the second kind for real order v and complex argument z.  

<DT>y = hankel2e(v,z)
<DD>hankel2e(v,z) returns the exponentially scaled Hankel function of the second
kind for real order v and complex argument z:
hankel1e(v,z) = hankel1(v,z) * exp(1j * z)

<DT>y = j0(x)
<DD>j0(x) returns the Bessel function of order 0 at x.

<DT>y = j1(x)
<DD>j1(x) returns the Bessel function of order 1 at x.

<DT>y = y0(x)
<DD>y0(x) returns the Bessel function of the second kind of order 0 at x.

<DT>y = y1(x)
<DD>y1(x) returns the Bessel function of the second kind of order 1 at x.

<DT>y = i0(x)
<DD>i0(x) returns the modified Bessel function of order 0 at x.

<DT>y = i1(x)
<DD>i1(x) returns the modified Bessel function of order 1 at x.

<DT>y = i0e(x)
<DD>i0e(x) returns the exponentially scaled modified Bessel function
of order 0 at x.  i0e(x) = exp(-|x|) * i0(x).

<DT>y = i1e(x)
<DD>i1e(x) returns the exponentially scaled modified Bessel function
of order 0 at x.  i1e(x) = exp(-|x|) * i1(x).

<DT>y = k0(x)
<DD>i0(x) returns the modified Bessel function of the third kind of
order 0 at x. 

<DT>y = k1(x)
<DD>i1(x) returns the modified Bessel function of the third kind of
order 1 at x. 

<DT>y = k0e(x)
<DD>k0e(x) returns the exponentially scaled modified Bessel function
of the third kind of order 0 at x.  k0e(x) = exp(x) * k0(x).

<DT>y = k1e(x)
<DD>k1e(x) returns the exponentially scaled modified Bessel function
of the third kind of order 1 at x.  k1e(x) = exp(x) * k1(x)
</DL>

<DT>y = besselpoly(a,lambda,nu)
<DD>besselpoly(a,lambda,nu) computes the integral of a bessel function
times a power:  y = integral(x^lambda jv(2*a*x),x=0..1)
</DL>

<DT>(ij0,iy0) = itj0y0(x)
<DD>itj0y0(x) returns simple integrals from 0 to x of the zeroth order 
bessel functions j0 and y0. 

<DT>(ij0,iy0) = it2j0y0(x)
<DD>it2j0y0(x) returns the integrals int((1-j0(t))/t,t=0..x) and 
int(y0(t)/t,t=x..infinitity). 

<DT>(ii0,ik0) = iti0k0(x)
<DD>iti0k0(x) returns simple integrals from 0 to x of the zeroth order 
modified bessel functions i0 and k0. 

<DT>(ii0,ik0) = it2i0k0(x)
<DD>it2i0k0(x) returns the integrals int((i0(t)-1)/t,t=0..x) and 
int(k0(t)/t,t=x..infinitity). 


<h1> Statistical Functions </h1>
<DL>
<DT>y = bdtr(k,n,p)
<DD>bdtr(k,n,p) returns the sum of the terms 0 through k of the
Binomial probability density:  sum(nCj p**j (1-p)**(n-j),j=0..k)

<DT>y = bdtrc(k,n,p)
<DD>bdtrc(k,n,p) returns the sum of the terms k+1 through n of the
Binomial probability density: sum(nCj p**j (1-p)**(n-j), j=k+1..n)

<DT>p = bdtri(k,n,y)
<DD>bdtri(k,n,y) finds the probability p such that the sum of the
terms 0 through k of the Binomial probability density is equal to the
given cumulative probability y.

<DT>y = btdtr(a,b,x)
<DD>btdtr(a,b,x) returns the area from zero to x under the beta
density function: gamma(a+b)/(gamma(a)*gamma(b)))*integral(t**(a-1)
(1-t)**(b-1), t=0..x).  SEE ALSO betainc

<DT>x = btdtri(a,b,p)
<DD>btdtri(a,b,p) returns the pth quantile of the beta distribution.  It is
effectively the inverse of btdtr returning the value of x for which 
btdtr(a,b,x) = p.   SEE ALSO betaincinv

<DT>y = fdtr(dfn,dfd,x) 
<DD>fdtr(dfn,dfd,x) returns the area from zero to x under the F density
function (also known as Snedcor's density or the variance ratio
density).  This is the density of X = (unum/dfn)/(uden/dfd), where unum and
uden are random variables having Chi square distributions with dfn and
dfd degrees of freedom, respectively.

<DT>y = fdtrc(dfn,dfd,x) 
<DD>fdtrc(dfn,dfd,x) returns the complemented F distribution function. 

<DT>x = fdtri(dfn,dfd,p)
<DD>fdtri(dfn,dfd,p) finds the F density argument x such that 
fdtr(dfn,dfd,x)=p. 

<DT>x = fdtridfn(dfn,dfd,p)
<DD>fdtridfn(p,dfd,x) finds the F density argument dfn such that 
fdtr(dfn,dfd,x)=p. 

<DT>x = fdtridfd(dfn,p,x)
<DD>fdtridfd(dfn,p,x) finds the F density argument dfd such that 
fdtr(dfn,dfd,x)=p. 


<DT>y = gdtr(a,b,x)
<DD>gdtr(a,b,x) returns the integral from zero to x of the gamma
probability density function: a**b / gamma(b) * integral(t**(b-1) exp(-at),t=0..x).
The arguments a and b are used differently here than in other definitions. 

<DT>y = gdtrc(a,b,x)
<DD>gdtrc(a,b,x) returns the integral from x to infinity of the gamma
probability density function.  SEE gdtr, gdtri

<DT>x = gdtri(a,b,p)
<DD>gdtri(a,b,p) returns pth quantile of the gamma distribution.  It is 
the inverse of the gamma cdf returning the value of x for which 
gdtr(b,a,x) = p. 

<DT>y = nbdtr(k,n,p)
<DD>nbdtr(k,n,p) returns the sum of the terms 0 through k of the
negative binomial distribution: sum((n+j-1)Cj p**n (1-p)**j,j=0..k).
In a sequence of Bernoulli trials this is the probability that k or
fewer failures precede the nth success. 

<DT>y = nbdtrc(k,n,p)
<DD>nbdtrc(k,n,p) returns the sum of the terms k+1 to infinity of the
negative binomial distribution.

<DT>p = nbdtri(k,n,y)
<DD>nbdtri(k,n,y) finds the argument p such that nbdtr(k,n,p)=y.

<DT>k = nbdtrik(y,n,p)
<DD>nbdtrik(y,n,p) finds the argument k such that nbdtr(k,n,p)=y.

<DT>n = nbdtrin(k,y,p)
<DD>nbdtrin(k,y,p) finds the argument n such that nbdtr(k,n,p)=y.

<DT>y = pdtr(k,m)
<DD>pdtr(k,m) returns the sum of the first k terms of the Poisson
distribution: sum(exp(-m) * m**j / j!, j=0..k) = gammaincc( k+1, m).
Arguments must both be positive and k an integer.

<DT>y = pdtrc(k,m)
<DD>pdtrc(k,m) returns the sum of the terms from k+1 to infinity of the
Poisson distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc( k+1, m).
Arguments must both be positive and k an integer.

<DT>m = pdtri(k,y)
<DD>pdtri(k,y) returns the Poisson variable m such that the sum
from 0 to k of the Poisson density is equal to the given probability
y:  calculated by gammaincinv( k+1, y).  k must be a nonnegative integer and
y between 0 and 1.

<DT>k = pdtrik(p,m)
<DD>pdtrik(p,m) returns the quantile k such that pdtr(k,m)=p

<DT>p = stdtr(df,t)
<DD>stdtr(df,t) returns the integral from minus infinity to t of the Student t
distribution with df > 0 degrees of freedom:
gamma((df+1)/2)/(sqrt(df*pi)*gamma(df/2)) * integral((1+x**2/df)**(-df/2-1/2),
x=-inf..t) 

<DT>t = stdtrit(df,p)
<DD>stdtrit(df,p) returns the argument t such that stdtr(df,t) is equal to p.

<DT>t = stdtridf(p,t)
<DD>stdtridf(p,t) returns the argument df such that stdtr(df,t) is equal to p.


<DT>p = chdtr(v,x)
<DD>chdtr(v,x) Returns the area under the left hand tail (from 0 to x) of the Chi
square probability density function with v degrees of freedom:
1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=0..x)

<DT>p = chdtrc(v,x)
<DD>chdtrc(v,x) returns the area under the right hand tail (from x to
infinity) of the Chi square probability density function with v
degrees of freedom:
1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=x..inf)

<DT>x = chdtri(v,p)
<DD>chdtri(v,p) returns the argument x such that chdtrc(v,x) is equal
to p.

<DT>y = ndtr(x)
<DD>ndtr(x) returns the area under the standard Gaussian probability 
density function, integrated from minus infinity to x:
1/sqrt(2*pi) * integral(exp(-t**2 / 2),t=-inf..x)

<DT>x = ndtri(y)
<DD>ndtri(y) returns the argument x for which the area udnder the
Gaussian probability density function (integrated from minus infinity
to x) is equal to y.

<DT>y = smirnov(n,e)
<DD>smirnov(n,e) returns the exact Kolmogorov-Smirnov complementary 
cumulative distribution function (Dn+ or Dn-) for a one-sided test of 
equality between an empirical and a theoretical distribution. It is equal 
to the probability that the maximum difference between a theoretical 
distribution and an empirical one based on n samples is greater than e.

<DT>e = smirnovi(n,y)
<DD>smirnovi(n,y) returns e such that smirnov(n,e) = y.

<DT>p = kolmogorov(y)
<DD>kolmogorov(y) returns the complementary cumulative distribution 
function of Kolmogorov's limiting distribution (Kn* for large n) 
of a two-sided test for equality between an empirical and a theoretical 
distribution. It is equal to the (limit as n->infinity of the) probability 
that sqrt(n) * max absolute deviation > y.

<DT>y = kolmogi(p)
<DD>kolmogi(p) returns y such that kolmogorov(y) = p
</DL>

<h1> Gamma and Related Functions </h1>
<DL>
<DT>y = gamma(z)
<DD>gamma(z) returns the gamma function of the argument.  The gamma
function is often referred to as the generalized factorial since 
z*gamma(z) = gamma(z+1) and gamma(n+1) = n! for natural number n.

<DT>y = gammaln(z)
<DD>gammaln(z) returns the base e logarithm of the absolute value of the
gamma function of z: ln(|gamma(z)|)

<DT>y = gammainc(a,x)
<DD>gammainc(a,x) returns the incomplete gamma integral defined as
1 / gamma(a) * integral(exp(-t) * t**(a-1), t=0..x).  Both arguments
must be positive.

<DT>y = gammaincc(a,x)
<DD>gammaincc(a,x) returns the complemented incomplete gamma integral
defined as 1 / gamma(a) * integral(exp(-t) * t**(a-1), t=x..inf) = 1 -
gammainc(a,x).  Both arguments must be positive.

<DT>x = gammainccinv(a,y)
<DD>gammainccinv(a,y) returns x such that gammaincc(a,x) = y.  

<DT>y = beta(a,b)
<DD>beta(a,b) returns gamma(a) * gamma(b) / gamma(a+b)

<DT>y = betaln(x)
<DD>betaln(a,b) returns the natural logarithm of the absolute value of
beta: ln(|beta(x)|). 

<DT>y = betainc(a,b,x)
<DD>betainc(a,b,x) returns the incomplete beta integral of the
arguments, evaluated from zero to x: gamma(a+b) / (gamma(a)*gamma(b))
* integral(t**(a-1) (1-t)**(b-1), t=0..x).

<DT>x = betaincinv(a,b,y)
<DD>betaincinv(a,b,y) returns x such that betainc(a,b,x) = y.

<DT>y = psi(z)
<DD>psi(z) is the derivative of the logarithm of the gamma function
evaluated at z (also called the digamma function). 

<DT>y = rgamma(z)
<DD>rgamma(z) returns one divided by the gamma function of x. 
</DL>

<h1> Error Function and Fresnel integrals </h1>
<DL>
<DT>y = erf(z)
<DD>erf(z) returns the error function of complex argument defined as
as 2/sqrt(pi)*integral(exp(-t**2),t=0..z) 

<DT>y = erfc(x)
<DD>erfc(x) returns 1 - erf(x).

<DT>(ssa,cca) = fresnel(z)
<DD>fresnel(z) returns the fresnel sin and cos integrals: integral(sin(pi/2
* t**2),t=0..z) and integral(cos(pi/2 * t**2),t=0..z) for real or 
complex z.

<DT>(fp,kp) = modfresnelp(x)
<DD>modfresnelp(x) returns the modified fresnel integrals F_+(x) and K_+(x)
as fp=integral(exp(1j*t*t),t=x..inf) and kp=1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp

<DT>(fm,km) = modfresnelm(x)
<DD>modfresnelp(x) returns the modified fresnel integrals F_-(x) amd K_-(x)
as fp=integral(exp(-1j*t*t),t=x..inf) and kp=1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp
</DL>

<h1> HyperGeometric Functions </h1>
<DL>
<DT>y = hyp2f1(a,b,c,z)
<DD>hyp2f1(a,b,c,z) returns the gauss hypergeometric function
( 2F1(a,b;c;z) ).

<DT>y = hyp1f1(a,b,x)
<DD>hyp1f1(a,b,x) returns the confluent hypergeometeric function
( 1F1(a,b;x) ) evaluated at the values a, b, and x.

<DT>y = hyperu(a,b,x)
<DD>hyperu(a,b,x) returns the confluent hypergeometric function of the
second kind U(a,b,x). 

<DT>(y,err) = hyp2f0(a,b,x,type)
<DD>hyp2f0(a,b,x,type) returns (y,err) with the hypergeometric function 2F0 in y and an error estimate in err.  The input type determines a convergence factor and
can be either 1 or 2.

<DT>(y,err) = hyp1f2(a,b,c,x)
<DD>hyp1f2(a,b,c,x) returns (y,err) with the hypergeometric function 1F2 in y and an error estimate in err.  

<DT>(y,err) = hyp3f0(a,b,c,x)
<DD>hyp3f0(a,b,c,x) returns (y,err) with the hypergeometric function 3F0 in y and an error estimate in err.  
</DL>

<h1> Parabolic Cylinder Functions </h1>
<DL>
<DT>(d,dp) = pbdv(v,x)
<DD>pbdv(v,x) returns (d,dp) with the parabolic cylinder function Dv(x) in 
d and the derivative, Dv'(x) in dp.

<DT>(v,vp) = pbvv(v,x)
<DD>pbvv(v,x) returns (v,vp) with the parabolic cylinder function Vv(x) in 
v and the derivative, Vv'(x) in vp.

<DT>(w,wp) = pbwa(a,x)
<DD>pbwa(a,x) returns (w,wp) with the parabolic cylinder function W(a,x) in 
w and the derivative, W'(a,x) in wp.  May not be accurate for large (>5) 
arguments in a and/or x.


<h1> Legendre Functions </h1>
<DL>
<DT>y = lpmv(m,v,x)
<DD>lpmv(m,v,x) returns the associated legendre function of integer order
m and nonnegative degree v: |x|<=1.


<h1> Mathieu Functions </h1>

<DL>
<DT>lmbda = mathieu_a(m,q)
<DD>mathieu_a(m,q) returns the characteristic value for the even solution, 
ce_m(z,q), of Mathieu's equation

<DT>lmbda = mathieu_b(m,q)
<DD>mathieu_b(m,q) returns the characteristic value for the odd solution, 
se_m(z,q), of Mathieu's equation

<DT>lmbda = mathieu_b(m,q)
<DD>mathieu_b(m,q) returns the characteristic value for the odd solution, 
se_m(z,q), of Mathieu's equation

<DT>(y,yp) = mathieu_cem(m,q,x)
<DD>mathieu_cem(m,q,x) returns the even Mathieu function, ce_m(x,q), 
of order m and parameter q evaluated at x (given in degrees).
Also returns the derivative with respect to x of ce_m(x,q)

<DT>(y,yp) = mathieu_sem(m,q,x)
<DD>mathieu_sem(m,q,x) returns the odd Mathieu function, se_m(x,q), 
of order m and parameter q evaluated at x (given in degrees).
Also returns the derivative with respect to x of se_m(x,q).

<DT>(y,yp) = mathieu_modcem1(m,q,x)
<DD>mathieu_modcem1(m,q,x) evaluates the even modified Matheiu function 
of the first kind, Mc1m(x,q), and its derivative at x for order m and
parameter q.

<DT>(y,yp) = mathieu_modcem2(m,q,x)
<DD>mathieu_modcem2(m,q,x) evaluates the even modified Matheiu function 
of the second kind, Mc2m(x,q), and its derivative at x (given in degrees)
for order m and parameter q.

<DT>(y,yp) = mathieu_modsem1(m,q,x)
<DD>mathieu_modsem1(m,q,x) evaluates the odd modified Matheiu function 
of the first kind, Ms1m(x,q), and its derivative at x (given in degrees)
for order m and parameter q.

<DT>(y,yp) = mathieu_modsem2(m,q,x)
<DD>mathieu_modsem2(m,q,x) evaluates the odd modified Matheiu function
of the second kind, Ms2m(x,q), and its derivative at x (given in degrees)
for order m and parameter q.


<h1> Spheroidal Wave Functions </h1>

<DT>(s,sp) = pro_ang1(m,n,c,x)
<DD>pro_ang1(m,n,c,x) computes the prolate sheroidal angular function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>(s,sp) = pro_rad1(m,n,c,x)
<DD>pro_rad1(m,n,c,x) computes the prolate sheroidal radial function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>(s,sp) = pro_rad2(m,n,c,x)
<DD>pro_rad2(m,n,c,x) computes the prolate sheroidal radial function 
of the second kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>(s,sp) = obl_ang1(m,n,c,x)
<DD>obl_ang1(m,n,c,x) computes the oblate sheroidal angular function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>(s,sp) = obl_rad1(m,n,c,x)
<DD>obl_rad1(m,n,c,x) computes the oblate sheroidal radial function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>(s,sp) = obl_rad2(m,n,c,x)
<DD>obl_rad2(m,n,c,x) computes the oblate sheroidal radial function 
of the second kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. 

<DT>cv = pro_cv(m,n,c)
<DD>pro_cv(m,n,c) computes the characteristic value of prolate spheroidal 
wave functions of order m,n (n>=m) and spheroidal parameter c.

<DT>cv = obl_cv(m,n,c)
<DD>obl_cv(m,n,c) computes the characteristic value of oblate spheroidal 
wave functions of order m,n (n>=m) and spheroidal parameter c.


<DT>(s,sp) = pro_ang1_cv(m,n,c,cv,x)
<DD>pro_ang1_cv(m,n,c,cv,x) computes the prolate sheroidal angular function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<DT>(s,sp) = pro_rad1_cv(m,n,c,cv,x)
<DD>pro_rad1_cv(m,n,c,cv,x) computes the prolate sheroidal radial function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<DT>(s,sp) = pro_rad2_cv(m,n,c,cv,x)
<DD>pro_rad2_cv(m,n,c,cv,x) computes the prolate sheroidal radial function 
of the second kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<DT>(s,sp) = obl_ang1_cv(m,n,c,cv,x)
<DD>obl_ang1_cv(m,n,c,cv,x) computes the oblate sheroidal angular function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<DT>(s,sp) = obl_rad1_cv(m,n,c,cv,x)
<DD>obl_rad1_cv(m,n,c,cv,x) computes the oblate sheroidal radial function 
of the first kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<DT>(s,sp) = obl_rad2_cv(m,n,c,cv,x)
<DD>obl_rad2_cv(m,n,c,cv,x) computes the oblate sheroidal radial function 
of the second kind and its derivative (with respect to x) for mode paramters
m>=0 and n>=m, spheroidal parameter c and |x|<1.0. Requires pre-computed
characteristic value.

<h1> Struve Functions </h1>
<DL>
<DT>y = struve(v,x)
<DD>struve(v,x) returns the Struve function Hv(x) of order v at x, x
must be positive unless v is an integer.

<DT>y = modstruve(v,x)
<DD>modstruve(v,x) returns the modified Struve function Lv(x) of order
v at x, x must be positive unless v is an integer and it is recommended
that |v|<=20.

<DT>y = itstruve0(x)
<DD>itstruve0(x) returns the integral of the Struve function of order 0 
from 0 to x:  integral(H0(t), t=0..x).

<DT>y = it2struve0(x)
<DD>it2struve0(x) returns the integral of the Struve function of order 0 
divided by t from x to infinity:  integral(H0(t)/t, t=x..inf).

<DT>y = itmodstruve0(x)
<DD>itmodstruve0(x) returns the integral of the modified Struve function
of order 0 from 0 to x:  integral(L0(t), t=0..x).
</DL>

<h1> Kelvin Functions </h1>
<DL>
<DT>(Be, Ke, Bep, Kep) = kelvin(x)
<DD>kelvin(x) returns the tuple (Be, Ke, Bep, Kep) which containes 
complex numbers representing the real and imaginary Kelvin functions 
and their derivatives evaluated at x.  For example, 
kelvin(x)[0].real = ber x and kelvin(x)[0].imag = bei x with similar 
relationships for ker and kei.  

<DT>y = ber(x)
<DD>ber(x) returns the Kelvin function ber x

<DT>y = bei(x)
<DD>bei(x) returns the Kelvin function bei x

<DT>y = ker(x)
<DD>ker(x) returns the Kelvin function ker x

<DT>y = kei(x)
<DD>kei(x) returns the Kelvin function ker x

<DT>y = berp(x)
<DD>berp(x) returns the derivative of the Kelvin function ber x

<DT>y = beip(x)
<DD>beip(x) returns the derivative of the Kelvin function bei x

<DT>y = kerp(x)
<DD>kerp(x) returns the derivative of the Kelvin function ker x

<DT>y = keip(x)
<DD>keip(x) returns the derivative of the Kelvin function kei x
</DL>


<h1> Other Special Functions </h1>
<DL>
<DT>y = expn(n,x)
<DD>expn(n,x) returns the exponential integral for integer n and
non-negative x and n: integral(exp(-x*t) / t**n, t=1..inf).

<DT>y = exp1(z)
<DD>exp1(z) returns the exponential integral (n=1) of complex argument
z: integral(exp(-z*t)/t,t=1..inf).

<DT>y = expi(z)
<DD>expi(x) returns an exponential integral of argument x defined as
integral(exp(t)/t,t=-inf..x).  See expn for a different exponential
integral.

<DT>y = wofz(z) 
<DD>wofz(z) returns the value of the fadeeva function for complex argument
z: exp(-z**2)*erfc(-i*z)

<DT>y = besselpoly(a,lam,nu) 
<DD>besselpoly(a,lam,nu) returns the value of the integral:
integral(x**lam * jv(nu,2*a*x),x=0..1).

<DT>y = dawsn(x)
<DD>dawsn(x) returns dawson's integral: exp(-x**2) *
integral(exp(t**2),t=0..x).

<DT>(shi,chi) = shichi(x)
<DD>shichi(x) returns the hyperbolic sine and cosine integrals:
integral(sinh(t)/t,t=0..x) and eul + ln x +
integral((cosh(t)-1)/t,t=0..x) where eul is Euler's Constant.

<DT>(si,ci) = sici(x)
<DD>sici(x) returns in si the integral of the sinc function from 0 to x:
integral(sin(t)/t,t=0..x).  It returns in ci the cosine integral: eul + ln x +
integral((cos(t) - 1)/t,t=0..x).

<DT>y = spence(x)
<DD>spence(x) returns the dilogarithm integral: -integral(log t /
(t-1),t=1..x)


<DT>y = zeta(x,q)
<DD>zeta(x,q) returns the Riemann zeta function of two arguments:
sum((k+q)**(-x),k=0..inf)

<DT>y = zetac(x)
<DD>zetac(x) returns 1.0 - the Riemann zeta function: sum(k**(-x), k=2..inf)
</DL>

<h1> Convenience Functions </h1>
<DL>
<DT>y = cbrt(x)
<DD>cbrt(x) returns the real cube root of x. 

<DT>y = exp10(x)
<DD>exp10(x) returns 10 raised to the x power.

<DT>y = exp2(x)
<DD>exp2(x) returns 2 raised to the x power.

<DT>y = radian(d,m,s)
<DD>radian(d,m,s) returns the angle given in (d)egrees, (m)inutes, and
(s)econds in radians.

<DT>y = cosdg(x)
<DD>cosdg(x) calculates the cosine of the angle x given in degrees.

<DT>y = sindg(x)
<DD>sindg(x) calculates the sine of the angle x given in degrees.

<DT>y = tandg(x)
<DD>tandg(x) calculates the tangent of the angle x given in degrees.

<DT>y = cotdg(x)
<DD>cotdg(x) calculates the cotangent of the angle x given in degrees.

<DT>y = log1p(x)
<DD>log1p(x) calculates log(1+x) for use when x is near zero.

<DT>y = expm1(x)
<DD>expm1(x) calculates exp(x) - 1 for use when x is near zero.

<DT>y = cosm1(x)
<DD>calculates cos(x) - 1 for use when x is near zero.

<DT>y = round(x)
<DD>Returns the nearest integer to x as a double precision
floating point result.  If x ends in 0.5 exactly, the
nearest even integer is chosen.
</DL>















