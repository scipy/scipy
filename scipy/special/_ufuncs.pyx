# This file is automatically generated by generate_ufuncs.py.
# Do not edit manually!
include "_ufuncs_extra_code_common.pxi"
include "_ufuncs_extra_code.pxi"

cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) nogil>func)(<double complex>(<double complex*>ip0)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) nogil>func)(<double complex>(<float complex*>ip0)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_Dld__As_Dld_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, long, double) nogil>func)(<double complex>(<double complex*>ip0)[0], <long>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) nogil>func)(<double>(<double*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) nogil>func)(<double>(<float*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_dddd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddd__As_ffff_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_iidd__As_lldd_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double complex(*)(int, int, double, double) nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double complex>NPY_NAN
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_lD__As_lD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(long, double complex) nogil>func)(<long>(<long*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) nogil>func)(<double>(<double*>ip0)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) nogil>func)(<double>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_dddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd_d_As_ffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double *) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], <double>(<float*>ip5)[0], <double>(<float*>ip6)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddi_d_As_dddl_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef char *op1 = args[5]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        if <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, double, int, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <int>(<long*>ip3)[0], &ov1)
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NPY_NAN
            ov1 = <double>NPY_NAN
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
        op1 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddi_d_As_ddl_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0]:
            ov0 = (<double(*)(double, double, int, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], &ov1)
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NPY_NAN
            ov1 = <double>NPY_NAN
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0] and <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, int, int, double, double, double) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], <int>(<long*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NPY_NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_id__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<double(*)(int, double) nogil>func)(<int>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NPY_NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_iid__As_lld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0] and <int>(<long*>ip1)[0] == (<long*>ip1)[0]:
            ov0 = (<double(*)(int, int, double) nogil>func)(<int>(<long*>ip0)[0], <int>(<long*>ip1)[0], <double>(<double*>ip2)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NPY_NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ld__As_ld_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double) nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ldd__As_ldd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double) nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_lddd__As_lddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(long, double, double, double) nogil>func)(<long>(<long*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float) nogil>func)(<float>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_g_g__As_g_g(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef long double ov0
    for i in range(n):
        ov0 = (<long double(*)(long double) nogil>func)(<long double>(<long double*>ip0)[0])
        (<long double *>op0)[0] = <long double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_D_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DDDD_As_F_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *, double complex *, double complex *) nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_d_DDDD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        (<double complex *>op2)[0] = <double complex>ov2
        (<double complex *>op3)[0] = <double complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DDDD_As_f_FFFF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double complex ov0
    cdef double complex ov1
    cdef double complex ov2
    cdef double complex ov3
    for i in range(n):
        (<int(*)(double, double complex *, double complex *, double complex *, double complex *) nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        (<float complex *>op2)[0] = <float complex>ov2
        (<float complex *>op3)[0] = <float complex>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_d_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_DD_As_f_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double, double complex *, double complex *) nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_d_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dddd_As_f_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef char *op2 = args[3]
    cdef char *op3 = args[4]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double *, double *, double *, double *) nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
        op2 += steps[3]
        op3 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_dd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dd_As_ff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double *, double *) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_ddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddd_dd_As_fff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double *, double *) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_ddddd_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_ddddd_dd_As_fffff_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *op0 = args[5]
    cdef char *op1 = args[6]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double, double, double, double, double *, double *) nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        op0 += steps[5]
        op1 += steps[6]
    sf_error.check_fpe(func_name)

cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef int ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<int(*)(int) nogil>func)(<int>(<long*>ip0)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <int>0xbad0bad0
        (<long *>op0)[0] = <long>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

from _trig cimport dcospi as _func_dcospi
ctypedef double _proto_dcospi_t(double) nogil
cdef _proto_dcospi_t *_proto_dcospi_t_var = &_func_dcospi
from _trig cimport ccospi as _func_ccospi
ctypedef double complex _proto_ccospi_t(double complex) nogil
cdef _proto_ccospi_t *_proto_ccospi_t_var = &_func_ccospi
from _ellip_harm cimport ellip_harmonic as _func_ellip_harmonic
ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) nogil
cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &_func_ellip_harmonic
from _legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe
ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) nogil
cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &_func_ellip_harmonic_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_igam_fac "igam_fac"(double, double) nogil
from lambertw cimport lambertw_scalar as _func_lambertw_scalar
ctypedef double complex _proto_lambertw_scalar_t(double complex, long, double) nogil
cdef _proto_lambertw_scalar_t *_proto_lambertw_scalar_t_var = &_func_lambertw_scalar
cdef extern from "_ufuncs_defs.h":
    cdef double _func_lanczos_sum_expg_scaled "lanczos_sum_expg_scaled"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_lgam1p "lgam1p"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_log1pmx "log1pmx"(double) nogil
from sf_error cimport _sf_error_test_function as _func__sf_error_test_function
ctypedef int _proto__sf_error_test_function_t(int) nogil
cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &_func__sf_error_test_function
from _trig cimport dsinpi as _func_dsinpi
ctypedef double _proto_dsinpi_t(double) nogil
cdef _proto_dsinpi_t *_proto_dsinpi_t_var = &_func_dsinpi
from _trig cimport csinpi as _func_csinpi
ctypedef double complex _proto_csinpi_t(double complex) nogil
cdef _proto_csinpi_t *_proto_csinpi_t_var = &_func_csinpi
from _spherical_bessel cimport spherical_in_real as _func_spherical_in_real
ctypedef double _proto_spherical_in_real_t(long, double) nogil
cdef _proto_spherical_in_real_t *_proto_spherical_in_real_t_var = &_func_spherical_in_real
from _spherical_bessel cimport spherical_in_complex as _func_spherical_in_complex
ctypedef double complex _proto_spherical_in_complex_t(long, double complex) nogil
cdef _proto_spherical_in_complex_t *_proto_spherical_in_complex_t_var = &_func_spherical_in_complex
from _spherical_bessel cimport spherical_in_d_real as _func_spherical_in_d_real
ctypedef double _proto_spherical_in_d_real_t(long, double) nogil
cdef _proto_spherical_in_d_real_t *_proto_spherical_in_d_real_t_var = &_func_spherical_in_d_real
from _spherical_bessel cimport spherical_in_d_complex as _func_spherical_in_d_complex
ctypedef double complex _proto_spherical_in_d_complex_t(long, double complex) nogil
cdef _proto_spherical_in_d_complex_t *_proto_spherical_in_d_complex_t_var = &_func_spherical_in_d_complex
from _spherical_bessel cimport spherical_jn_real as _func_spherical_jn_real
ctypedef double _proto_spherical_jn_real_t(long, double) nogil
cdef _proto_spherical_jn_real_t *_proto_spherical_jn_real_t_var = &_func_spherical_jn_real
from _spherical_bessel cimport spherical_jn_complex as _func_spherical_jn_complex
ctypedef double complex _proto_spherical_jn_complex_t(long, double complex) nogil
cdef _proto_spherical_jn_complex_t *_proto_spherical_jn_complex_t_var = &_func_spherical_jn_complex
from _spherical_bessel cimport spherical_jn_d_real as _func_spherical_jn_d_real
ctypedef double _proto_spherical_jn_d_real_t(long, double) nogil
cdef _proto_spherical_jn_d_real_t *_proto_spherical_jn_d_real_t_var = &_func_spherical_jn_d_real
from _spherical_bessel cimport spherical_jn_d_complex as _func_spherical_jn_d_complex
ctypedef double complex _proto_spherical_jn_d_complex_t(long, double complex) nogil
cdef _proto_spherical_jn_d_complex_t *_proto_spherical_jn_d_complex_t_var = &_func_spherical_jn_d_complex
from _spherical_bessel cimport spherical_kn_real as _func_spherical_kn_real
ctypedef double _proto_spherical_kn_real_t(long, double) nogil
cdef _proto_spherical_kn_real_t *_proto_spherical_kn_real_t_var = &_func_spherical_kn_real
from _spherical_bessel cimport spherical_kn_complex as _func_spherical_kn_complex
ctypedef double complex _proto_spherical_kn_complex_t(long, double complex) nogil
cdef _proto_spherical_kn_complex_t *_proto_spherical_kn_complex_t_var = &_func_spherical_kn_complex
from _spherical_bessel cimport spherical_kn_d_real as _func_spherical_kn_d_real
ctypedef double _proto_spherical_kn_d_real_t(long, double) nogil
cdef _proto_spherical_kn_d_real_t *_proto_spherical_kn_d_real_t_var = &_func_spherical_kn_d_real
from _spherical_bessel cimport spherical_kn_d_complex as _func_spherical_kn_d_complex
ctypedef double complex _proto_spherical_kn_d_complex_t(long, double complex) nogil
cdef _proto_spherical_kn_d_complex_t *_proto_spherical_kn_d_complex_t_var = &_func_spherical_kn_d_complex
from _spherical_bessel cimport spherical_yn_real as _func_spherical_yn_real
ctypedef double _proto_spherical_yn_real_t(long, double) nogil
cdef _proto_spherical_yn_real_t *_proto_spherical_yn_real_t_var = &_func_spherical_yn_real
from _spherical_bessel cimport spherical_yn_complex as _func_spherical_yn_complex
ctypedef double complex _proto_spherical_yn_complex_t(long, double complex) nogil
cdef _proto_spherical_yn_complex_t *_proto_spherical_yn_complex_t_var = &_func_spherical_yn_complex
from _spherical_bessel cimport spherical_yn_d_real as _func_spherical_yn_d_real
ctypedef double _proto_spherical_yn_d_real_t(long, double) nogil
cdef _proto_spherical_yn_d_real_t *_proto_spherical_yn_d_real_t_var = &_func_spherical_yn_d_real
from _spherical_bessel cimport spherical_yn_d_complex as _func_spherical_yn_d_complex
ctypedef double complex _proto_spherical_yn_d_complex_t(long, double complex) nogil
cdef _proto_spherical_yn_d_complex_t *_proto_spherical_yn_d_complex_t_var = &_func_spherical_yn_d_complex
cdef extern from "_ufuncs_defs.h":
    cdef double _func_struve_asymp_large_z "struve_asymp_large_z"(double, double, int, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_struve_bessel_series "struve_bessel_series"(double, double, int, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_struve_power_series "struve_power_series"(double, double, int, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_zeta "zeta"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_airy_wrap "airy_wrap"(double, double *, double *, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_cairy_wrap "cairy_wrap"(double complex, double complex *, double complex *, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e_real "cairy_wrap_e_real"(double, double *, double *, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_cairy_wrap_e "cairy_wrap_e"(double complex, double complex *, double complex *, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_bdtr "bdtr"(int, int, double) nogil
from _legacy cimport bdtr_unsafe as _func_bdtr_unsafe
ctypedef double _proto_bdtr_unsafe_t(double, double, double) nogil
cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &_func_bdtr_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_bdtrc "bdtrc"(int, int, double) nogil
from _legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe
ctypedef double _proto_bdtrc_unsafe_t(double, double, double) nogil
cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &_func_bdtrc_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_bdtri "bdtri"(int, int, double) nogil
from _legacy cimport bdtri_unsafe as _func_bdtri_unsafe
ctypedef double _proto_bdtri_unsafe_t(double, double, double) nogil
cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &_func_bdtri_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfbin2_wrap "cdfbin2_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfbin3_wrap "cdfbin3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_bei_wrap "bei_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_beip_wrap "beip_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ber_wrap "ber_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_berp_wrap "berp_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_besselpoly "besselpoly"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_beta "beta"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_incbet "incbet"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_incbi "incbi"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_lbeta "lbeta"(double, double) nogil
from orthogonal_eval cimport binom as _func_binom
ctypedef double _proto_binom_t(double, double) nogil
cdef _proto_binom_t *_proto_binom_t_var = &_func_binom
from _boxcox cimport boxcox as _func_boxcox
ctypedef double _proto_boxcox_t(double, double) nogil
cdef _proto_boxcox_t *_proto_boxcox_t_var = &_func_boxcox
from _boxcox cimport boxcox1p as _func_boxcox1p
ctypedef double _proto_boxcox1p_t(double, double) nogil
cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &_func_boxcox1p
cdef extern from "_ufuncs_defs.h":
    cdef double _func_btdtr "btdtr"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_incbi "incbi"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfbet3_wrap "cdfbet3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfbet4_wrap "cdfbet4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbrt "cbrt"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_chdtr "chdtr"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_chdtrc "chdtrc"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_chdtri "chdtri"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfchi3_wrap "cdfchi3_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfchn1_wrap "cdfchn1_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfchn3_wrap "cdfchn3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfchn4_wrap "cdfchn4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfchn2_wrap "cdfchn2_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cosdg "cosdg"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cosm1 "cosm1"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cotdg "cotdg"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ellpe "ellpe"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ellie "ellie"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_ellpj "ellpj"(double, double, double *, double *, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ellik "ellik"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ellpk "ellpk"(double) nogil
from _convex_analysis cimport entr as _func_entr
ctypedef double _proto_entr_t(double) nogil
cdef _proto_entr_t *_proto_entr_t_var = &_func_entr
cdef extern from "_ufuncs_defs.h":
    cdef double _func_erf "erf"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_erfc "erfc"(double) nogil
from orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double _proto_eval_chebyc_double__t(double, double) nogil
cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &_func_eval_chebyc[double]
from orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) nogil
cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &_func_eval_chebyc[double_complex]
from orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l
ctypedef double _proto_eval_chebyc_l_t(long, double) nogil
cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &_func_eval_chebyc_l
from orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double _proto_eval_chebys_double__t(double, double) nogil
cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &_func_eval_chebys[double]
from orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) nogil
cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &_func_eval_chebys[double_complex]
from orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l
ctypedef double _proto_eval_chebys_l_t(long, double) nogil
cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &_func_eval_chebys_l
from orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double _proto_eval_chebyt_double__t(double, double) nogil
cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &_func_eval_chebyt[double]
from orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) nogil
cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &_func_eval_chebyt[double_complex]
from orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l
ctypedef double _proto_eval_chebyt_l_t(long, double) nogil
cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &_func_eval_chebyt_l
from orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double _proto_eval_chebyu_double__t(double, double) nogil
cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &_func_eval_chebyu[double]
from orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) nogil
cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &_func_eval_chebyu[double_complex]
from orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l
ctypedef double _proto_eval_chebyu_l_t(long, double) nogil
cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &_func_eval_chebyu_l
from orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) nogil
cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &_func_eval_gegenbauer[double]
from orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) nogil
cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &_func_eval_gegenbauer[double_complex]
from orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l
ctypedef double _proto_eval_gegenbauer_l_t(long, double, double) nogil
cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &_func_eval_gegenbauer_l
from orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) nogil
cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &_func_eval_genlaguerre[double]
from orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) nogil
cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &_func_eval_genlaguerre[double_complex]
from orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l
ctypedef double _proto_eval_genlaguerre_l_t(long, double, double) nogil
cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &_func_eval_genlaguerre_l
from orthogonal_eval cimport eval_hermite as _func_eval_hermite
ctypedef double _proto_eval_hermite_t(long, double) nogil
cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &_func_eval_hermite
from orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm
ctypedef double _proto_eval_hermitenorm_t(long, double) nogil
cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &_func_eval_hermitenorm
from orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) nogil
cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &_func_eval_jacobi[double]
from orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) nogil
cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &_func_eval_jacobi[double_complex]
from orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l
ctypedef double _proto_eval_jacobi_l_t(long, double, double, double) nogil
cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &_func_eval_jacobi_l
from orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double _proto_eval_laguerre_double__t(double, double) nogil
cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &_func_eval_laguerre[double]
from orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) nogil
cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &_func_eval_laguerre[double_complex]
from orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l
ctypedef double _proto_eval_laguerre_l_t(long, double) nogil
cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &_func_eval_laguerre_l
from orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double _proto_eval_legendre_double__t(double, double) nogil
cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &_func_eval_legendre[double]
from orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) nogil
cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &_func_eval_legendre[double_complex]
from orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l
ctypedef double _proto_eval_legendre_l_t(long, double) nogil
cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &_func_eval_legendre_l
from orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double _proto_eval_sh_chebyt_double__t(double, double) nogil
cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &_func_eval_sh_chebyt[double]
from orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) nogil
cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &_func_eval_sh_chebyt[double_complex]
from orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l
ctypedef double _proto_eval_sh_chebyt_l_t(long, double) nogil
cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &_func_eval_sh_chebyt_l
from orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double _proto_eval_sh_chebyu_double__t(double, double) nogil
cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &_func_eval_sh_chebyu[double]
from orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) nogil
cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &_func_eval_sh_chebyu[double_complex]
from orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l
ctypedef double _proto_eval_sh_chebyu_l_t(long, double) nogil
cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &_func_eval_sh_chebyu_l
from orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) nogil
cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &_func_eval_sh_jacobi[double]
from orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) nogil
cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &_func_eval_sh_jacobi[double_complex]
from orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l
ctypedef double _proto_eval_sh_jacobi_l_t(long, double, double, double) nogil
cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &_func_eval_sh_jacobi_l
from orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double _proto_eval_sh_legendre_double__t(double, double) nogil
cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &_func_eval_sh_legendre[double]
from orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) nogil
cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &_func_eval_sh_legendre[double_complex]
from orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l
ctypedef double _proto_eval_sh_legendre_l_t(long, double) nogil
cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &_func_eval_sh_legendre_l
cdef extern from "_ufuncs_defs.h":
    cdef double _func_exp1_wrap "exp1_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cexp1_wrap "cexp1_wrap"(double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_exp10 "exp10"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_exp2 "exp2"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_expi_wrap "expi_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cexpi_wrap "cexpi_wrap"(double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef float _func_expitf "expitf"(float) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_expit "expit"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef long double _func_expitl "expitl"(long double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_expm1 "expm1"(double) nogil
from _cunity cimport cexpm1 as _func_cexpm1
ctypedef double complex _proto_cexpm1_t(double complex) nogil
cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &_func_cexpm1
cdef extern from "_ufuncs_defs.h":
    cdef double _func_expn "expn"(int, double) nogil
from _legacy cimport expn_unsafe as _func_expn_unsafe
ctypedef double _proto_expn_unsafe_t(double, double) nogil
cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &_func_expn_unsafe
from _exprel cimport exprel as _func_exprel
ctypedef double _proto_exprel_t(double) nogil
cdef _proto_exprel_t *_proto_exprel_t_var = &_func_exprel
cdef extern from "_ufuncs_defs.h":
    cdef double _func_fdtr "fdtr"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_fdtrc "fdtrc"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_fdtri "fdtri"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdff4_wrap "cdff4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_fresnl "fresnl"(double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_cfresnl_wrap "cfresnl_wrap"(double complex, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_Gamma "Gamma"(double) nogil
from _loggamma cimport cgamma as _func_cgamma
ctypedef double complex _proto_cgamma_t(double complex) nogil
cdef _proto_cgamma_t *_proto_cgamma_t_var = &_func_cgamma
cdef extern from "_ufuncs_defs.h":
    cdef double _func_igam "igam"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_igamc "igamc"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_igami "igami"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_gammaincinv "gammaincinv"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_lgam "lgam"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_gammasgn "gammasgn"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_gdtr "gdtr"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_gdtrc "gdtrc"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfgam4_wrap "cdfgam4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfgam3_wrap "cdfgam3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfgam2_wrap "cdfgam2_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1 "cbesh_wrap1"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap1_e "cbesh_wrap1_e"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2 "cbesh_wrap2"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesh_wrap2_e "cbesh_wrap2_e"(double, double complex) nogil
from _convex_analysis cimport huber as _func_huber
ctypedef double _proto_huber_t(double, double) nogil
cdef _proto_huber_t *_proto_huber_t_var = &_func_huber
from _hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real
ctypedef double _proto__hyp0f1_real_t(double, double) nogil
cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &_func__hyp0f1_real
from _hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx
ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) nogil
cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &_func__hyp0f1_cmplx
cdef extern from "_ufuncs_defs.h":
    cdef double _func_hyp1f1_wrap "hyp1f1_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_chyp1f1_wrap "chyp1f1_wrap"(double, double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_onef2 "onef2"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_hyp2f0 "hyp2f0"(double, double, double, int, double *) nogil
from _legacy cimport hyp2f0_unsafe as _func_hyp2f0_unsafe
ctypedef double _proto_hyp2f0_unsafe_t(double, double, double, double, double *) nogil
cdef _proto_hyp2f0_unsafe_t *_proto_hyp2f0_unsafe_t_var = &_func_hyp2f0_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_hyp2f1 "hyp2f1"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_chyp2f1_wrap "chyp2f1_wrap"(double, double, double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_threef0 "threef0"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_hypU_wrap "hypU_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_i0 "i0"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_i0e "i0e"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_i1 "i1"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_i1e "i1e"(double) nogil
from _boxcox cimport inv_boxcox as _func_inv_boxcox
ctypedef double _proto_inv_boxcox_t(double, double) nogil
cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &_func_inv_boxcox
from _boxcox cimport inv_boxcox1p as _func_inv_boxcox1p
ctypedef double _proto_inv_boxcox1p_t(double, double) nogil
cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &_func_inv_boxcox1p
cdef extern from "_ufuncs_defs.h":
    cdef int _func_it2i0k0_wrap "it2i0k0_wrap"(double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_it2j0y0_wrap "it2j0y0_wrap"(double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_it2struve0_wrap "it2struve0_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_itairy_wrap "itairy_wrap"(double, double *, double *, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_it1i0k0_wrap "it1i0k0_wrap"(double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_it1j0y0_wrap "it1j0y0_wrap"(double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_itmodstruve0_wrap "itmodstruve0_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_itstruve0_wrap "itstruve0_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_iv "iv"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap "cbesi_wrap"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesi_wrap_e_real "cbesi_wrap_e_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesi_wrap_e "cbesi_wrap_e"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_j0 "j0"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_j1 "j1"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_real "cbesj_wrap_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap "cbesj_wrap"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesj_wrap_e_real "cbesj_wrap_e_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesj_wrap_e "cbesj_wrap_e"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_k0 "k0"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_k0e "k0e"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_k1 "k1"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_k1e "k1e"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_kei_wrap "kei_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_keip_wrap "keip_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_kelvin_wrap "kelvin_wrap"(double, double complex *, double complex *, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ker_wrap "ker_wrap"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_kerp_wrap "kerp_wrap"(double) nogil
from _convex_analysis cimport kl_div as _func_kl_div
ctypedef double _proto_kl_div_t(double, double) nogil
cdef _proto_kl_div_t *_proto_kl_div_t_var = &_func_kl_div
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real_int "cbesk_wrap_real_int"(int, double) nogil
from _legacy cimport kn_unsafe as _func_kn_unsafe
ctypedef double _proto_kn_unsafe_t(double, double) nogil
cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &_func_kn_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_kolmogi "kolmogi"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_kolmogorov "kolmogorov"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_real "cbesk_wrap_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap "cbesk_wrap"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesk_wrap_e_real "cbesk_wrap_e_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesk_wrap_e "cbesk_wrap_e"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_log1p "log1p"(double) nogil
from _cunity cimport clog1p as _func_clog1p
ctypedef double complex _proto_clog1p_t(double complex) nogil
cdef _proto_clog1p_t *_proto_clog1p_t_var = &_func_clog1p
cdef extern from "_ufuncs_defs.h":
    cdef double _func_log_ndtr "log_ndtr"(double) nogil
from _loggamma cimport loggamma as _func_loggamma
ctypedef double complex _proto_loggamma_t(double complex) nogil
cdef _proto_loggamma_t *_proto_loggamma_t_var = &_func_loggamma
cdef extern from "_ufuncs_defs.h":
    cdef float _func_logitf "logitf"(float) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_logit "logit"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef long double _func_logitl "logitl"(long double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_pmv_wrap "pmv_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cem_cva_wrap "cem_cva_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_sem_cva_wrap "sem_cva_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_cem_wrap "cem_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_mcm1_wrap "mcm1_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_mcm2_wrap "mcm2_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_msm1_wrap "msm1_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_msm2_wrap "msm2_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_sem_wrap "sem_wrap"(double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_modified_fresnel_minus_wrap "modified_fresnel_minus_wrap"(double, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_modified_fresnel_plus_wrap "modified_fresnel_plus_wrap"(double, double complex *, double complex *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_struve_l "struve_l"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_nbdtr "nbdtr"(int, int, double) nogil
from _legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe
ctypedef double _proto_nbdtr_unsafe_t(double, double, double) nogil
cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &_func_nbdtr_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_nbdtrc "nbdtrc"(int, int, double) nogil
from _legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe
ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) nogil
cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &_func_nbdtrc_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_nbdtri "nbdtri"(int, int, double) nogil
from _legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe
ctypedef double _proto_nbdtri_unsafe_t(double, double, double) nogil
cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &_func_nbdtri_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfnbn2_wrap "cdfnbn2_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfnbn3_wrap "cdfnbn3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdffnc1_wrap "cdffnc1_wrap"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdffnc2_wrap "cdffnc2_wrap"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdffnc4_wrap "cdffnc4_wrap"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdffnc3_wrap "cdffnc3_wrap"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdffnc5_wrap "cdffnc5_wrap"(double, double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdftnc1_wrap "cdftnc1_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdftnc3_wrap "cdftnc3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdftnc4_wrap "cdftnc4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdftnc2_wrap "cdftnc2_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ndtr "ndtr"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_ndtri "ndtri"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfnor3_wrap "cdfnor3_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfnor4_wrap "cdfnor4_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_oblate_aswfa_nocv_wrap "oblate_aswfa_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_oblate_aswfa_wrap "oblate_aswfa_wrap"(double, double, double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_oblate_segv_wrap "oblate_segv_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_oblate_radial1_nocv_wrap "oblate_radial1_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_oblate_radial1_wrap "oblate_radial1_wrap"(double, double, double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_oblate_radial2_nocv_wrap "oblate_radial2_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_oblate_radial2_wrap "oblate_radial2_wrap"(double, double, double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_pbdv_wrap "pbdv_wrap"(double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_pbvv_wrap "pbvv_wrap"(double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_pbwa_wrap "pbwa_wrap"(double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_pdtr "pdtr"(int, double) nogil
from _legacy cimport pdtr_unsafe as _func_pdtr_unsafe
ctypedef double _proto_pdtr_unsafe_t(double, double) nogil
cdef _proto_pdtr_unsafe_t *_proto_pdtr_unsafe_t_var = &_func_pdtr_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_pdtrc "pdtrc"(int, double) nogil
from _legacy cimport pdtrc_unsafe as _func_pdtrc_unsafe
ctypedef double _proto_pdtrc_unsafe_t(double, double) nogil
cdef _proto_pdtrc_unsafe_t *_proto_pdtrc_unsafe_t_var = &_func_pdtrc_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_pdtri "pdtri"(int, double) nogil
from _legacy cimport pdtri_unsafe as _func_pdtri_unsafe
ctypedef double _proto_pdtri_unsafe_t(double, double) nogil
cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &_func_pdtri_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdfpoi2_wrap "cdfpoi2_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_poch "poch"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_prolate_aswfa_nocv_wrap "prolate_aswfa_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_prolate_aswfa_wrap "prolate_aswfa_wrap"(double, double, double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_prolate_segv_wrap "prolate_segv_wrap"(double, double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_prolate_radial1_nocv_wrap "prolate_radial1_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_prolate_radial1_wrap "prolate_radial1_wrap"(double, double, double, double, double, double *, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_prolate_radial2_nocv_wrap "prolate_radial2_nocv_wrap"(double, double, double, double, double *) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_prolate_radial2_wrap "prolate_radial2_wrap"(double, double, double, double, double, double *, double *) nogil
from _convex_analysis cimport pseudo_huber as _func_pseudo_huber
ctypedef double _proto_pseudo_huber_t(double, double) nogil
cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &_func_pseudo_huber
from _digamma cimport digamma as _func_digamma
ctypedef double _proto_digamma_t(double) nogil
cdef _proto_digamma_t *_proto_digamma_t_var = &_func_digamma
from _digamma cimport cdigamma as _func_cdigamma
ctypedef double complex _proto_cdigamma_t(double complex) nogil
cdef _proto_cdigamma_t *_proto_cdigamma_t_var = &_func_cdigamma
cdef extern from "_ufuncs_defs.h":
    cdef double _func_radian "radian"(double, double, double) nogil
from _convex_analysis cimport rel_entr as _func_rel_entr
ctypedef double _proto_rel_entr_t(double, double) nogil
cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &_func_rel_entr
cdef extern from "_ufuncs_defs.h":
    cdef double _func_rgamma "rgamma"(double) nogil
from _loggamma cimport crgamma as _func_crgamma
ctypedef double complex _proto_crgamma_t(double complex) nogil
cdef _proto_crgamma_t *_proto_crgamma_t_var = &_func_crgamma
cdef extern from "_ufuncs_defs.h":
    cdef double _func_round "round"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef int _func_shichi "shichi"(double, double *, double *) nogil
from _sici cimport cshichi as _func_cshichi
ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) nogil
cdef _proto_cshichi_t *_proto_cshichi_t_var = &_func_cshichi
cdef extern from "_ufuncs_defs.h":
    cdef int _func_sici "sici"(double, double *, double *) nogil
from _sici cimport csici as _func_csici
ctypedef int _proto_csici_t(double complex, double complex *, double complex *) nogil
cdef _proto_csici_t *_proto_csici_t_var = &_func_csici
cdef extern from "_ufuncs_defs.h":
    cdef double _func_sindg "sindg"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_smirnov "smirnov"(int, double) nogil
from _legacy cimport smirnov_unsafe as _func_smirnov_unsafe
ctypedef double _proto_smirnov_unsafe_t(double, double) nogil
cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &_func_smirnov_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_smirnovi "smirnovi"(int, double) nogil
from _legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe
ctypedef double _proto_smirnovi_unsafe_t(double, double) nogil
cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &_func_smirnovi_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_smirnovp "smirnovp"(int, double) nogil
from _legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe
ctypedef double _proto_smirnovp_unsafe_t(double, double) nogil
cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &_func_smirnovp_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_spence "spence"(double) nogil
from _spence cimport cspence as _func_cspence
ctypedef double complex _proto_cspence_t(double complex) nogil
cdef _proto_cspence_t *_proto_cspence_t_var = &_func_cspence
from sph_harm cimport sph_harmonic as _func_sph_harmonic
ctypedef double complex _proto_sph_harmonic_t(int, int, double, double) nogil
cdef _proto_sph_harmonic_t *_proto_sph_harmonic_t_var = &_func_sph_harmonic
from _legacy cimport sph_harmonic_unsafe as _func_sph_harmonic_unsafe
ctypedef double complex _proto_sph_harmonic_unsafe_t(double, double, double, double) nogil
cdef _proto_sph_harmonic_unsafe_t *_proto_sph_harmonic_unsafe_t_var = &_func_sph_harmonic_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdft1_wrap "cdft1_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdft3_wrap "cdft3_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cdft2_wrap "cdft2_wrap"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_struve_h "struve_h"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_tandg "tandg"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_tukeylambdacdf "tukeylambdacdf"(double, double) nogil
from _xlogy cimport xlog1py as _func_xlog1py
ctypedef double _proto_xlog1py_double__t(double, double) nogil
cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &_func_xlog1py[double]
from _xlogy cimport xlog1py as _func_xlog1py
ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) nogil
cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &_func_xlog1py[double_complex]
from _xlogy cimport xlogy as _func_xlogy
ctypedef double _proto_xlogy_double__t(double, double) nogil
cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &_func_xlogy[double]
from _xlogy cimport xlogy as _func_xlogy
ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) nogil
cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &_func_xlogy[double_complex]
cdef extern from "_ufuncs_defs.h":
    cdef double _func_y0 "y0"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_y1 "y1"(double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_yn "yn"(int, double) nogil
from _legacy cimport yn_unsafe as _func_yn_unsafe
ctypedef double _proto_yn_unsafe_t(double, double) nogil
cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &_func_yn_unsafe
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_real "cbesy_wrap_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap "cbesy_wrap"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_cbesy_wrap_e_real "cbesy_wrap_e_real"(double, double) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double complex _func_cbesy_wrap_e "cbesy_wrap_e"(double, double complex) nogil
cdef extern from "_ufuncs_defs.h":
    cdef double _func_zetac "zetac"(double) nogil
cdef np.PyUFuncGenericFunction ufunc__cospi_loops[4]
cdef void *ufunc__cospi_ptr[8]
cdef void *ufunc__cospi_data[4]
cdef char ufunc__cospi_types[8]
cdef char *ufunc__cospi_doc = (
    "Internal function, do not use.")
ufunc__cospi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cospi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cospi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__cospi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__cospi_types[0] = <char>NPY_FLOAT
ufunc__cospi_types[1] = <char>NPY_FLOAT
ufunc__cospi_types[2] = <char>NPY_DOUBLE
ufunc__cospi_types[3] = <char>NPY_DOUBLE
ufunc__cospi_types[4] = <char>NPY_CFLOAT
ufunc__cospi_types[5] = <char>NPY_CFLOAT
ufunc__cospi_types[6] = <char>NPY_CDOUBLE
ufunc__cospi_types[7] = <char>NPY_CDOUBLE
ufunc__cospi_ptr[2*0] = <void*>_func_dcospi
ufunc__cospi_ptr[2*0+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*1] = <void*>_func_dcospi
ufunc__cospi_ptr[2*1+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*2] = <void*>_func_ccospi
ufunc__cospi_ptr[2*2+1] = <void*>(<char*>"_cospi")
ufunc__cospi_ptr[2*3] = <void*>_func_ccospi
ufunc__cospi_ptr[2*3+1] = <void*>(<char*>"_cospi")
ufunc__cospi_data[0] = &ufunc__cospi_ptr[2*0]
ufunc__cospi_data[1] = &ufunc__cospi_ptr[2*1]
ufunc__cospi_data[2] = &ufunc__cospi_ptr[2*2]
ufunc__cospi_data[3] = &ufunc__cospi_ptr[2*3]
_cospi = np.PyUFunc_FromFuncAndData(ufunc__cospi_loops, ufunc__cospi_data, ufunc__cospi_types, 4, 1, 1, 0, "_cospi", ufunc__cospi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]
cdef void *ufunc__ellip_harm_ptr[6]
cdef void *ufunc__ellip_harm_data[3]
cdef char ufunc__ellip_harm_types[24]
cdef char *ufunc__ellip_harm_doc = (
    "Internal function, use `ellip_harm` instead.")
ufunc__ellip_harm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_fffffff_f
ufunc__ellip_harm_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddiiddd__As_ddllddd_d
ufunc__ellip_harm_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_ddddddd_d
ufunc__ellip_harm_types[0] = <char>NPY_FLOAT
ufunc__ellip_harm_types[1] = <char>NPY_FLOAT
ufunc__ellip_harm_types[2] = <char>NPY_FLOAT
ufunc__ellip_harm_types[3] = <char>NPY_FLOAT
ufunc__ellip_harm_types[4] = <char>NPY_FLOAT
ufunc__ellip_harm_types[5] = <char>NPY_FLOAT
ufunc__ellip_harm_types[6] = <char>NPY_FLOAT
ufunc__ellip_harm_types[7] = <char>NPY_FLOAT
ufunc__ellip_harm_types[8] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[9] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[10] = <char>NPY_LONG
ufunc__ellip_harm_types[11] = <char>NPY_LONG
ufunc__ellip_harm_types[12] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[13] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[14] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[15] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[16] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[17] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[18] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[19] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[20] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[21] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[22] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[23] = <char>NPY_DOUBLE
ufunc__ellip_harm_ptr[2*0] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*0+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*1] = <void*>_func_ellip_harmonic
ufunc__ellip_harm_ptr[2*1+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*2] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*2+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_data[0] = &ufunc__ellip_harm_ptr[2*0]
ufunc__ellip_harm_data[1] = &ufunc__ellip_harm_ptr[2*1]
ufunc__ellip_harm_data[2] = &ufunc__ellip_harm_ptr[2*2]
_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, "_ellip_harm", ufunc__ellip_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]
cdef void *ufunc__igam_fac_ptr[4]
cdef void *ufunc__igam_fac_data[2]
cdef char ufunc__igam_fac_types[6]
cdef char *ufunc__igam_fac_doc = (
    "Internal function, do not use.")
ufunc__igam_fac_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__igam_fac_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__igam_fac_types[0] = <char>NPY_FLOAT
ufunc__igam_fac_types[1] = <char>NPY_FLOAT
ufunc__igam_fac_types[2] = <char>NPY_FLOAT
ufunc__igam_fac_types[3] = <char>NPY_DOUBLE
ufunc__igam_fac_types[4] = <char>NPY_DOUBLE
ufunc__igam_fac_types[5] = <char>NPY_DOUBLE
ufunc__igam_fac_ptr[2*0] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*0+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_ptr[2*1] = <void*>_func_igam_fac
ufunc__igam_fac_ptr[2*1+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_data[0] = &ufunc__igam_fac_ptr[2*0]
ufunc__igam_fac_data[1] = &ufunc__igam_fac_ptr[2*1]
_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, "_igam_fac", ufunc__igam_fac_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lambertw_loops[1]
cdef void *ufunc__lambertw_ptr[2]
cdef void *ufunc__lambertw_data[1]
cdef char ufunc__lambertw_types[4]
cdef char *ufunc__lambertw_doc = (
    "Internal function, use `lambertw` instead.")
ufunc__lambertw_loops[0] = <np.PyUFuncGenericFunction>loop_D_Dld__As_Dld_D
ufunc__lambertw_types[0] = <char>NPY_CDOUBLE
ufunc__lambertw_types[1] = <char>NPY_LONG
ufunc__lambertw_types[2] = <char>NPY_DOUBLE
ufunc__lambertw_types[3] = <char>NPY_CDOUBLE
ufunc__lambertw_ptr[2*0] = <void*>_func_lambertw_scalar
ufunc__lambertw_ptr[2*0+1] = <void*>(<char*>"_lambertw")
ufunc__lambertw_data[0] = &ufunc__lambertw_ptr[2*0]
_lambertw = np.PyUFunc_FromFuncAndData(ufunc__lambertw_loops, ufunc__lambertw_data, ufunc__lambertw_types, 1, 3, 1, 0, "_lambertw", ufunc__lambertw_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]
cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]
cdef void *ufunc__lanczos_sum_expg_scaled_data[2]
cdef char ufunc__lanczos_sum_expg_scaled_types[4]
cdef char *ufunc__lanczos_sum_expg_scaled_doc = (
    "Internal function, do not use.")
ufunc__lanczos_sum_expg_scaled_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lanczos_sum_expg_scaled_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lanczos_sum_expg_scaled_types[0] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[1] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[2] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_types[3] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_ptr[2*0] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_ptr[2*1] = <void*>_func_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_data[0] = &ufunc__lanczos_sum_expg_scaled_ptr[2*0]
ufunc__lanczos_sum_expg_scaled_data[1] = &ufunc__lanczos_sum_expg_scaled_ptr[2*1]
_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, "_lanczos_sum_expg_scaled", ufunc__lanczos_sum_expg_scaled_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]
cdef void *ufunc__lgam1p_ptr[4]
cdef void *ufunc__lgam1p_data[2]
cdef char ufunc__lgam1p_types[4]
cdef char *ufunc__lgam1p_doc = (
    "Internal function, do not use.")
ufunc__lgam1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lgam1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lgam1p_types[0] = <char>NPY_FLOAT
ufunc__lgam1p_types[1] = <char>NPY_FLOAT
ufunc__lgam1p_types[2] = <char>NPY_DOUBLE
ufunc__lgam1p_types[3] = <char>NPY_DOUBLE
ufunc__lgam1p_ptr[2*0] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*0+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_ptr[2*1] = <void*>_func_lgam1p
ufunc__lgam1p_ptr[2*1+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_data[0] = &ufunc__lgam1p_ptr[2*0]
ufunc__lgam1p_data[1] = &ufunc__lgam1p_ptr[2*1]
_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, "_lgam1p", ufunc__lgam1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]
cdef void *ufunc__log1pmx_ptr[4]
cdef void *ufunc__log1pmx_data[2]
cdef char ufunc__log1pmx_types[4]
cdef char *ufunc__log1pmx_doc = (
    "Internal function, do not use.")
ufunc__log1pmx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__log1pmx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__log1pmx_types[0] = <char>NPY_FLOAT
ufunc__log1pmx_types[1] = <char>NPY_FLOAT
ufunc__log1pmx_types[2] = <char>NPY_DOUBLE
ufunc__log1pmx_types[3] = <char>NPY_DOUBLE
ufunc__log1pmx_ptr[2*0] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*0+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_ptr[2*1] = <void*>_func_log1pmx
ufunc__log1pmx_ptr[2*1+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_data[0] = &ufunc__log1pmx_ptr[2*0]
ufunc__log1pmx_data[1] = &ufunc__log1pmx_ptr[2*1]
_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, "_log1pmx", ufunc__log1pmx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]
cdef void *ufunc__sf_error_test_function_ptr[2]
cdef void *ufunc__sf_error_test_function_data[1]
cdef char ufunc__sf_error_test_function_types[2]
cdef char *ufunc__sf_error_test_function_doc = (
    "Private function; do not use.")
ufunc__sf_error_test_function_loops[0] = <np.PyUFuncGenericFunction>loop_i_i__As_l_l
ufunc__sf_error_test_function_types[0] = <char>NPY_LONG
ufunc__sf_error_test_function_types[1] = <char>NPY_LONG
ufunc__sf_error_test_function_ptr[2*0] = <void*>_func__sf_error_test_function
ufunc__sf_error_test_function_ptr[2*0+1] = <void*>(<char*>"_sf_error_test_function")
ufunc__sf_error_test_function_data[0] = &ufunc__sf_error_test_function_ptr[2*0]
_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, "_sf_error_test_function", ufunc__sf_error_test_function_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sinpi_loops[4]
cdef void *ufunc__sinpi_ptr[8]
cdef void *ufunc__sinpi_data[4]
cdef char ufunc__sinpi_types[8]
cdef char *ufunc__sinpi_doc = (
    "Internal function, do not use.")
ufunc__sinpi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__sinpi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__sinpi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc__sinpi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc__sinpi_types[0] = <char>NPY_FLOAT
ufunc__sinpi_types[1] = <char>NPY_FLOAT
ufunc__sinpi_types[2] = <char>NPY_DOUBLE
ufunc__sinpi_types[3] = <char>NPY_DOUBLE
ufunc__sinpi_types[4] = <char>NPY_CFLOAT
ufunc__sinpi_types[5] = <char>NPY_CFLOAT
ufunc__sinpi_types[6] = <char>NPY_CDOUBLE
ufunc__sinpi_types[7] = <char>NPY_CDOUBLE
ufunc__sinpi_ptr[2*0] = <void*>_func_dsinpi
ufunc__sinpi_ptr[2*0+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*1] = <void*>_func_dsinpi
ufunc__sinpi_ptr[2*1+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*2] = <void*>_func_csinpi
ufunc__sinpi_ptr[2*2+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_ptr[2*3] = <void*>_func_csinpi
ufunc__sinpi_ptr[2*3+1] = <void*>(<char*>"_sinpi")
ufunc__sinpi_data[0] = &ufunc__sinpi_ptr[2*0]
ufunc__sinpi_data[1] = &ufunc__sinpi_ptr[2*1]
ufunc__sinpi_data[2] = &ufunc__sinpi_ptr[2*2]
ufunc__sinpi_data[3] = &ufunc__sinpi_ptr[2*3]
_sinpi = np.PyUFunc_FromFuncAndData(ufunc__sinpi_loops, ufunc__sinpi_data, ufunc__sinpi_types, 4, 1, 1, 0, "_sinpi", ufunc__sinpi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_loops[2]
cdef void *ufunc__spherical_in_ptr[4]
cdef void *ufunc__spherical_in_data[2]
cdef char ufunc__spherical_in_types[6]
cdef char *ufunc__spherical_in_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_types[0] = <char>NPY_LONG
ufunc__spherical_in_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_types[3] = <char>NPY_LONG
ufunc__spherical_in_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_ptr[2*0] = <void*>_func_spherical_in_real
ufunc__spherical_in_ptr[2*0+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_ptr[2*1] = <void*>_func_spherical_in_complex
ufunc__spherical_in_ptr[2*1+1] = <void*>(<char*>"_spherical_in")
ufunc__spherical_in_data[0] = &ufunc__spherical_in_ptr[2*0]
ufunc__spherical_in_data[1] = &ufunc__spherical_in_ptr[2*1]
_spherical_in = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_loops, ufunc__spherical_in_data, ufunc__spherical_in_types, 2, 2, 1, 0, "_spherical_in", ufunc__spherical_in_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_in_d_loops[2]
cdef void *ufunc__spherical_in_d_ptr[4]
cdef void *ufunc__spherical_in_d_data[2]
cdef char ufunc__spherical_in_d_types[6]
cdef char *ufunc__spherical_in_d_doc = (
    "Internal function, use `spherical_in` instead.")
ufunc__spherical_in_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_in_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_in_d_types[0] = <char>NPY_LONG
ufunc__spherical_in_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_in_d_types[3] = <char>NPY_LONG
ufunc__spherical_in_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_in_d_ptr[2*0] = <void*>_func_spherical_in_d_real
ufunc__spherical_in_d_ptr[2*0+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_ptr[2*1] = <void*>_func_spherical_in_d_complex
ufunc__spherical_in_d_ptr[2*1+1] = <void*>(<char*>"_spherical_in_d")
ufunc__spherical_in_d_data[0] = &ufunc__spherical_in_d_ptr[2*0]
ufunc__spherical_in_d_data[1] = &ufunc__spherical_in_d_ptr[2*1]
_spherical_in_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_in_d_loops, ufunc__spherical_in_d_data, ufunc__spherical_in_d_types, 2, 2, 1, 0, "_spherical_in_d", ufunc__spherical_in_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_loops[2]
cdef void *ufunc__spherical_jn_ptr[4]
cdef void *ufunc__spherical_jn_data[2]
cdef char ufunc__spherical_jn_types[6]
cdef char *ufunc__spherical_jn_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_types[0] = <char>NPY_LONG
ufunc__spherical_jn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_types[3] = <char>NPY_LONG
ufunc__spherical_jn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_ptr[2*0] = <void*>_func_spherical_jn_real
ufunc__spherical_jn_ptr[2*0+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_ptr[2*1] = <void*>_func_spherical_jn_complex
ufunc__spherical_jn_ptr[2*1+1] = <void*>(<char*>"_spherical_jn")
ufunc__spherical_jn_data[0] = &ufunc__spherical_jn_ptr[2*0]
ufunc__spherical_jn_data[1] = &ufunc__spherical_jn_ptr[2*1]
_spherical_jn = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_loops, ufunc__spherical_jn_data, ufunc__spherical_jn_types, 2, 2, 1, 0, "_spherical_jn", ufunc__spherical_jn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_jn_d_loops[2]
cdef void *ufunc__spherical_jn_d_ptr[4]
cdef void *ufunc__spherical_jn_d_data[2]
cdef char ufunc__spherical_jn_d_types[6]
cdef char *ufunc__spherical_jn_d_doc = (
    "Internal function, use `spherical_jn` instead.")
ufunc__spherical_jn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_jn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_jn_d_types[0] = <char>NPY_LONG
ufunc__spherical_jn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_jn_d_types[3] = <char>NPY_LONG
ufunc__spherical_jn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_jn_d_ptr[2*0] = <void*>_func_spherical_jn_d_real
ufunc__spherical_jn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_ptr[2*1] = <void*>_func_spherical_jn_d_complex
ufunc__spherical_jn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_jn_d")
ufunc__spherical_jn_d_data[0] = &ufunc__spherical_jn_d_ptr[2*0]
ufunc__spherical_jn_d_data[1] = &ufunc__spherical_jn_d_ptr[2*1]
_spherical_jn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_jn_d_loops, ufunc__spherical_jn_d_data, ufunc__spherical_jn_d_types, 2, 2, 1, 0, "_spherical_jn_d", ufunc__spherical_jn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_loops[2]
cdef void *ufunc__spherical_kn_ptr[4]
cdef void *ufunc__spherical_kn_data[2]
cdef char ufunc__spherical_kn_types[6]
cdef char *ufunc__spherical_kn_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_types[0] = <char>NPY_LONG
ufunc__spherical_kn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_types[3] = <char>NPY_LONG
ufunc__spherical_kn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_ptr[2*0] = <void*>_func_spherical_kn_real
ufunc__spherical_kn_ptr[2*0+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_ptr[2*1] = <void*>_func_spherical_kn_complex
ufunc__spherical_kn_ptr[2*1+1] = <void*>(<char*>"_spherical_kn")
ufunc__spherical_kn_data[0] = &ufunc__spherical_kn_ptr[2*0]
ufunc__spherical_kn_data[1] = &ufunc__spherical_kn_ptr[2*1]
_spherical_kn = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_loops, ufunc__spherical_kn_data, ufunc__spherical_kn_types, 2, 2, 1, 0, "_spherical_kn", ufunc__spherical_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_kn_d_loops[2]
cdef void *ufunc__spherical_kn_d_ptr[4]
cdef void *ufunc__spherical_kn_d_data[2]
cdef char ufunc__spherical_kn_d_types[6]
cdef char *ufunc__spherical_kn_d_doc = (
    "Internal function, use `spherical_kn` instead.")
ufunc__spherical_kn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_kn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_kn_d_types[0] = <char>NPY_LONG
ufunc__spherical_kn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_kn_d_types[3] = <char>NPY_LONG
ufunc__spherical_kn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_kn_d_ptr[2*0] = <void*>_func_spherical_kn_d_real
ufunc__spherical_kn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_ptr[2*1] = <void*>_func_spherical_kn_d_complex
ufunc__spherical_kn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_kn_d")
ufunc__spherical_kn_d_data[0] = &ufunc__spherical_kn_d_ptr[2*0]
ufunc__spherical_kn_d_data[1] = &ufunc__spherical_kn_d_ptr[2*1]
_spherical_kn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_kn_d_loops, ufunc__spherical_kn_d_data, ufunc__spherical_kn_d_types, 2, 2, 1, 0, "_spherical_kn_d", ufunc__spherical_kn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_loops[2]
cdef void *ufunc__spherical_yn_ptr[4]
cdef void *ufunc__spherical_yn_data[2]
cdef char ufunc__spherical_yn_types[6]
cdef char *ufunc__spherical_yn_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_types[0] = <char>NPY_LONG
ufunc__spherical_yn_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_types[3] = <char>NPY_LONG
ufunc__spherical_yn_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_ptr[2*0] = <void*>_func_spherical_yn_real
ufunc__spherical_yn_ptr[2*0+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_ptr[2*1] = <void*>_func_spherical_yn_complex
ufunc__spherical_yn_ptr[2*1+1] = <void*>(<char*>"_spherical_yn")
ufunc__spherical_yn_data[0] = &ufunc__spherical_yn_ptr[2*0]
ufunc__spherical_yn_data[1] = &ufunc__spherical_yn_ptr[2*1]
_spherical_yn = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_loops, ufunc__spherical_yn_data, ufunc__spherical_yn_types, 2, 2, 1, 0, "_spherical_yn", ufunc__spherical_yn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__spherical_yn_d_loops[2]
cdef void *ufunc__spherical_yn_d_ptr[4]
cdef void *ufunc__spherical_yn_d_data[2]
cdef char ufunc__spherical_yn_d_types[6]
cdef char *ufunc__spherical_yn_d_doc = (
    "Internal function, use `spherical_yn` instead.")
ufunc__spherical_yn_d_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc__spherical_yn_d_loops[1] = <np.PyUFuncGenericFunction>loop_D_lD__As_lD_D
ufunc__spherical_yn_d_types[0] = <char>NPY_LONG
ufunc__spherical_yn_d_types[1] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[2] = <char>NPY_DOUBLE
ufunc__spherical_yn_d_types[3] = <char>NPY_LONG
ufunc__spherical_yn_d_types[4] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_types[5] = <char>NPY_CDOUBLE
ufunc__spherical_yn_d_ptr[2*0] = <void*>_func_spherical_yn_d_real
ufunc__spherical_yn_d_ptr[2*0+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_ptr[2*1] = <void*>_func_spherical_yn_d_complex
ufunc__spherical_yn_d_ptr[2*1+1] = <void*>(<char*>"_spherical_yn_d")
ufunc__spherical_yn_d_data[0] = &ufunc__spherical_yn_d_ptr[2*0]
ufunc__spherical_yn_d_data[1] = &ufunc__spherical_yn_d_ptr[2*1]
_spherical_yn_d = np.PyUFunc_FromFuncAndData(ufunc__spherical_yn_d_loops, ufunc__spherical_yn_d_data, ufunc__spherical_yn_d_types, 2, 2, 1, 0, "_spherical_yn_d", ufunc__spherical_yn_d_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]
cdef void *ufunc__struve_asymp_large_z_ptr[2]
cdef void *ufunc__struve_asymp_large_z_data[1]
cdef char ufunc__struve_asymp_large_z_types[5]
cdef char *ufunc__struve_asymp_large_z_doc = (
    "_struve_asymp_large_z(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using asymptotic expansion\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_asymp_large_z_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_asymp_large_z_types[0] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[1] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[2] = <char>NPY_LONG
ufunc__struve_asymp_large_z_types[3] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[4] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_ptr[2*0] = <void*>_func_struve_asymp_large_z
ufunc__struve_asymp_large_z_ptr[2*0+1] = <void*>(<char*>"_struve_asymp_large_z")
ufunc__struve_asymp_large_z_data[0] = &ufunc__struve_asymp_large_z_ptr[2*0]
_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, "_struve_asymp_large_z", ufunc__struve_asymp_large_z_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]
cdef void *ufunc__struve_bessel_series_ptr[2]
cdef void *ufunc__struve_bessel_series_data[1]
cdef char ufunc__struve_bessel_series_types[5]
cdef char *ufunc__struve_bessel_series_doc = (
    "_struve_bessel_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using Bessel function series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_bessel_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_bessel_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[2] = <char>NPY_LONG
ufunc__struve_bessel_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_ptr[2*0] = <void*>_func_struve_bessel_series
ufunc__struve_bessel_series_ptr[2*0+1] = <void*>(<char*>"_struve_bessel_series")
ufunc__struve_bessel_series_data[0] = &ufunc__struve_bessel_series_ptr[2*0]
_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, "_struve_bessel_series", ufunc__struve_bessel_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]
cdef void *ufunc__struve_power_series_ptr[2]
cdef void *ufunc__struve_power_series_data[1]
cdef char ufunc__struve_power_series_types[5]
cdef char *ufunc__struve_power_series_doc = (
    "_struve_power_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using power series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_power_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddi_d_As_ddl_dd
ufunc__struve_power_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[2] = <char>NPY_LONG
ufunc__struve_power_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_power_series_ptr[2*0] = <void*>_func_struve_power_series
ufunc__struve_power_series_ptr[2*0+1] = <void*>(<char*>"_struve_power_series")
ufunc__struve_power_series_data[0] = &ufunc__struve_power_series_ptr[2*0]
_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, "_struve_power_series", ufunc__struve_power_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__zeta_loops[2]
cdef void *ufunc__zeta_ptr[4]
cdef void *ufunc__zeta_data[2]
cdef char ufunc__zeta_types[6]
cdef char *ufunc__zeta_doc = (
    "_zeta(x, q)\n"
    "\n"
    "Internal function, Hurwitz zeta.")
ufunc__zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__zeta_types[0] = <char>NPY_FLOAT
ufunc__zeta_types[1] = <char>NPY_FLOAT
ufunc__zeta_types[2] = <char>NPY_FLOAT
ufunc__zeta_types[3] = <char>NPY_DOUBLE
ufunc__zeta_types[4] = <char>NPY_DOUBLE
ufunc__zeta_types[5] = <char>NPY_DOUBLE
ufunc__zeta_ptr[2*0] = <void*>_func_zeta
ufunc__zeta_ptr[2*0+1] = <void*>(<char*>"_zeta")
ufunc__zeta_ptr[2*1] = <void*>_func_zeta
ufunc__zeta_ptr[2*1+1] = <void*>(<char*>"_zeta")
ufunc__zeta_data[0] = &ufunc__zeta_ptr[2*0]
ufunc__zeta_data[1] = &ufunc__zeta_ptr[2*1]
_zeta = np.PyUFunc_FromFuncAndData(ufunc__zeta_loops, ufunc__zeta_data, ufunc__zeta_types, 2, 2, 1, 0, "_zeta", ufunc__zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airy_loops[4]
cdef void *ufunc_airy_ptr[8]
cdef void *ufunc_airy_data[4]
cdef char ufunc_airy_types[20]
cdef char *ufunc_airy_doc = (
    "airy(z)\n"
    "\n"
    "Airy functions and their derivatives.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Ai, Aip, Bi, Bip : ndarrays\n"
    "    Airy functions Ai and Bi, and their derivatives Aip and Bip.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The Airy functions Ai and Bi are two independent solutions of\n"
    "\n"
    ".. math:: y''(x) = x y(x).\n"
    "\n"
    "For real `z` in [-10, 10], the computation is carried out by calling\n"
    "the Cephes [1]_ `airy` routine, which uses power series summation\n"
    "for small `z` and rational minimax approximations for large `z`.\n"
    "\n"
    "Outside this range, the AMOS [2]_ `zairy` and `zbiry` routines are\n"
    "employed.  They are computed using power series for :math:`|z| < 1` and\n"
    "the following relations to modified Bessel functions for larger `z`\n"
    "(where :math:`t \\equiv 2 z^{3/2}/3`):\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Ai(z) = \\frac{1}{\\pi \\sqrt{3}} K_{1/3}(t)\n"
    "\n"
    "    Ai'(z) = -\\frac{z}{\\pi \\sqrt{3}} K_{2/3}(t)\n"
    "\n"
    "    Bi(z) = \\sqrt{\\frac{z}{3}} \\left(I_{-1/3}(t) + I_{1/3}(t) \\right)\n"
    "\n"
    "    Bi'(z) = \\frac{z}{\\sqrt{3}} \\left(I_{-2/3}(t) + I_{2/3}(t)\\right)\n"
    "\n"
    "See also\n"
    "--------\n"
    "airye : exponentially scaled Airy functions.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/.org/amos/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Compute the Airy functions on the interval [-15, 5].\n"
    "\n"
    ">>> from scipy import special\n"
    ">>> x = np.linspace(-15, 5, 201)\n"
    ">>> ai, aip, bi, bip = special.airy(x)\n"
    "\n"
    "Plot Ai(x) and Bi(x).\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.plot(x, ai, 'r', label='Ai(x)')\n"
    ">>> plt.plot(x, bi, 'b--', label='Bi(x)')\n"
    ">>> plt.ylim(-0.5, 1.0)\n"
    ">>> plt.grid()\n"
    ">>> plt.legend(loc='upper left')\n"
    ">>> plt.show()")
ufunc_airy_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airy_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airy_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airy_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airy_types[0] = <char>NPY_FLOAT
ufunc_airy_types[1] = <char>NPY_FLOAT
ufunc_airy_types[2] = <char>NPY_FLOAT
ufunc_airy_types[3] = <char>NPY_FLOAT
ufunc_airy_types[4] = <char>NPY_FLOAT
ufunc_airy_types[5] = <char>NPY_DOUBLE
ufunc_airy_types[6] = <char>NPY_DOUBLE
ufunc_airy_types[7] = <char>NPY_DOUBLE
ufunc_airy_types[8] = <char>NPY_DOUBLE
ufunc_airy_types[9] = <char>NPY_DOUBLE
ufunc_airy_types[10] = <char>NPY_CFLOAT
ufunc_airy_types[11] = <char>NPY_CFLOAT
ufunc_airy_types[12] = <char>NPY_CFLOAT
ufunc_airy_types[13] = <char>NPY_CFLOAT
ufunc_airy_types[14] = <char>NPY_CFLOAT
ufunc_airy_types[15] = <char>NPY_CDOUBLE
ufunc_airy_types[16] = <char>NPY_CDOUBLE
ufunc_airy_types[17] = <char>NPY_CDOUBLE
ufunc_airy_types[18] = <char>NPY_CDOUBLE
ufunc_airy_types[19] = <char>NPY_CDOUBLE
ufunc_airy_ptr[2*0] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*0+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*1] = <void*>_func_airy_wrap
ufunc_airy_ptr[2*1+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*2] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*2+1] = <void*>(<char*>"airy")
ufunc_airy_ptr[2*3] = <void*>_func_cairy_wrap
ufunc_airy_ptr[2*3+1] = <void*>(<char*>"airy")
ufunc_airy_data[0] = &ufunc_airy_ptr[2*0]
ufunc_airy_data[1] = &ufunc_airy_ptr[2*1]
ufunc_airy_data[2] = &ufunc_airy_ptr[2*2]
ufunc_airy_data[3] = &ufunc_airy_ptr[2*3]
airy = np.PyUFunc_FromFuncAndData(ufunc_airy_loops, ufunc_airy_data, ufunc_airy_types, 4, 1, 4, 0, "airy", ufunc_airy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_airye_loops[4]
cdef void *ufunc_airye_ptr[8]
cdef void *ufunc_airye_data[4]
cdef char ufunc_airye_types[20]
cdef char *ufunc_airye_doc = (
    "airye(z)\n"
    "\n"
    "Exponentially scaled Airy functions and their derivatives.\n"
    "\n"
    "Scaling::\n"
    "\n"
    "    eAi  = Ai  * exp(2.0/3.0*z*sqrt(z))\n"
    "    eAip = Aip * exp(2.0/3.0*z*sqrt(z))\n"
    "    eBi  = Bi  * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "    eBip = Bip * exp(-abs(2.0/3.0*(z*sqrt(z)).real))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "eAi, eAip, eBi, eBip : array_like\n"
    "    Airy functions Ai and Bi, and their derivatives Aip and Bip\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the AMOS [1]_ routines `zairy` and `zbiry`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "airy\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_airye_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_airye_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_airye_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_F_FFFF
ufunc_airye_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DDDD_As_D_DDDD
ufunc_airye_types[0] = <char>NPY_FLOAT
ufunc_airye_types[1] = <char>NPY_FLOAT
ufunc_airye_types[2] = <char>NPY_FLOAT
ufunc_airye_types[3] = <char>NPY_FLOAT
ufunc_airye_types[4] = <char>NPY_FLOAT
ufunc_airye_types[5] = <char>NPY_DOUBLE
ufunc_airye_types[6] = <char>NPY_DOUBLE
ufunc_airye_types[7] = <char>NPY_DOUBLE
ufunc_airye_types[8] = <char>NPY_DOUBLE
ufunc_airye_types[9] = <char>NPY_DOUBLE
ufunc_airye_types[10] = <char>NPY_CFLOAT
ufunc_airye_types[11] = <char>NPY_CFLOAT
ufunc_airye_types[12] = <char>NPY_CFLOAT
ufunc_airye_types[13] = <char>NPY_CFLOAT
ufunc_airye_types[14] = <char>NPY_CFLOAT
ufunc_airye_types[15] = <char>NPY_CDOUBLE
ufunc_airye_types[16] = <char>NPY_CDOUBLE
ufunc_airye_types[17] = <char>NPY_CDOUBLE
ufunc_airye_types[18] = <char>NPY_CDOUBLE
ufunc_airye_types[19] = <char>NPY_CDOUBLE
ufunc_airye_ptr[2*0] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*0+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*1] = <void*>_func_cairy_wrap_e_real
ufunc_airye_ptr[2*1+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*2] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*2+1] = <void*>(<char*>"airye")
ufunc_airye_ptr[2*3] = <void*>_func_cairy_wrap_e
ufunc_airye_ptr[2*3+1] = <void*>(<char*>"airye")
ufunc_airye_data[0] = &ufunc_airye_ptr[2*0]
ufunc_airye_data[1] = &ufunc_airye_ptr[2*1]
ufunc_airye_data[2] = &ufunc_airye_ptr[2*2]
ufunc_airye_data[3] = &ufunc_airye_ptr[2*3]
airye = np.PyUFunc_FromFuncAndData(ufunc_airye_loops, ufunc_airye_data, ufunc_airye_types, 4, 1, 4, 0, "airye", ufunc_airye_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]
cdef void *ufunc_bdtr_ptr[6]
cdef void *ufunc_bdtr_data[3]
cdef char ufunc_bdtr_types[12]
cdef char *ufunc_bdtr_doc = (
    "bdtr(k, n, p)\n"
    "\n"
    "Binomial distribution cumulative distribution function.\n"
    "\n"
    "Sum of the terms 0 through `k` of the Binomial probability density.\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) = \\sum_{j=0}^k {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (int).\n"
    "n : array_like\n"
    "    Number of events (int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : ndarray\n"
    "    Probability of `k` or fewer successes in `n` independent events with\n"
    "    success probabilities of `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) = I_{1 - p}(n - k, k + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_bdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_bdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtr_types[0] = <char>NPY_LONG
ufunc_bdtr_types[1] = <char>NPY_LONG
ufunc_bdtr_types[2] = <char>NPY_DOUBLE
ufunc_bdtr_types[3] = <char>NPY_DOUBLE
ufunc_bdtr_types[4] = <char>NPY_FLOAT
ufunc_bdtr_types[5] = <char>NPY_FLOAT
ufunc_bdtr_types[6] = <char>NPY_FLOAT
ufunc_bdtr_types[7] = <char>NPY_FLOAT
ufunc_bdtr_types[8] = <char>NPY_DOUBLE
ufunc_bdtr_types[9] = <char>NPY_DOUBLE
ufunc_bdtr_types[10] = <char>NPY_DOUBLE
ufunc_bdtr_types[11] = <char>NPY_DOUBLE
ufunc_bdtr_ptr[2*0] = <void*>_func_bdtr
ufunc_bdtr_ptr[2*0+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*1] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*1+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*2] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*2+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_data[0] = &ufunc_bdtr_ptr[2*0]
ufunc_bdtr_data[1] = &ufunc_bdtr_ptr[2*1]
ufunc_bdtr_data[2] = &ufunc_bdtr_ptr[2*2]
bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, "bdtr", ufunc_bdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]
cdef void *ufunc_bdtrc_ptr[6]
cdef void *ufunc_bdtrc_data[3]
cdef char ufunc_bdtrc_types[12]
cdef char *ufunc_bdtrc_doc = (
    "bdtrc(k, n, p)\n"
    "\n"
    "Binomial distribution survival function.\n"
    "\n"
    "Sum of the terms `k + 1` through `n` of the binomial probability density,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = \\sum_{j=k+1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (int).\n"
    "n : array_like\n"
    "    Number of events (int)\n"
    "p : array_like\n"
    "    Probability of success in a single event.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : ndarray\n"
    "    Probability of `k + 1` or more successes in `n` independent events\n"
    "    with success probabilities of `p`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "bdtr\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = I_{p}(k + 1, n - k).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_bdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_bdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrc_types[0] = <char>NPY_LONG
ufunc_bdtrc_types[1] = <char>NPY_LONG
ufunc_bdtrc_types[2] = <char>NPY_DOUBLE
ufunc_bdtrc_types[3] = <char>NPY_DOUBLE
ufunc_bdtrc_types[4] = <char>NPY_FLOAT
ufunc_bdtrc_types[5] = <char>NPY_FLOAT
ufunc_bdtrc_types[6] = <char>NPY_FLOAT
ufunc_bdtrc_types[7] = <char>NPY_FLOAT
ufunc_bdtrc_types[8] = <char>NPY_DOUBLE
ufunc_bdtrc_types[9] = <char>NPY_DOUBLE
ufunc_bdtrc_types[10] = <char>NPY_DOUBLE
ufunc_bdtrc_types[11] = <char>NPY_DOUBLE
ufunc_bdtrc_ptr[2*0] = <void*>_func_bdtrc
ufunc_bdtrc_ptr[2*0+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*1] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*1+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*2] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*2+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_data[0] = &ufunc_bdtrc_ptr[2*0]
ufunc_bdtrc_data[1] = &ufunc_bdtrc_ptr[2*1]
ufunc_bdtrc_data[2] = &ufunc_bdtrc_ptr[2*2]
bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, "bdtrc", ufunc_bdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]
cdef void *ufunc_bdtri_ptr[6]
cdef void *ufunc_bdtri_data[3]
cdef char ufunc_bdtri_types[12]
cdef char *ufunc_bdtri_doc = (
    "bdtri(k, n, y)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `p`.\n"
    "\n"
    "Finds the event probability `p` such that the sum of the terms 0 through\n"
    "`k` of the binomial probability density is equal to the given cumulative\n"
    "probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "n : array_like\n"
    "    Number of events (float)\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : ndarray\n"
    "    The event probability such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "bdtr\n"
    "betaincinv\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the inverse beta integral function\n"
    "and the relation,::\n"
    "\n"
    "    1 - p = betaincinv(n - k, k + 1, y).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_bdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_bdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtri_types[0] = <char>NPY_LONG
ufunc_bdtri_types[1] = <char>NPY_LONG
ufunc_bdtri_types[2] = <char>NPY_DOUBLE
ufunc_bdtri_types[3] = <char>NPY_DOUBLE
ufunc_bdtri_types[4] = <char>NPY_FLOAT
ufunc_bdtri_types[5] = <char>NPY_FLOAT
ufunc_bdtri_types[6] = <char>NPY_FLOAT
ufunc_bdtri_types[7] = <char>NPY_FLOAT
ufunc_bdtri_types[8] = <char>NPY_DOUBLE
ufunc_bdtri_types[9] = <char>NPY_DOUBLE
ufunc_bdtri_types[10] = <char>NPY_DOUBLE
ufunc_bdtri_types[11] = <char>NPY_DOUBLE
ufunc_bdtri_ptr[2*0] = <void*>_func_bdtri
ufunc_bdtri_ptr[2*0+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*1] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*1+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*2] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*2+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_data[0] = &ufunc_bdtri_ptr[2*0]
ufunc_bdtri_data[1] = &ufunc_bdtri_ptr[2*1]
ufunc_bdtri_data[2] = &ufunc_bdtri_ptr[2*2]
bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, "bdtri", ufunc_bdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]
cdef void *ufunc_bdtrik_ptr[4]
cdef void *ufunc_bdtrik_data[2]
cdef char ufunc_bdtrik_types[8]
cdef char *ufunc_bdtrik_doc = (
    "bdtrik(y, n, p)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `k`.\n"
    "\n"
    "Finds the number of successes `k` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for `n` events with probability\n"
    "`p` is equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "n : array_like\n"
    "    Number of events (float).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : ndarray\n"
    "    The number of successes `k` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrik_types[0] = <char>NPY_FLOAT
ufunc_bdtrik_types[1] = <char>NPY_FLOAT
ufunc_bdtrik_types[2] = <char>NPY_FLOAT
ufunc_bdtrik_types[3] = <char>NPY_FLOAT
ufunc_bdtrik_types[4] = <char>NPY_DOUBLE
ufunc_bdtrik_types[5] = <char>NPY_DOUBLE
ufunc_bdtrik_types[6] = <char>NPY_DOUBLE
ufunc_bdtrik_types[7] = <char>NPY_DOUBLE
ufunc_bdtrik_ptr[2*0] = <void*>_func_cdfbin2_wrap
ufunc_bdtrik_ptr[2*0+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_ptr[2*1] = <void*>_func_cdfbin2_wrap
ufunc_bdtrik_ptr[2*1+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_data[0] = &ufunc_bdtrik_ptr[2*0]
ufunc_bdtrik_data[1] = &ufunc_bdtrik_ptr[2*1]
bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, "bdtrik", ufunc_bdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]
cdef void *ufunc_bdtrin_ptr[4]
cdef void *ufunc_bdtrin_data[2]
cdef char ufunc_bdtrin_types[8]
cdef char *ufunc_bdtrin_doc = (
    "bdtrin(k, y, p)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `n`.\n"
    "\n"
    "Finds the number of events `n` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for events with probability `p` is\n"
    "equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : ndarray\n"
    "    The number of events `n` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrin_types[0] = <char>NPY_FLOAT
ufunc_bdtrin_types[1] = <char>NPY_FLOAT
ufunc_bdtrin_types[2] = <char>NPY_FLOAT
ufunc_bdtrin_types[3] = <char>NPY_FLOAT
ufunc_bdtrin_types[4] = <char>NPY_DOUBLE
ufunc_bdtrin_types[5] = <char>NPY_DOUBLE
ufunc_bdtrin_types[6] = <char>NPY_DOUBLE
ufunc_bdtrin_types[7] = <char>NPY_DOUBLE
ufunc_bdtrin_ptr[2*0] = <void*>_func_cdfbin3_wrap
ufunc_bdtrin_ptr[2*0+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_ptr[2*1] = <void*>_func_cdfbin3_wrap
ufunc_bdtrin_ptr[2*1+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_data[0] = &ufunc_bdtrin_ptr[2*0]
ufunc_bdtrin_data[1] = &ufunc_bdtrin_ptr[2*1]
bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, "bdtrin", ufunc_bdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bei_loops[2]
cdef void *ufunc_bei_ptr[4]
cdef void *ufunc_bei_data[2]
cdef char ufunc_bei_types[4]
cdef char *ufunc_bei_doc = (
    "bei(x)\n"
    "\n"
    "Kelvin function bei")
ufunc_bei_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_bei_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_bei_types[0] = <char>NPY_FLOAT
ufunc_bei_types[1] = <char>NPY_FLOAT
ufunc_bei_types[2] = <char>NPY_DOUBLE
ufunc_bei_types[3] = <char>NPY_DOUBLE
ufunc_bei_ptr[2*0] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*0+1] = <void*>(<char*>"bei")
ufunc_bei_ptr[2*1] = <void*>_func_bei_wrap
ufunc_bei_ptr[2*1+1] = <void*>(<char*>"bei")
ufunc_bei_data[0] = &ufunc_bei_ptr[2*0]
ufunc_bei_data[1] = &ufunc_bei_ptr[2*1]
bei = np.PyUFunc_FromFuncAndData(ufunc_bei_loops, ufunc_bei_data, ufunc_bei_types, 2, 1, 1, 0, "bei", ufunc_bei_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beip_loops[2]
cdef void *ufunc_beip_ptr[4]
cdef void *ufunc_beip_data[2]
cdef char ufunc_beip_types[4]
cdef char *ufunc_beip_doc = (
    "beip(x)\n"
    "\n"
    "Derivative of the Kelvin function `bei`")
ufunc_beip_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_beip_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_beip_types[0] = <char>NPY_FLOAT
ufunc_beip_types[1] = <char>NPY_FLOAT
ufunc_beip_types[2] = <char>NPY_DOUBLE
ufunc_beip_types[3] = <char>NPY_DOUBLE
ufunc_beip_ptr[2*0] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*0+1] = <void*>(<char*>"beip")
ufunc_beip_ptr[2*1] = <void*>_func_beip_wrap
ufunc_beip_ptr[2*1+1] = <void*>(<char*>"beip")
ufunc_beip_data[0] = &ufunc_beip_ptr[2*0]
ufunc_beip_data[1] = &ufunc_beip_ptr[2*1]
beip = np.PyUFunc_FromFuncAndData(ufunc_beip_loops, ufunc_beip_data, ufunc_beip_types, 2, 1, 1, 0, "beip", ufunc_beip_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ber_loops[2]
cdef void *ufunc_ber_ptr[4]
cdef void *ufunc_ber_data[2]
cdef char ufunc_ber_types[4]
cdef char *ufunc_ber_doc = (
    "ber(x)\n"
    "\n"
    "Kelvin function ber.")
ufunc_ber_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ber_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ber_types[0] = <char>NPY_FLOAT
ufunc_ber_types[1] = <char>NPY_FLOAT
ufunc_ber_types[2] = <char>NPY_DOUBLE
ufunc_ber_types[3] = <char>NPY_DOUBLE
ufunc_ber_ptr[2*0] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*0+1] = <void*>(<char*>"ber")
ufunc_ber_ptr[2*1] = <void*>_func_ber_wrap
ufunc_ber_ptr[2*1+1] = <void*>(<char*>"ber")
ufunc_ber_data[0] = &ufunc_ber_ptr[2*0]
ufunc_ber_data[1] = &ufunc_ber_ptr[2*1]
ber = np.PyUFunc_FromFuncAndData(ufunc_ber_loops, ufunc_ber_data, ufunc_ber_types, 2, 1, 1, 0, "ber", ufunc_ber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_berp_loops[2]
cdef void *ufunc_berp_ptr[4]
cdef void *ufunc_berp_data[2]
cdef char ufunc_berp_types[4]
cdef char *ufunc_berp_doc = (
    "berp(x)\n"
    "\n"
    "Derivative of the Kelvin function `ber`")
ufunc_berp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_berp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_berp_types[0] = <char>NPY_FLOAT
ufunc_berp_types[1] = <char>NPY_FLOAT
ufunc_berp_types[2] = <char>NPY_DOUBLE
ufunc_berp_types[3] = <char>NPY_DOUBLE
ufunc_berp_ptr[2*0] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*0+1] = <void*>(<char*>"berp")
ufunc_berp_ptr[2*1] = <void*>_func_berp_wrap
ufunc_berp_ptr[2*1+1] = <void*>(<char*>"berp")
ufunc_berp_data[0] = &ufunc_berp_ptr[2*0]
ufunc_berp_data[1] = &ufunc_berp_ptr[2*1]
berp = np.PyUFunc_FromFuncAndData(ufunc_berp_loops, ufunc_berp_data, ufunc_berp_types, 2, 1, 1, 0, "berp", ufunc_berp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]
cdef void *ufunc_besselpoly_ptr[4]
cdef void *ufunc_besselpoly_data[2]
cdef char ufunc_besselpoly_types[8]
cdef char *ufunc_besselpoly_doc = (
    "besselpoly(a, lmb, nu)\n"
    "\n"
    "Weighted integral of a Bessel function.\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n"
    "\n"
    "where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n"
    ":math:`\\nu=nu`.")
ufunc_besselpoly_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_besselpoly_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_besselpoly_types[0] = <char>NPY_FLOAT
ufunc_besselpoly_types[1] = <char>NPY_FLOAT
ufunc_besselpoly_types[2] = <char>NPY_FLOAT
ufunc_besselpoly_types[3] = <char>NPY_FLOAT
ufunc_besselpoly_types[4] = <char>NPY_DOUBLE
ufunc_besselpoly_types[5] = <char>NPY_DOUBLE
ufunc_besselpoly_types[6] = <char>NPY_DOUBLE
ufunc_besselpoly_types[7] = <char>NPY_DOUBLE
ufunc_besselpoly_ptr[2*0] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*0+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_ptr[2*1] = <void*>_func_besselpoly
ufunc_besselpoly_ptr[2*1+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_data[0] = &ufunc_besselpoly_ptr[2*0]
ufunc_besselpoly_data[1] = &ufunc_besselpoly_ptr[2*1]
besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, "besselpoly", ufunc_besselpoly_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]
cdef void *ufunc_beta_ptr[4]
cdef void *ufunc_beta_data[2]
cdef char ufunc_beta_types[6]
cdef char *ufunc_beta_doc = (
    "beta(a, b)\n"
    "\n"
    "Beta function.\n"
    "\n"
    "::\n"
    "\n"
    "    beta(a, b) =  gamma(a) * gamma(b) / gamma(a+b)")
ufunc_beta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_beta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_beta_types[0] = <char>NPY_FLOAT
ufunc_beta_types[1] = <char>NPY_FLOAT
ufunc_beta_types[2] = <char>NPY_FLOAT
ufunc_beta_types[3] = <char>NPY_DOUBLE
ufunc_beta_types[4] = <char>NPY_DOUBLE
ufunc_beta_types[5] = <char>NPY_DOUBLE
ufunc_beta_ptr[2*0] = <void*>_func_beta
ufunc_beta_ptr[2*0+1] = <void*>(<char*>"beta")
ufunc_beta_ptr[2*1] = <void*>_func_beta
ufunc_beta_ptr[2*1+1] = <void*>(<char*>"beta")
ufunc_beta_data[0] = &ufunc_beta_ptr[2*0]
ufunc_beta_data[1] = &ufunc_beta_ptr[2*1]
beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, "beta", ufunc_beta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]
cdef void *ufunc_betainc_ptr[4]
cdef void *ufunc_betainc_data[2]
cdef char ufunc_betainc_types[8]
cdef char *ufunc_betainc_doc = (
    "betainc(a, b, x)\n"
    "\n"
    "Incomplete beta integral.\n"
    "\n"
    "Compute the incomplete beta integral of the arguments, evaluated\n"
    "from zero to `x`::\n"
    "\n"
    "    gamma(a+b) / (gamma(a)*gamma(b)) * integral(t**(a-1) (1-t)**(b-1), t=0..x).\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The incomplete beta is also sometimes defined without the terms\n"
    "in gamma, in which case the above definition is the so-called regularized\n"
    "incomplete beta. Under this definition, you can get the incomplete beta by\n"
    "multiplying the result of the scipy function by beta(a, b).")
ufunc_betainc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_betainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainc_types[0] = <char>NPY_FLOAT
ufunc_betainc_types[1] = <char>NPY_FLOAT
ufunc_betainc_types[2] = <char>NPY_FLOAT
ufunc_betainc_types[3] = <char>NPY_FLOAT
ufunc_betainc_types[4] = <char>NPY_DOUBLE
ufunc_betainc_types[5] = <char>NPY_DOUBLE
ufunc_betainc_types[6] = <char>NPY_DOUBLE
ufunc_betainc_types[7] = <char>NPY_DOUBLE
ufunc_betainc_ptr[2*0] = <void*>_func_incbet
ufunc_betainc_ptr[2*0+1] = <void*>(<char*>"betainc")
ufunc_betainc_ptr[2*1] = <void*>_func_incbet
ufunc_betainc_ptr[2*1+1] = <void*>(<char*>"betainc")
ufunc_betainc_data[0] = &ufunc_betainc_ptr[2*0]
ufunc_betainc_data[1] = &ufunc_betainc_ptr[2*1]
betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, "betainc", ufunc_betainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]
cdef void *ufunc_betaincinv_ptr[4]
cdef void *ufunc_betaincinv_data[2]
cdef char ufunc_betaincinv_types[8]
cdef char *ufunc_betaincinv_doc = (
    "betaincinv(a, b, y)\n"
    "\n"
    "Inverse function to beta integral.\n"
    "\n"
    "Compute `x` such that betainc(a, b, x) = y.")
ufunc_betaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_betaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincinv_types[0] = <char>NPY_FLOAT
ufunc_betaincinv_types[1] = <char>NPY_FLOAT
ufunc_betaincinv_types[2] = <char>NPY_FLOAT
ufunc_betaincinv_types[3] = <char>NPY_FLOAT
ufunc_betaincinv_types[4] = <char>NPY_DOUBLE
ufunc_betaincinv_types[5] = <char>NPY_DOUBLE
ufunc_betaincinv_types[6] = <char>NPY_DOUBLE
ufunc_betaincinv_types[7] = <char>NPY_DOUBLE
ufunc_betaincinv_ptr[2*0] = <void*>_func_incbi
ufunc_betaincinv_ptr[2*0+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_ptr[2*1] = <void*>_func_incbi
ufunc_betaincinv_ptr[2*1+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_data[0] = &ufunc_betaincinv_ptr[2*0]
ufunc_betaincinv_data[1] = &ufunc_betaincinv_ptr[2*1]
betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, "betaincinv", ufunc_betaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]
cdef void *ufunc_betaln_ptr[4]
cdef void *ufunc_betaln_data[2]
cdef char ufunc_betaln_types[6]
cdef char *ufunc_betaln_doc = (
    "betaln(a, b)\n"
    "\n"
    "Natural logarithm of absolute value of beta function.\n"
    "\n"
    "Computes ``ln(abs(beta(a, b)))``.")
ufunc_betaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_betaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_betaln_types[0] = <char>NPY_FLOAT
ufunc_betaln_types[1] = <char>NPY_FLOAT
ufunc_betaln_types[2] = <char>NPY_FLOAT
ufunc_betaln_types[3] = <char>NPY_DOUBLE
ufunc_betaln_types[4] = <char>NPY_DOUBLE
ufunc_betaln_types[5] = <char>NPY_DOUBLE
ufunc_betaln_ptr[2*0] = <void*>_func_lbeta
ufunc_betaln_ptr[2*0+1] = <void*>(<char*>"betaln")
ufunc_betaln_ptr[2*1] = <void*>_func_lbeta
ufunc_betaln_ptr[2*1+1] = <void*>(<char*>"betaln")
ufunc_betaln_data[0] = &ufunc_betaln_ptr[2*0]
ufunc_betaln_data[1] = &ufunc_betaln_ptr[2*1]
betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, "betaln", ufunc_betaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_binom_loops[2]
cdef void *ufunc_binom_ptr[4]
cdef void *ufunc_binom_data[2]
cdef char ufunc_binom_types[6]
cdef char *ufunc_binom_doc = (
    "binom(n, k)\n"
    "\n"
    "Binomial coefficient\n"
    "\n"
    "See Also\n"
    "--------\n"
    "comb : The number of combinations of N things taken k at a time.")
ufunc_binom_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_binom_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_binom_types[0] = <char>NPY_FLOAT
ufunc_binom_types[1] = <char>NPY_FLOAT
ufunc_binom_types[2] = <char>NPY_FLOAT
ufunc_binom_types[3] = <char>NPY_DOUBLE
ufunc_binom_types[4] = <char>NPY_DOUBLE
ufunc_binom_types[5] = <char>NPY_DOUBLE
ufunc_binom_ptr[2*0] = <void*>_func_binom
ufunc_binom_ptr[2*0+1] = <void*>(<char*>"binom")
ufunc_binom_ptr[2*1] = <void*>_func_binom
ufunc_binom_ptr[2*1+1] = <void*>(<char*>"binom")
ufunc_binom_data[0] = &ufunc_binom_ptr[2*0]
ufunc_binom_data[1] = &ufunc_binom_ptr[2*1]
binom = np.PyUFunc_FromFuncAndData(ufunc_binom_loops, ufunc_binom_data, ufunc_binom_types, 2, 2, 1, 0, "binom", ufunc_binom_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]
cdef void *ufunc_boxcox_ptr[4]
cdef void *ufunc_boxcox_data[2]
cdef char ufunc_boxcox_types[6]
cdef char *ufunc_boxcox_doc = (
    "boxcox(x, lmbda)\n"
    "\n"
    "Compute the Box-Cox transformation.\n"
    "\n"
    "The Box-Cox transformation is::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < 0``.\n"
    "Returns `-inf` if ``x == 0`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : array\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox\n"
    ">>> boxcox([1, 4, 10], 2.5)\n"
    "array([   0.        ,   12.4       ,  126.09110641])\n"
    ">>> boxcox(2, [0, 1, 2])\n"
    "array([ 0.69314718,  1.        ,  1.5       ])")
ufunc_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox_types[0] = <char>NPY_FLOAT
ufunc_boxcox_types[1] = <char>NPY_FLOAT
ufunc_boxcox_types[2] = <char>NPY_FLOAT
ufunc_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_boxcox_ptr[2*0] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*0+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_ptr[2*1] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*1+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_data[0] = &ufunc_boxcox_ptr[2*0]
ufunc_boxcox_data[1] = &ufunc_boxcox_ptr[2*1]
boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, "boxcox", ufunc_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]
cdef void *ufunc_boxcox1p_ptr[4]
cdef void *ufunc_boxcox1p_data[2]
cdef char ufunc_boxcox1p_types[6]
cdef char *ufunc_boxcox1p_doc = (
    "boxcox1p(x, lmbda)\n"
    "\n"
    "Compute the Box-Cox transformation of 1 + `x`.\n"
    "\n"
    "The Box-Cox transformation computed by `boxcox1p` is::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < -1``.\n"
    "Returns `-inf` if ``x == -1`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : array\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p\n"
    ">>> boxcox1p(1e-4, [0, 0.5, 1])\n"
    "array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n"
    ">>> boxcox1p([0.01, 0.1], 0.25)\n"
    "array([ 0.00996272,  0.09645476])")
ufunc_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_boxcox1p_ptr[2*0] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*0+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_ptr[2*1] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*1+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_data[0] = &ufunc_boxcox1p_ptr[2*0]
ufunc_boxcox1p_data[1] = &ufunc_boxcox1p_ptr[2*1]
boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, "boxcox1p", ufunc_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]
cdef void *ufunc_btdtr_ptr[4]
cdef void *ufunc_btdtr_data[2]
cdef char ufunc_btdtr_types[8]
cdef char *ufunc_btdtr_doc = (
    "btdtr(a, b, x)\n"
    "\n"
    "Cumulative density function of the beta distribution.\n"
    "\n"
    "Returns the integral from zero to `x` of the beta probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (a > 0).\n"
    "b : array_like\n"
    "    Shape parameter (b > 0).\n"
    "x : array_like\n"
    "    Upper limit of integration, in [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    Cumulative density function of the beta distribution with parameters\n"
    "    `a` and `b` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is identical to the incomplete beta integral function\n"
    "`betainc`.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `btdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_btdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtr_types[0] = <char>NPY_FLOAT
ufunc_btdtr_types[1] = <char>NPY_FLOAT
ufunc_btdtr_types[2] = <char>NPY_FLOAT
ufunc_btdtr_types[3] = <char>NPY_FLOAT
ufunc_btdtr_types[4] = <char>NPY_DOUBLE
ufunc_btdtr_types[5] = <char>NPY_DOUBLE
ufunc_btdtr_types[6] = <char>NPY_DOUBLE
ufunc_btdtr_types[7] = <char>NPY_DOUBLE
ufunc_btdtr_ptr[2*0] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*0+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_ptr[2*1] = <void*>_func_btdtr
ufunc_btdtr_ptr[2*1+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_data[0] = &ufunc_btdtr_ptr[2*0]
ufunc_btdtr_data[1] = &ufunc_btdtr_ptr[2*1]
btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, "btdtr", ufunc_btdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]
cdef void *ufunc_btdtri_ptr[4]
cdef void *ufunc_btdtri_data[2]
cdef char ufunc_btdtri_types[8]
cdef char *ufunc_btdtri_doc = (
    "btdtri(a, b, p)\n"
    "\n"
    "The `p`-th quantile of the beta distribution.\n"
    "\n"
    "This function is the inverse of the beta cumulative distribution function,\n"
    "`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betaincinv\n"
    "btdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of `x` is found by interval halving or Newton iterations.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n"
    "problem of finding the inverse of the incomplete beta integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_btdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtri_types[0] = <char>NPY_FLOAT
ufunc_btdtri_types[1] = <char>NPY_FLOAT
ufunc_btdtri_types[2] = <char>NPY_FLOAT
ufunc_btdtri_types[3] = <char>NPY_FLOAT
ufunc_btdtri_types[4] = <char>NPY_DOUBLE
ufunc_btdtri_types[5] = <char>NPY_DOUBLE
ufunc_btdtri_types[6] = <char>NPY_DOUBLE
ufunc_btdtri_types[7] = <char>NPY_DOUBLE
ufunc_btdtri_ptr[2*0] = <void*>_func_incbi
ufunc_btdtri_ptr[2*0+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_ptr[2*1] = <void*>_func_incbi
ufunc_btdtri_ptr[2*1+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_data[0] = &ufunc_btdtri_ptr[2*0]
ufunc_btdtri_data[1] = &ufunc_btdtri_ptr[2*1]
btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, "btdtri", ufunc_btdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]
cdef void *ufunc_btdtria_ptr[4]
cdef void *ufunc_btdtria_data[2]
cdef char ufunc_btdtria_types[8]
cdef char *ufunc_btdtria_doc = (
    "btdtria(p, b, x)\n"
    "\n"
    "Inverse of `btdtr` with respect to `a`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `a`, returning the value of `a` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : ndarray\n"
    "    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative density function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtrib : Inverse with respect to `b`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_.  Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`.  The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtria_types[0] = <char>NPY_FLOAT
ufunc_btdtria_types[1] = <char>NPY_FLOAT
ufunc_btdtria_types[2] = <char>NPY_FLOAT
ufunc_btdtria_types[3] = <char>NPY_FLOAT
ufunc_btdtria_types[4] = <char>NPY_DOUBLE
ufunc_btdtria_types[5] = <char>NPY_DOUBLE
ufunc_btdtria_types[6] = <char>NPY_DOUBLE
ufunc_btdtria_types[7] = <char>NPY_DOUBLE
ufunc_btdtria_ptr[2*0] = <void*>_func_cdfbet3_wrap
ufunc_btdtria_ptr[2*0+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_ptr[2*1] = <void*>_func_cdfbet3_wrap
ufunc_btdtria_ptr[2*1+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_data[0] = &ufunc_btdtria_ptr[2*0]
ufunc_btdtria_data[1] = &ufunc_btdtria_ptr[2*1]
btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, "btdtria", ufunc_btdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]
cdef void *ufunc_btdtrib_ptr[4]
cdef void *ufunc_btdtrib_data[2]
cdef char ufunc_btdtrib_types[8]
cdef char *ufunc_btdtrib_doc = (
    "btdtria(a, p, x)\n"
    "\n"
    "Inverse of `btdtr` with respect to `b`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `b`, returning the value of `b` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : ndarray\n"
    "    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative density function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtria : Inverse with respect to `a`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_.  Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`.  The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtrib_types[0] = <char>NPY_FLOAT
ufunc_btdtrib_types[1] = <char>NPY_FLOAT
ufunc_btdtrib_types[2] = <char>NPY_FLOAT
ufunc_btdtrib_types[3] = <char>NPY_FLOAT
ufunc_btdtrib_types[4] = <char>NPY_DOUBLE
ufunc_btdtrib_types[5] = <char>NPY_DOUBLE
ufunc_btdtrib_types[6] = <char>NPY_DOUBLE
ufunc_btdtrib_types[7] = <char>NPY_DOUBLE
ufunc_btdtrib_ptr[2*0] = <void*>_func_cdfbet4_wrap
ufunc_btdtrib_ptr[2*0+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_ptr[2*1] = <void*>_func_cdfbet4_wrap
ufunc_btdtrib_ptr[2*1+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_data[0] = &ufunc_btdtrib_ptr[2*0]
ufunc_btdtrib_data[1] = &ufunc_btdtrib_ptr[2*1]
btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, "btdtrib", ufunc_btdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]
cdef void *ufunc_cbrt_ptr[4]
cdef void *ufunc_cbrt_data[2]
cdef char ufunc_cbrt_types[4]
cdef char *ufunc_cbrt_doc = (
    "cbrt(x)\n"
    "\n"
    "Cube root of `x`")
ufunc_cbrt_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cbrt_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cbrt_types[0] = <char>NPY_FLOAT
ufunc_cbrt_types[1] = <char>NPY_FLOAT
ufunc_cbrt_types[2] = <char>NPY_DOUBLE
ufunc_cbrt_types[3] = <char>NPY_DOUBLE
ufunc_cbrt_ptr[2*0] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*0+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_ptr[2*1] = <void*>_func_cbrt
ufunc_cbrt_ptr[2*1+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_data[0] = &ufunc_cbrt_ptr[2*0]
ufunc_cbrt_data[1] = &ufunc_cbrt_ptr[2*1]
cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, "cbrt", ufunc_cbrt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]
cdef void *ufunc_chdtr_ptr[4]
cdef void *ufunc_chdtr_data[2]
cdef char ufunc_chdtr_types[6]
cdef char *ufunc_chdtr_doc = (
    "chdtr(v, x)\n"
    "\n"
    "Chi square cumulative distribution function\n"
    "\n"
    "Returns the area under the left hand tail (from 0 to `x`) of the Chi\n"
    "square probability density function with `v` degrees of freedom::\n"
    "\n"
    "    1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=0..x)")
ufunc_chdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtr_types[0] = <char>NPY_FLOAT
ufunc_chdtr_types[1] = <char>NPY_FLOAT
ufunc_chdtr_types[2] = <char>NPY_FLOAT
ufunc_chdtr_types[3] = <char>NPY_DOUBLE
ufunc_chdtr_types[4] = <char>NPY_DOUBLE
ufunc_chdtr_types[5] = <char>NPY_DOUBLE
ufunc_chdtr_ptr[2*0] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*0+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_ptr[2*1] = <void*>_func_chdtr
ufunc_chdtr_ptr[2*1+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_data[0] = &ufunc_chdtr_ptr[2*0]
ufunc_chdtr_data[1] = &ufunc_chdtr_ptr[2*1]
chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, "chdtr", ufunc_chdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]
cdef void *ufunc_chdtrc_ptr[4]
cdef void *ufunc_chdtrc_data[2]
cdef char ufunc_chdtrc_types[6]
cdef char *ufunc_chdtrc_doc = (
    "chdtrc(v, x)\n"
    "\n"
    "Chi square survival function\n"
    "\n"
    "Returns the area under the right hand tail (from `x` to\n"
    "infinity) of the Chi square probability density function with `v`\n"
    "degrees of freedom::\n"
    "\n"
    "    1/(2**(v/2) * gamma(v/2)) * integral(t**(v/2-1) * exp(-t/2), t=x..inf)")
ufunc_chdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtrc_types[0] = <char>NPY_FLOAT
ufunc_chdtrc_types[1] = <char>NPY_FLOAT
ufunc_chdtrc_types[2] = <char>NPY_FLOAT
ufunc_chdtrc_types[3] = <char>NPY_DOUBLE
ufunc_chdtrc_types[4] = <char>NPY_DOUBLE
ufunc_chdtrc_types[5] = <char>NPY_DOUBLE
ufunc_chdtrc_ptr[2*0] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*0+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_ptr[2*1] = <void*>_func_chdtrc
ufunc_chdtrc_ptr[2*1+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_data[0] = &ufunc_chdtrc_ptr[2*0]
ufunc_chdtrc_data[1] = &ufunc_chdtrc_ptr[2*1]
chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, "chdtrc", ufunc_chdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]
cdef void *ufunc_chdtri_ptr[4]
cdef void *ufunc_chdtri_data[2]
cdef char ufunc_chdtri_types[6]
cdef char *ufunc_chdtri_doc = (
    "chdtri(v, p)\n"
    "\n"
    "Inverse to `chdtrc`\n"
    "\n"
    "Returns the argument x such that ``chdtrc(v, x) == p``.")
ufunc_chdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtri_types[0] = <char>NPY_FLOAT
ufunc_chdtri_types[1] = <char>NPY_FLOAT
ufunc_chdtri_types[2] = <char>NPY_FLOAT
ufunc_chdtri_types[3] = <char>NPY_DOUBLE
ufunc_chdtri_types[4] = <char>NPY_DOUBLE
ufunc_chdtri_types[5] = <char>NPY_DOUBLE
ufunc_chdtri_ptr[2*0] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*0+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_ptr[2*1] = <void*>_func_chdtri
ufunc_chdtri_ptr[2*1+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_data[0] = &ufunc_chdtri_ptr[2*0]
ufunc_chdtri_data[1] = &ufunc_chdtri_ptr[2*1]
chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, "chdtri", ufunc_chdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]
cdef void *ufunc_chdtriv_ptr[4]
cdef void *ufunc_chdtriv_data[2]
cdef char ufunc_chdtriv_types[6]
cdef char *ufunc_chdtriv_doc = (
    "chdtriv(p, x)\n"
    "\n"
    "Inverse to `chdtr` vs `v`\n"
    "\n"
    "Returns the argument v such that ``chdtr(v, x) == p``.")
ufunc_chdtriv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtriv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtriv_types[0] = <char>NPY_FLOAT
ufunc_chdtriv_types[1] = <char>NPY_FLOAT
ufunc_chdtriv_types[2] = <char>NPY_FLOAT
ufunc_chdtriv_types[3] = <char>NPY_DOUBLE
ufunc_chdtriv_types[4] = <char>NPY_DOUBLE
ufunc_chdtriv_types[5] = <char>NPY_DOUBLE
ufunc_chdtriv_ptr[2*0] = <void*>_func_cdfchi3_wrap
ufunc_chdtriv_ptr[2*0+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_ptr[2*1] = <void*>_func_cdfchi3_wrap
ufunc_chdtriv_ptr[2*1+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_data[0] = &ufunc_chdtriv_ptr[2*0]
ufunc_chdtriv_data[1] = &ufunc_chdtriv_ptr[2*1]
chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, "chdtriv", ufunc_chdtriv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]
cdef void *ufunc_chndtr_ptr[4]
cdef void *ufunc_chndtr_data[2]
cdef char ufunc_chndtr_types[8]
cdef char *ufunc_chndtr_doc = (
    "chndtr(x, df, nc)\n"
    "\n"
    "Non-central chi square cumulative distribution function")
ufunc_chndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtr_types[0] = <char>NPY_FLOAT
ufunc_chndtr_types[1] = <char>NPY_FLOAT
ufunc_chndtr_types[2] = <char>NPY_FLOAT
ufunc_chndtr_types[3] = <char>NPY_FLOAT
ufunc_chndtr_types[4] = <char>NPY_DOUBLE
ufunc_chndtr_types[5] = <char>NPY_DOUBLE
ufunc_chndtr_types[6] = <char>NPY_DOUBLE
ufunc_chndtr_types[7] = <char>NPY_DOUBLE
ufunc_chndtr_ptr[2*0] = <void*>_func_cdfchn1_wrap
ufunc_chndtr_ptr[2*0+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_ptr[2*1] = <void*>_func_cdfchn1_wrap
ufunc_chndtr_ptr[2*1+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_data[0] = &ufunc_chndtr_ptr[2*0]
ufunc_chndtr_data[1] = &ufunc_chndtr_ptr[2*1]
chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, "chndtr", ufunc_chndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]
cdef void *ufunc_chndtridf_ptr[4]
cdef void *ufunc_chndtridf_data[2]
cdef char ufunc_chndtridf_types[8]
cdef char *ufunc_chndtridf_doc = (
    "chndtridf(x, p, nc)\n"
    "\n"
    "Inverse to `chndtr` vs `df`")
ufunc_chndtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtridf_types[0] = <char>NPY_FLOAT
ufunc_chndtridf_types[1] = <char>NPY_FLOAT
ufunc_chndtridf_types[2] = <char>NPY_FLOAT
ufunc_chndtridf_types[3] = <char>NPY_FLOAT
ufunc_chndtridf_types[4] = <char>NPY_DOUBLE
ufunc_chndtridf_types[5] = <char>NPY_DOUBLE
ufunc_chndtridf_types[6] = <char>NPY_DOUBLE
ufunc_chndtridf_types[7] = <char>NPY_DOUBLE
ufunc_chndtridf_ptr[2*0] = <void*>_func_cdfchn3_wrap
ufunc_chndtridf_ptr[2*0+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_ptr[2*1] = <void*>_func_cdfchn3_wrap
ufunc_chndtridf_ptr[2*1+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_data[0] = &ufunc_chndtridf_ptr[2*0]
ufunc_chndtridf_data[1] = &ufunc_chndtridf_ptr[2*1]
chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, "chndtridf", ufunc_chndtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]
cdef void *ufunc_chndtrinc_ptr[4]
cdef void *ufunc_chndtrinc_data[2]
cdef char ufunc_chndtrinc_types[8]
cdef char *ufunc_chndtrinc_doc = (
    "chndtrinc(x, df, p)\n"
    "\n"
    "Inverse to `chndtr` vs `nc`")
ufunc_chndtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrinc_types[0] = <char>NPY_FLOAT
ufunc_chndtrinc_types[1] = <char>NPY_FLOAT
ufunc_chndtrinc_types[2] = <char>NPY_FLOAT
ufunc_chndtrinc_types[3] = <char>NPY_FLOAT
ufunc_chndtrinc_types[4] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[5] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[6] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[7] = <char>NPY_DOUBLE
ufunc_chndtrinc_ptr[2*0] = <void*>_func_cdfchn4_wrap
ufunc_chndtrinc_ptr[2*0+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_ptr[2*1] = <void*>_func_cdfchn4_wrap
ufunc_chndtrinc_ptr[2*1+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_data[0] = &ufunc_chndtrinc_ptr[2*0]
ufunc_chndtrinc_data[1] = &ufunc_chndtrinc_ptr[2*1]
chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, "chndtrinc", ufunc_chndtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]
cdef void *ufunc_chndtrix_ptr[4]
cdef void *ufunc_chndtrix_data[2]
cdef char ufunc_chndtrix_types[8]
cdef char *ufunc_chndtrix_doc = (
    "chndtrix(p, df, nc)\n"
    "\n"
    "Inverse to `chndtr` vs `x`")
ufunc_chndtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrix_types[0] = <char>NPY_FLOAT
ufunc_chndtrix_types[1] = <char>NPY_FLOAT
ufunc_chndtrix_types[2] = <char>NPY_FLOAT
ufunc_chndtrix_types[3] = <char>NPY_FLOAT
ufunc_chndtrix_types[4] = <char>NPY_DOUBLE
ufunc_chndtrix_types[5] = <char>NPY_DOUBLE
ufunc_chndtrix_types[6] = <char>NPY_DOUBLE
ufunc_chndtrix_types[7] = <char>NPY_DOUBLE
ufunc_chndtrix_ptr[2*0] = <void*>_func_cdfchn2_wrap
ufunc_chndtrix_ptr[2*0+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_ptr[2*1] = <void*>_func_cdfchn2_wrap
ufunc_chndtrix_ptr[2*1+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_data[0] = &ufunc_chndtrix_ptr[2*0]
ufunc_chndtrix_data[1] = &ufunc_chndtrix_ptr[2*1]
chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, "chndtrix", ufunc_chndtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]
cdef void *ufunc_cosdg_ptr[4]
cdef void *ufunc_cosdg_data[2]
cdef char ufunc_cosdg_types[4]
cdef char *ufunc_cosdg_doc = (
    "cosdg(x)\n"
    "\n"
    "Cosine of the angle `x` given in degrees.")
ufunc_cosdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosdg_types[0] = <char>NPY_FLOAT
ufunc_cosdg_types[1] = <char>NPY_FLOAT
ufunc_cosdg_types[2] = <char>NPY_DOUBLE
ufunc_cosdg_types[3] = <char>NPY_DOUBLE
ufunc_cosdg_ptr[2*0] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*0+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_ptr[2*1] = <void*>_func_cosdg
ufunc_cosdg_ptr[2*1+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_data[0] = &ufunc_cosdg_ptr[2*0]
ufunc_cosdg_data[1] = &ufunc_cosdg_ptr[2*1]
cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, "cosdg", ufunc_cosdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]
cdef void *ufunc_cosm1_ptr[4]
cdef void *ufunc_cosm1_data[2]
cdef char ufunc_cosm1_types[4]
cdef char *ufunc_cosm1_doc = (
    "cosm1(x)\n"
    "\n"
    "cos(x) - 1 for use when `x` is near zero.")
ufunc_cosm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosm1_types[0] = <char>NPY_FLOAT
ufunc_cosm1_types[1] = <char>NPY_FLOAT
ufunc_cosm1_types[2] = <char>NPY_DOUBLE
ufunc_cosm1_types[3] = <char>NPY_DOUBLE
ufunc_cosm1_ptr[2*0] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*0+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_ptr[2*1] = <void*>_func_cosm1
ufunc_cosm1_ptr[2*1+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_data[0] = &ufunc_cosm1_ptr[2*0]
ufunc_cosm1_data[1] = &ufunc_cosm1_ptr[2*1]
cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, "cosm1", ufunc_cosm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]
cdef void *ufunc_cotdg_ptr[4]
cdef void *ufunc_cotdg_data[2]
cdef char ufunc_cotdg_types[4]
cdef char *ufunc_cotdg_doc = (
    "cotdg(x)\n"
    "\n"
    "Cotangent of the angle `x` given in degrees.")
ufunc_cotdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cotdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cotdg_types[0] = <char>NPY_FLOAT
ufunc_cotdg_types[1] = <char>NPY_FLOAT
ufunc_cotdg_types[2] = <char>NPY_DOUBLE
ufunc_cotdg_types[3] = <char>NPY_DOUBLE
ufunc_cotdg_ptr[2*0] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*0+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_ptr[2*1] = <void*>_func_cotdg
ufunc_cotdg_ptr[2*1+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_data[0] = &ufunc_cotdg_ptr[2*0]
ufunc_cotdg_data[1] = &ufunc_cotdg_ptr[2*1]
cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, "cotdg", ufunc_cotdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]
cdef void *ufunc_dawsn_ptr[8]
cdef void *ufunc_dawsn_data[4]
cdef char ufunc_dawsn_types[8]
cdef char *ufunc_dawsn_doc = (
    "dawsn(x)\n"
    "\n"
    "Dawson's integral.\n"
    "\n"
    "Computes::\n"
    "\n"
    "    exp(-x**2) * integral(exp(t**2), t=0..x).\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-15, 15, num=1000)\n"
    ">>> plt.plot(x, special.dawsn(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$dawsn(x)$')\n"
    ">>> plt.show()")
ufunc_dawsn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_dawsn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_dawsn_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_dawsn_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_dawsn_types[0] = <char>NPY_FLOAT
ufunc_dawsn_types[1] = <char>NPY_FLOAT
ufunc_dawsn_types[2] = <char>NPY_DOUBLE
ufunc_dawsn_types[3] = <char>NPY_DOUBLE
ufunc_dawsn_types[4] = <char>NPY_CFLOAT
ufunc_dawsn_types[5] = <char>NPY_CFLOAT
ufunc_dawsn_types[6] = <char>NPY_CDOUBLE
ufunc_dawsn_types[7] = <char>NPY_CDOUBLE
ufunc_dawsn_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*0+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*1+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*2+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*3+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_data[0] = &ufunc_dawsn_ptr[2*0]
ufunc_dawsn_data[1] = &ufunc_dawsn_ptr[2*1]
ufunc_dawsn_data[2] = &ufunc_dawsn_ptr[2*2]
ufunc_dawsn_data[3] = &ufunc_dawsn_ptr[2*3]
dawsn = np.PyUFunc_FromFuncAndData(ufunc_dawsn_loops, ufunc_dawsn_data, ufunc_dawsn_types, 4, 1, 1, 0, "dawsn", ufunc_dawsn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipe_loops[2]
cdef void *ufunc_ellipe_ptr[4]
cdef void *ufunc_ellipe_data[2]
cdef char ufunc_ellipe_types[4]
cdef char *ufunc_ellipe_doc = (
    "ellipe(m)\n"
    "\n"
    "Complete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(m) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Defines the parameter of the elliptic integral.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpe`.\n"
    "\n"
    "For `m > 0` the computation uses the approximation,\n"
    "\n"
    ".. math:: E(m) \\approx P(1-m) - (1-m) \\log(1-m) Q(1-m),\n"
    "\n"
    "where :math:`P` and :math:`Q` are tenth-order polynomials.  For\n"
    "`m < 0`, the relation\n"
    "\n"
    ".. math:: E(m) = E(m/(m - 1)) \\sqrt(1-m)\n"
    "\n"
    "is used.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_ellipe_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipe_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipe_types[0] = <char>NPY_FLOAT
ufunc_ellipe_types[1] = <char>NPY_FLOAT
ufunc_ellipe_types[2] = <char>NPY_DOUBLE
ufunc_ellipe_types[3] = <char>NPY_DOUBLE
ufunc_ellipe_ptr[2*0] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*0+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_ptr[2*1] = <void*>_func_ellpe
ufunc_ellipe_ptr[2*1+1] = <void*>(<char*>"ellipe")
ufunc_ellipe_data[0] = &ufunc_ellipe_ptr[2*0]
ufunc_ellipe_data[1] = &ufunc_ellipe_ptr[2*1]
ellipe = np.PyUFunc_FromFuncAndData(ufunc_ellipe_loops, ufunc_ellipe_data, ufunc_ellipe_types, 2, 1, 1, 0, "ellipe", ufunc_ellipe_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipeinc_loops[2]
cdef void *ufunc_ellipeinc_ptr[4]
cdef void *ufunc_ellipeinc_data[2]
cdef char ufunc_ellipeinc_types[6]
cdef char *ufunc_ellipeinc_doc = (
    "ellipeinc(phi, m)\n"
    "\n"
    "Incomplete elliptic integral of the second kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: E(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{1/2} dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "phi : array_like\n"
    "    amplitude of the elliptic integral.\n"
    "\n"
    "m : array_like\n"
    "    parameter of the elliptic integral.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "E : ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellie`.\n"
    "\n"
    "Computation uses arithmetic-geometric means algorithm.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_ellipeinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ellipeinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ellipeinc_types[0] = <char>NPY_FLOAT
ufunc_ellipeinc_types[1] = <char>NPY_FLOAT
ufunc_ellipeinc_types[2] = <char>NPY_FLOAT
ufunc_ellipeinc_types[3] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[4] = <char>NPY_DOUBLE
ufunc_ellipeinc_types[5] = <char>NPY_DOUBLE
ufunc_ellipeinc_ptr[2*0] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*0+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_ptr[2*1] = <void*>_func_ellie
ufunc_ellipeinc_ptr[2*1+1] = <void*>(<char*>"ellipeinc")
ufunc_ellipeinc_data[0] = &ufunc_ellipeinc_ptr[2*0]
ufunc_ellipeinc_data[1] = &ufunc_ellipeinc_ptr[2*1]
ellipeinc = np.PyUFunc_FromFuncAndData(ufunc_ellipeinc_loops, ufunc_ellipeinc_data, ufunc_ellipeinc_types, 2, 2, 1, 0, "ellipeinc", ufunc_ellipeinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipj_loops[2]
cdef void *ufunc_ellipj_ptr[4]
cdef void *ufunc_ellipj_data[2]
cdef char ufunc_ellipj_types[12]
cdef char *ufunc_ellipj_doc = (
    "ellipj(u, m)\n"
    "\n"
    "Jacobian elliptic functions\n"
    "\n"
    "Calculates the Jacobian elliptic functions of parameter `m` between\n"
    "0 and 1, and real argument `u`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Parameter.\n"
    "u : array_like\n"
    "    Argument.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "sn, cn, dn, ph : ndarrays\n"
    "    The returned functions::\n"
    "\n"
    "        sn(u|m), cn(u|m), dn(u|m)\n"
    "\n"
    "    The value `ph` is such that if `u = ellipk(ph, m)`,\n"
    "    then `sn(u|m) = sin(ph)` and `cn(u|m) = cos(ph)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpj`.\n"
    "\n"
    "These functions are periodic, with quarter-period on the real axis\n"
    "equal to the complete elliptic integral `ellipk(m)`.\n"
    "\n"
    "Relation to incomplete elliptic integral: If `u = ellipk(phi,m)`, then\n"
    "`sn(u|m) = sin(phi)`, and `cn(u|m) = cos(phi)`.  The `phi` is called\n"
    "the amplitude of `u`.\n"
    "\n"
    "Computation is by means of the arithmetic-geometric mean algorithm,\n"
    "except when `m` is within 1e-9 of 0 or 1.  In the latter case with `m`\n"
    "close to 1, the approximation applies only for `phi < pi/2`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "ellipk : Complete elliptic integral of the first kind.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_ellipj_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dddd_As_ff_ffff
ufunc_ellipj_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dddd_As_dd_dddd
ufunc_ellipj_types[0] = <char>NPY_FLOAT
ufunc_ellipj_types[1] = <char>NPY_FLOAT
ufunc_ellipj_types[2] = <char>NPY_FLOAT
ufunc_ellipj_types[3] = <char>NPY_FLOAT
ufunc_ellipj_types[4] = <char>NPY_FLOAT
ufunc_ellipj_types[5] = <char>NPY_FLOAT
ufunc_ellipj_types[6] = <char>NPY_DOUBLE
ufunc_ellipj_types[7] = <char>NPY_DOUBLE
ufunc_ellipj_types[8] = <char>NPY_DOUBLE
ufunc_ellipj_types[9] = <char>NPY_DOUBLE
ufunc_ellipj_types[10] = <char>NPY_DOUBLE
ufunc_ellipj_types[11] = <char>NPY_DOUBLE
ufunc_ellipj_ptr[2*0] = <void*>_func_ellpj
ufunc_ellipj_ptr[2*0+1] = <void*>(<char*>"ellipj")
ufunc_ellipj_ptr[2*1] = <void*>_func_ellpj
ufunc_ellipj_ptr[2*1+1] = <void*>(<char*>"ellipj")
ufunc_ellipj_data[0] = &ufunc_ellipj_ptr[2*0]
ufunc_ellipj_data[1] = &ufunc_ellipj_ptr[2*1]
ellipj = np.PyUFunc_FromFuncAndData(ufunc_ellipj_loops, ufunc_ellipj_data, ufunc_ellipj_types, 2, 2, 4, 0, "ellipj", ufunc_ellipj_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipkinc_loops[2]
cdef void *ufunc_ellipkinc_ptr[4]
cdef void *ufunc_ellipkinc_data[2]
cdef char ufunc_ellipkinc_types[6]
cdef char *ufunc_ellipkinc_doc = (
    "ellipkinc(phi, m)\n"
    "\n"
    "Incomplete elliptic integral of the first kind\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: K(\\phi, m) = \\int_0^{\\phi} [1 - m \\sin(t)^2]^{-1/2} dt\n"
    "\n"
    "This function is also called `F(phi, m)`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "phi : array_like\n"
    "    amplitude of the elliptic integral\n"
    "\n"
    "m : array_like\n"
    "    parameter of the elliptic integral\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the elliptic integral\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellik`.  The computation is\n"
    "carried out using the arithmetic-geometric mean algorithm.\n"
    "\n"
    "The parameterization in terms of :math:`m` follows that of section\n"
    "17.2 in [2]_. Other parameterizations in terms of the\n"
    "complementary parameter :math:`1 - m`, modular angle\n"
    ":math:`\\sin^2(\\alpha) = m`, or modulus :math:`k^2 = m` are also\n"
    "used, so be careful that you choose the correct parameter.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipkm1 : Complete elliptic integral of the first kind, near `m` = 1\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_ellipkinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ellipkinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ellipkinc_types[0] = <char>NPY_FLOAT
ufunc_ellipkinc_types[1] = <char>NPY_FLOAT
ufunc_ellipkinc_types[2] = <char>NPY_FLOAT
ufunc_ellipkinc_types[3] = <char>NPY_DOUBLE
ufunc_ellipkinc_types[4] = <char>NPY_DOUBLE
ufunc_ellipkinc_types[5] = <char>NPY_DOUBLE
ufunc_ellipkinc_ptr[2*0] = <void*>_func_ellik
ufunc_ellipkinc_ptr[2*0+1] = <void*>(<char*>"ellipkinc")
ufunc_ellipkinc_ptr[2*1] = <void*>_func_ellik
ufunc_ellipkinc_ptr[2*1+1] = <void*>(<char*>"ellipkinc")
ufunc_ellipkinc_data[0] = &ufunc_ellipkinc_ptr[2*0]
ufunc_ellipkinc_data[1] = &ufunc_ellipkinc_ptr[2*1]
ellipkinc = np.PyUFunc_FromFuncAndData(ufunc_ellipkinc_loops, ufunc_ellipkinc_data, ufunc_ellipkinc_types, 2, 2, 1, 0, "ellipkinc", ufunc_ellipkinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ellipkm1_loops[2]
cdef void *ufunc_ellipkm1_ptr[4]
cdef void *ufunc_ellipkm1_data[2]
cdef char ufunc_ellipkm1_types[4]
cdef char *ufunc_ellipkm1_doc = (
    "ellipkm1(p)\n"
    "\n"
    "Complete elliptic integral of the first kind around `m` = 1\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: K(p) = \\int_0^{\\pi/2} [1 - m \\sin(t)^2]^{-1/2} dt\n"
    "\n"
    "where `m = 1 - p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Defines the parameter of the elliptic integral as `m = 1 - p`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the elliptic integral.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `ellpk`.\n"
    "\n"
    "For `p <= 1`, computation uses the approximation,\n"
    "\n"
    ".. math:: K(p) \\approx P(p) - \\log(p) Q(p),\n"
    "\n"
    "where :math:`P` and :math:`Q` are tenth-order polynomials.  The\n"
    "argument `p` is used internally rather than `m` so that the logarithmic\n"
    "singularity at `m = 1` will be shifted to the origin; this preserves\n"
    "maximum accuracy.  For `p > 1`, the identity\n"
    "\n"
    ".. math:: K(p) = K(1/p)/\\sqrt(p)\n"
    "\n"
    "is used.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ellipk : Complete elliptic integral of the first kind\n"
    "ellipkinc : Incomplete elliptic integral of the first kind\n"
    "ellipe : Complete elliptic integral of the second kind\n"
    "ellipeinc : Incomplete elliptic integral of the second kind\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_ellipkm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ellipkm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ellipkm1_types[0] = <char>NPY_FLOAT
ufunc_ellipkm1_types[1] = <char>NPY_FLOAT
ufunc_ellipkm1_types[2] = <char>NPY_DOUBLE
ufunc_ellipkm1_types[3] = <char>NPY_DOUBLE
ufunc_ellipkm1_ptr[2*0] = <void*>_func_ellpk
ufunc_ellipkm1_ptr[2*0+1] = <void*>(<char*>"ellipkm1")
ufunc_ellipkm1_ptr[2*1] = <void*>_func_ellpk
ufunc_ellipkm1_ptr[2*1+1] = <void*>(<char*>"ellipkm1")
ufunc_ellipkm1_data[0] = &ufunc_ellipkm1_ptr[2*0]
ufunc_ellipkm1_data[1] = &ufunc_ellipkm1_ptr[2*1]
ellipkm1 = np.PyUFunc_FromFuncAndData(ufunc_ellipkm1_loops, ufunc_ellipkm1_data, ufunc_ellipkm1_types, 2, 1, 1, 0, "ellipkm1", ufunc_ellipkm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_entr_loops[2]
cdef void *ufunc_entr_ptr[4]
cdef void *ufunc_entr_data[2]
cdef char ufunc_entr_types[4]
cdef char *ufunc_entr_doc = (
    "entr(x)\n"
    "\n"
    "Elementwise function for computing entropy.\n"
    "\n"
    ".. math:: \\text{entr}(x) = \\begin{cases} - x \\log(x) & x > 0  \\\\ 0 & x = 0 \\\\ -\\infty & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    The value of the elementwise entropy function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kl_div, rel_entr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is concave.\n"
    "\n"
    ".. versionadded:: 0.15.0")
ufunc_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_entr_types[0] = <char>NPY_FLOAT
ufunc_entr_types[1] = <char>NPY_FLOAT
ufunc_entr_types[2] = <char>NPY_DOUBLE
ufunc_entr_types[3] = <char>NPY_DOUBLE
ufunc_entr_ptr[2*0] = <void*>_func_entr
ufunc_entr_ptr[2*0+1] = <void*>(<char*>"entr")
ufunc_entr_ptr[2*1] = <void*>_func_entr
ufunc_entr_ptr[2*1+1] = <void*>(<char*>"entr")
ufunc_entr_data[0] = &ufunc_entr_ptr[2*0]
ufunc_entr_data[1] = &ufunc_entr_ptr[2*1]
entr = np.PyUFunc_FromFuncAndData(ufunc_entr_loops, ufunc_entr_data, ufunc_entr_types, 2, 1, 1, 0, "entr", ufunc_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erf_loops[4]
cdef void *ufunc_erf_ptr[8]
cdef void *ufunc_erf_data[4]
cdef char ufunc_erf_types[8]
cdef char *ufunc_erf_doc = (
    "erf(z)\n"
    "\n"
    "Returns the error function of complex argument.\n"
    "\n"
    "It is defined as ``2/sqrt(pi)*integral(exp(-t**2), t=0..z)``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    The values of the error function at the given points `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erfc, erfinv, erfcinv, wofz, erfcx, erfi\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The cumulative of the unit normal distribution is given by\n"
    "``Phi(z) = 1/2[1 + erf(z/sqrt(2))]``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] http://en.wikipedia.org/wiki/Error_function\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "    Handbook of Mathematical Functions with Formulas,\n"
    "    Graphs, and Mathematical Tables. New York: Dover,\n"
    "    1972. http://www.math.sfu.ca/~cbm/aands/page_297.htm\n"
    ".. [3] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erf(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erf(x)$')\n"
    ">>> plt.show()")
ufunc_erf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erf_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erf_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erf_types[0] = <char>NPY_FLOAT
ufunc_erf_types[1] = <char>NPY_FLOAT
ufunc_erf_types[2] = <char>NPY_DOUBLE
ufunc_erf_types[3] = <char>NPY_DOUBLE
ufunc_erf_types[4] = <char>NPY_CFLOAT
ufunc_erf_types[5] = <char>NPY_CFLOAT
ufunc_erf_types[6] = <char>NPY_CDOUBLE
ufunc_erf_types[7] = <char>NPY_CDOUBLE
ufunc_erf_ptr[2*0] = <void*>_func_erf
ufunc_erf_ptr[2*0+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*1] = <void*>_func_erf
ufunc_erf_ptr[2*1+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*2+1] = <void*>(<char*>"erf")
ufunc_erf_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erf
ufunc_erf_ptr[2*3+1] = <void*>(<char*>"erf")
ufunc_erf_data[0] = &ufunc_erf_ptr[2*0]
ufunc_erf_data[1] = &ufunc_erf_ptr[2*1]
ufunc_erf_data[2] = &ufunc_erf_ptr[2*2]
ufunc_erf_data[3] = &ufunc_erf_ptr[2*3]
erf = np.PyUFunc_FromFuncAndData(ufunc_erf_loops, ufunc_erf_data, ufunc_erf_types, 4, 1, 1, 0, "erf", ufunc_erf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfc_loops[4]
cdef void *ufunc_erfc_ptr[8]
cdef void *ufunc_erfc_data[4]
cdef char ufunc_erfc_types[8]
cdef char *ufunc_erfc_doc = (
    "erfc(x)\n"
    "\n"
    "Complementary error function, ``1 - erf(x)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfi, erfcx, dawsn, wofz\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfc(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfc(x)$')\n"
    ">>> plt.show()")
ufunc_erfc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfc_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfc_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfc_types[0] = <char>NPY_FLOAT
ufunc_erfc_types[1] = <char>NPY_FLOAT
ufunc_erfc_types[2] = <char>NPY_DOUBLE
ufunc_erfc_types[3] = <char>NPY_DOUBLE
ufunc_erfc_types[4] = <char>NPY_CFLOAT
ufunc_erfc_types[5] = <char>NPY_CFLOAT
ufunc_erfc_types[6] = <char>NPY_CDOUBLE
ufunc_erfc_types[7] = <char>NPY_CDOUBLE
ufunc_erfc_ptr[2*0] = <void*>_func_erfc
ufunc_erfc_ptr[2*0+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*1] = <void*>_func_erfc
ufunc_erfc_ptr[2*1+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc
ufunc_erfc_ptr[2*2+1] = <void*>(<char*>"erfc")
ufunc_erfc_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfc
ufunc_erfc_ptr[2*3+1] = <void*>(<char*>"erfc")
ufunc_erfc_data[0] = &ufunc_erfc_ptr[2*0]
ufunc_erfc_data[1] = &ufunc_erfc_ptr[2*1]
ufunc_erfc_data[2] = &ufunc_erfc_ptr[2*2]
ufunc_erfc_data[3] = &ufunc_erfc_ptr[2*3]
erfc = np.PyUFunc_FromFuncAndData(ufunc_erfc_loops, ufunc_erfc_data, ufunc_erfc_types, 4, 1, 1, 0, "erfc", ufunc_erfc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfcx_loops[4]
cdef void *ufunc_erfcx_ptr[8]
cdef void *ufunc_erfcx_data[4]
cdef char ufunc_erfcx_types[8]
cdef char *ufunc_erfcx_doc = (
    "erfcx(x)\n"
    "\n"
    "Scaled complementary error function, ``exp(x**2) * erfc(x)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfi, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfcx(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfcx(x)$')\n"
    ">>> plt.show()")
ufunc_erfcx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfcx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfcx_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfcx_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfcx_types[0] = <char>NPY_FLOAT
ufunc_erfcx_types[1] = <char>NPY_FLOAT
ufunc_erfcx_types[2] = <char>NPY_DOUBLE
ufunc_erfcx_types[3] = <char>NPY_DOUBLE
ufunc_erfcx_types[4] = <char>NPY_CFLOAT
ufunc_erfcx_types[5] = <char>NPY_CFLOAT
ufunc_erfcx_types[6] = <char>NPY_CDOUBLE
ufunc_erfcx_types[7] = <char>NPY_CDOUBLE
ufunc_erfcx_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*0+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx
ufunc_erfcx_ptr[2*1+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*2+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfcx_complex
ufunc_erfcx_ptr[2*3+1] = <void*>(<char*>"erfcx")
ufunc_erfcx_data[0] = &ufunc_erfcx_ptr[2*0]
ufunc_erfcx_data[1] = &ufunc_erfcx_ptr[2*1]
ufunc_erfcx_data[2] = &ufunc_erfcx_ptr[2*2]
ufunc_erfcx_data[3] = &ufunc_erfcx_ptr[2*3]
erfcx = np.PyUFunc_FromFuncAndData(ufunc_erfcx_loops, ufunc_erfcx_data, ufunc_erfcx_types, 4, 1, 1, 0, "erfcx", ufunc_erfcx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_erfi_loops[4]
cdef void *ufunc_erfi_ptr[8]
cdef void *ufunc_erfi_data[4]
cdef char ufunc_erfi_types[8]
cdef char *ufunc_erfi_doc = (
    "erfi(z)\n"
    "\n"
    "Imaginary error function, ``-i erf(i z)``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf, erfc, erfcx, dawsn, wofz\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.12.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.erfi(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$erfi(x)$')\n"
    ">>> plt.show()")
ufunc_erfi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_erfi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_erfi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_erfi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_erfi_types[0] = <char>NPY_FLOAT
ufunc_erfi_types[1] = <char>NPY_FLOAT
ufunc_erfi_types[2] = <char>NPY_DOUBLE
ufunc_erfi_types[3] = <char>NPY_DOUBLE
ufunc_erfi_types[4] = <char>NPY_CFLOAT
ufunc_erfi_types[5] = <char>NPY_CFLOAT
ufunc_erfi_types[6] = <char>NPY_CDOUBLE
ufunc_erfi_types[7] = <char>NPY_CDOUBLE
ufunc_erfi_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*0+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi
ufunc_erfi_ptr[2*1+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*2+1] = <void*>(<char*>"erfi")
ufunc_erfi_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_erfi_complex
ufunc_erfi_ptr[2*3+1] = <void*>(<char*>"erfi")
ufunc_erfi_data[0] = &ufunc_erfi_ptr[2*0]
ufunc_erfi_data[1] = &ufunc_erfi_ptr[2*1]
ufunc_erfi_data[2] = &ufunc_erfi_ptr[2*2]
ufunc_erfi_data[3] = &ufunc_erfi_ptr[2*3]
erfi = np.PyUFunc_FromFuncAndData(ufunc_erfi_loops, ufunc_erfi_data, ufunc_erfi_types, 4, 1, 1, 0, "erfi", ufunc_erfi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyc_loops[5]
cdef void *ufunc_eval_chebyc_ptr[10]
cdef void *ufunc_eval_chebyc_data[5]
cdef char ufunc_eval_chebyc_types[15]
cdef char *ufunc_eval_chebyc_doc = (
    "eval_chebyc(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S_n(x) = T_n(x/2)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyc : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind on [-2, 2]\n"
    "chebyc : Chebyshev polynomial object\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "eval_chebyt : evaluate Chebycshev polynomials of the first kind")
ufunc_eval_chebyc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyc_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyc_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyc_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyc_types[0] = <char>NPY_LONG
ufunc_eval_chebyc_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyc_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyc_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyc_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyc_ptr[2*0] = <void*>_func_eval_chebyc_l
ufunc_eval_chebyc_ptr[2*0+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*1] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*1+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*2] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*2+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*3] = <void*>_func_eval_chebyc[double]
ufunc_eval_chebyc_ptr[2*3+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_ptr[2*4] = <void*>_func_eval_chebyc[double_complex]
ufunc_eval_chebyc_ptr[2*4+1] = <void*>(<char*>"eval_chebyc")
ufunc_eval_chebyc_data[0] = &ufunc_eval_chebyc_ptr[2*0]
ufunc_eval_chebyc_data[1] = &ufunc_eval_chebyc_ptr[2*1]
ufunc_eval_chebyc_data[2] = &ufunc_eval_chebyc_ptr[2*2]
ufunc_eval_chebyc_data[3] = &ufunc_eval_chebyc_ptr[2*3]
ufunc_eval_chebyc_data[4] = &ufunc_eval_chebyc_ptr[2*4]
eval_chebyc = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyc_loops, ufunc_eval_chebyc_data, ufunc_eval_chebyc_types, 5, 2, 1, 0, "eval_chebyc", ufunc_eval_chebyc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebys_loops[5]
cdef void *ufunc_eval_chebys_ptr[10]
cdef void *ufunc_eval_chebys_data[5]
cdef char ufunc_eval_chebys_types[15]
cdef char *ufunc_eval_chebys_doc = (
    "eval_chebys(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind on [-2, 2] at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    S_n(x) = U_n(x/2)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the second kind.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "S : ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebys : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind on [-2, 2]\n"
    "chebys : Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind")
ufunc_eval_chebys_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebys_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebys_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebys_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebys_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebys_types[0] = <char>NPY_LONG
ufunc_eval_chebys_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[3] = <char>NPY_FLOAT
ufunc_eval_chebys_types[4] = <char>NPY_FLOAT
ufunc_eval_chebys_types[5] = <char>NPY_FLOAT
ufunc_eval_chebys_types[6] = <char>NPY_FLOAT
ufunc_eval_chebys_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebys_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebys_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebys_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebys_ptr[2*0] = <void*>_func_eval_chebys_l
ufunc_eval_chebys_ptr[2*0+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*1] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*1+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*2] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*2+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*3] = <void*>_func_eval_chebys[double]
ufunc_eval_chebys_ptr[2*3+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_ptr[2*4] = <void*>_func_eval_chebys[double_complex]
ufunc_eval_chebys_ptr[2*4+1] = <void*>(<char*>"eval_chebys")
ufunc_eval_chebys_data[0] = &ufunc_eval_chebys_ptr[2*0]
ufunc_eval_chebys_data[1] = &ufunc_eval_chebys_ptr[2*1]
ufunc_eval_chebys_data[2] = &ufunc_eval_chebys_ptr[2*2]
ufunc_eval_chebys_data[3] = &ufunc_eval_chebys_ptr[2*3]
ufunc_eval_chebys_data[4] = &ufunc_eval_chebys_ptr[2*4]
eval_chebys = np.PyUFunc_FromFuncAndData(ufunc_eval_chebys_loops, ufunc_eval_chebys_data, ufunc_eval_chebys_types, 5, 2, 1, 0, "eval_chebys", ufunc_eval_chebys_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyt_loops[5]
cdef void *ufunc_eval_chebyt_ptr[10]
cdef void *ufunc_eval_chebyt_data[5]
cdef char ufunc_eval_chebyt_types[15]
cdef char *ufunc_eval_chebyt_doc = (
    "eval_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the first kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the first kind can be defined via the\n"
    "Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n(x) = {}_2F_1(n, -n; 1/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyt : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the first kind\n"
    "chebyu : Chebychev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This routine is numerically stable for `x` in ``[-1, 1]`` at least\n"
    "up to order ``10000``.")
ufunc_eval_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyt_types[0] = <char>NPY_LONG
ufunc_eval_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyt_ptr[2*0] = <void*>_func_eval_chebyt_l
ufunc_eval_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*1] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*2] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*3] = <void*>_func_eval_chebyt[double]
ufunc_eval_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_ptr[2*4] = <void*>_func_eval_chebyt[double_complex]
ufunc_eval_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_chebyt")
ufunc_eval_chebyt_data[0] = &ufunc_eval_chebyt_ptr[2*0]
ufunc_eval_chebyt_data[1] = &ufunc_eval_chebyt_ptr[2*1]
ufunc_eval_chebyt_data[2] = &ufunc_eval_chebyt_ptr[2*2]
ufunc_eval_chebyt_data[3] = &ufunc_eval_chebyt_ptr[2*3]
ufunc_eval_chebyt_data[4] = &ufunc_eval_chebyt_ptr[2*4]
eval_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyt_loops, ufunc_eval_chebyt_data, ufunc_eval_chebyt_types, 5, 2, 1, 0, "eval_chebyt", ufunc_eval_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_chebyu_loops[5]
cdef void *ufunc_eval_chebyu_ptr[10]
cdef void *ufunc_eval_chebyu_data[5]
cdef char ufunc_eval_chebyu_types[15]
cdef char *ufunc_eval_chebyu_doc = (
    "eval_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate Chebyshev polynomial of the second kind at a point.\n"
    "\n"
    "The Chebyshev polynomials of the second kind can be defined via\n"
    "the Gauss hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n(x) = (n + 1) {}_2F_1(-n, n + 2; 3/2; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : ndarray\n"
    "    Values of the Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_chebyu : roots and quadrature weights of Chebyshev\n"
    "               polynomials of the second kind\n"
    "chebyu : Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "hyp2f1 : Gauss hypergeometric function")
ufunc_eval_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_chebyu_types[0] = <char>NPY_LONG
ufunc_eval_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_chebyu_ptr[2*0] = <void*>_func_eval_chebyu_l
ufunc_eval_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*1] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*2] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*3] = <void*>_func_eval_chebyu[double]
ufunc_eval_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_ptr[2*4] = <void*>_func_eval_chebyu[double_complex]
ufunc_eval_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_chebyu")
ufunc_eval_chebyu_data[0] = &ufunc_eval_chebyu_ptr[2*0]
ufunc_eval_chebyu_data[1] = &ufunc_eval_chebyu_ptr[2*1]
ufunc_eval_chebyu_data[2] = &ufunc_eval_chebyu_ptr[2*2]
ufunc_eval_chebyu_data[3] = &ufunc_eval_chebyu_ptr[2*3]
ufunc_eval_chebyu_data[4] = &ufunc_eval_chebyu_ptr[2*4]
eval_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_chebyu_loops, ufunc_eval_chebyu_data, ufunc_eval_chebyu_types, 5, 2, 1, 0, "eval_chebyu", ufunc_eval_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_gegenbauer_loops[5]
cdef void *ufunc_eval_gegenbauer_ptr[10]
cdef void *ufunc_eval_gegenbauer_data[5]
cdef char ufunc_eval_gegenbauer_types[20]
cdef char *ufunc_eval_gegenbauer_doc = (
    "eval_gegenbauer(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate Gegenbauer polynomial at a point.\n"
    "\n"
    "The Gegenbauer polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    C_n^{(\\alpha)} = \\frac{(2\\alpha)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 2\\alpha + n; \\alpha + 1/2; (1 - z)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the Gegenbauer polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "C : ndarray\n"
    "    Values of the Gegenbauer polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_gegenbauer : roots and quadrature weights of Gegenbauer\n"
    "                   polynomials\n"
    "gegenbauer : Gegenbauer polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function")
ufunc_eval_gegenbauer_loops[0] = <np.PyUFuncGenericFunction>loop_d_ldd__As_ldd_d
ufunc_eval_gegenbauer_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_gegenbauer_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_gegenbauer_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_gegenbauer_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_gegenbauer_types[0] = <char>NPY_LONG
ufunc_eval_gegenbauer_types[1] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[2] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[3] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[4] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[5] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[6] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[7] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[8] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[9] = <char>NPY_FLOAT
ufunc_eval_gegenbauer_types[10] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[11] = <char>NPY_CFLOAT
ufunc_eval_gegenbauer_types[12] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[13] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[14] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[15] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[16] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[17] = <char>NPY_DOUBLE
ufunc_eval_gegenbauer_types[18] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_types[19] = <char>NPY_CDOUBLE
ufunc_eval_gegenbauer_ptr[2*0] = <void*>_func_eval_gegenbauer_l
ufunc_eval_gegenbauer_ptr[2*0+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*1] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*1+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*2] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*2+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*3] = <void*>_func_eval_gegenbauer[double]
ufunc_eval_gegenbauer_ptr[2*3+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_ptr[2*4] = <void*>_func_eval_gegenbauer[double_complex]
ufunc_eval_gegenbauer_ptr[2*4+1] = <void*>(<char*>"eval_gegenbauer")
ufunc_eval_gegenbauer_data[0] = &ufunc_eval_gegenbauer_ptr[2*0]
ufunc_eval_gegenbauer_data[1] = &ufunc_eval_gegenbauer_ptr[2*1]
ufunc_eval_gegenbauer_data[2] = &ufunc_eval_gegenbauer_ptr[2*2]
ufunc_eval_gegenbauer_data[3] = &ufunc_eval_gegenbauer_ptr[2*3]
ufunc_eval_gegenbauer_data[4] = &ufunc_eval_gegenbauer_ptr[2*4]
eval_gegenbauer = np.PyUFunc_FromFuncAndData(ufunc_eval_gegenbauer_loops, ufunc_eval_gegenbauer_data, ufunc_eval_gegenbauer_types, 5, 3, 1, 0, "eval_gegenbauer", ufunc_eval_gegenbauer_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_genlaguerre_loops[5]
cdef void *ufunc_eval_genlaguerre_ptr[10]
cdef void *ufunc_eval_genlaguerre_data[5]
cdef char ufunc_eval_genlaguerre_types[20]
cdef char *ufunc_eval_genlaguerre_doc = (
    "eval_genlaguerre(n, alpha, x, out=None)\n"
    "\n"
    "Evaluate generalized Laguerre polynomial at a point.\n"
    "\n"
    "The generalized Laguerre polynomials can be defined via the\n"
    "confluent hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n^{(\\alpha)}(x) = \\binom{n + \\alpha}{n}\n"
    "      {}_1F_1(-n, \\alpha + 1, x).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`. The Laguerre polynomials are the special case where\n"
    ":math:`\\alpha = 0`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter; must have ``alpha > -1``\n"
    "x : array_like\n"
    "    Points at which to evaluate the generalized Laguerre\n"
    "    polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : ndarray\n"
    "    Values of the generalized Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_genlaguerre : roots and quadrature weights of generalized\n"
    "                    Laguerre polynomials\n"
    "genlaguerre : generalized Laguerre polynomial object\n"
    "hyp1f1 : confluent hypergeometric function\n"
    "eval_laguerre : evaluate Laguerre polynomials")
ufunc_eval_genlaguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ldd__As_ldd_d
ufunc_eval_genlaguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_eval_genlaguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_eval_genlaguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_eval_genlaguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_eval_genlaguerre_types[0] = <char>NPY_LONG
ufunc_eval_genlaguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[3] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[7] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[8] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[9] = <char>NPY_FLOAT
ufunc_eval_genlaguerre_types[10] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[11] = <char>NPY_CFLOAT
ufunc_eval_genlaguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[13] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[14] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[15] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[16] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[17] = <char>NPY_DOUBLE
ufunc_eval_genlaguerre_types[18] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_types[19] = <char>NPY_CDOUBLE
ufunc_eval_genlaguerre_ptr[2*0] = <void*>_func_eval_genlaguerre_l
ufunc_eval_genlaguerre_ptr[2*0+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*1] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*1+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*2] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*2+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*3] = <void*>_func_eval_genlaguerre[double]
ufunc_eval_genlaguerre_ptr[2*3+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_ptr[2*4] = <void*>_func_eval_genlaguerre[double_complex]
ufunc_eval_genlaguerre_ptr[2*4+1] = <void*>(<char*>"eval_genlaguerre")
ufunc_eval_genlaguerre_data[0] = &ufunc_eval_genlaguerre_ptr[2*0]
ufunc_eval_genlaguerre_data[1] = &ufunc_eval_genlaguerre_ptr[2*1]
ufunc_eval_genlaguerre_data[2] = &ufunc_eval_genlaguerre_ptr[2*2]
ufunc_eval_genlaguerre_data[3] = &ufunc_eval_genlaguerre_ptr[2*3]
ufunc_eval_genlaguerre_data[4] = &ufunc_eval_genlaguerre_ptr[2*4]
eval_genlaguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_genlaguerre_loops, ufunc_eval_genlaguerre_data, ufunc_eval_genlaguerre_types, 5, 3, 1, 0, "eval_genlaguerre", ufunc_eval_genlaguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermite_loops[1]
cdef void *ufunc_eval_hermite_ptr[2]
cdef void *ufunc_eval_hermite_data[1]
cdef char ufunc_eval_hermite_types[3]
cdef char *ufunc_eval_hermite_doc = (
    "eval_hermite(n, x, out=None)\n"
    "\n"
    "Evaluate physicist's Hermite polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n} e^{-x^2};\n"
    "\n"
    ":math:`H_n` is a polynomial of degree :math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "H : ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermite : roots and quadrature weights of physicist's\n"
    "                Hermite polynomials\n"
    "hermite : physicist's Hermite polynomial object\n"
    "numpy.polynomial.hermite.Hermite : Physicist's Hermite series\n"
    "eval_hermitenorm : evaluate Probabilist's Hermite polynomials")
ufunc_eval_hermite_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_hermite_types[0] = <char>NPY_LONG
ufunc_eval_hermite_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermite_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermite_ptr[2*0] = <void*>_func_eval_hermite
ufunc_eval_hermite_ptr[2*0+1] = <void*>(<char*>"eval_hermite")
ufunc_eval_hermite_data[0] = &ufunc_eval_hermite_ptr[2*0]
eval_hermite = np.PyUFunc_FromFuncAndData(ufunc_eval_hermite_loops, ufunc_eval_hermite_data, ufunc_eval_hermite_types, 1, 2, 1, 0, "eval_hermite", ufunc_eval_hermite_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_hermitenorm_loops[1]
cdef void *ufunc_eval_hermitenorm_ptr[2]
cdef void *ufunc_eval_hermitenorm_data[1]
cdef char ufunc_eval_hermitenorm_types[3]
cdef char *ufunc_eval_hermitenorm_doc = (
    "eval_hermitenorm(n, x, out=None)\n"
    "\n"
    "Evaluate probabilist's (normalized) Hermite polynomial at a\n"
    "point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    He_n(x) = (-1)^n e^{x^2/2} \\frac{d^n}{dx^n} e^{-x^2/2};\n"
    "\n"
    ":math:`He_n` is a polynomial of degree :math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial\n"
    "x : array_like\n"
    "    Points at which to evaluate the Hermite polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "He : ndarray\n"
    "    Values of the Hermite polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_hermitenorm : roots and quadrature weights of probabilist's\n"
    "                    Hermite polynomials\n"
    "hermitenorm : probabilist's Hermite polynomial object\n"
    "numpy.polynomial.hermite_e.HermiteE : Probabilist's Hermite series\n"
    "eval_hermite : evaluate physicist's Hermite polynomials")
ufunc_eval_hermitenorm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_hermitenorm_types[0] = <char>NPY_LONG
ufunc_eval_hermitenorm_types[1] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_types[2] = <char>NPY_DOUBLE
ufunc_eval_hermitenorm_ptr[2*0] = <void*>_func_eval_hermitenorm
ufunc_eval_hermitenorm_ptr[2*0+1] = <void*>(<char*>"eval_hermitenorm")
ufunc_eval_hermitenorm_data[0] = &ufunc_eval_hermitenorm_ptr[2*0]
eval_hermitenorm = np.PyUFunc_FromFuncAndData(ufunc_eval_hermitenorm_loops, ufunc_eval_hermitenorm_data, ufunc_eval_hermitenorm_types, 1, 2, 1, 0, "eval_hermitenorm", ufunc_eval_hermitenorm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_jacobi_loops[5]
cdef void *ufunc_eval_jacobi_ptr[10]
cdef void *ufunc_eval_jacobi_data[5]
cdef char ufunc_eval_jacobi_types[25]
cdef char *ufunc_eval_jacobi_doc = (
    "eval_jacobi(n, alpha, beta, x, out=None)\n"
    "\n"
    "Evaluate Jacobi polynomial at a point.\n"
    "\n"
    "The Jacobi polynomials can be defined via the Gauss hypergeometric\n"
    "function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^{(\\alpha, \\beta)}(x) = \\frac{(\\alpha + 1)_n}{\\Gamma(n + 1)}\n"
    "      {}_2F_1(-n, 1 + \\alpha + \\beta + n; \\alpha + 1; (1 - z)/2)\n"
    "\n"
    "where :math:`(\\cdot)_n` is the Pochhammer symbol; see `poch`. When\n"
    ":math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "alpha : array_like\n"
    "    Parameter\n"
    "beta : array_like\n"
    "    Parameter\n"
    "x : array_like\n"
    "    Points at which to evaluate the polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : ndarray\n"
    "    Values of the Jacobi polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_jacobi : roots and quadrature weights of Jacobi polynomials\n"
    "jacobi : Jacobi polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function")
ufunc_eval_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_lddd__As_lddd_d
ufunc_eval_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_jacobi_types[0] = <char>NPY_LONG
ufunc_eval_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_jacobi_ptr[2*0] = <void*>_func_eval_jacobi_l
ufunc_eval_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*1] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*2] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*3] = <void*>_func_eval_jacobi[double]
ufunc_eval_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_ptr[2*4] = <void*>_func_eval_jacobi[double_complex]
ufunc_eval_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_jacobi")
ufunc_eval_jacobi_data[0] = &ufunc_eval_jacobi_ptr[2*0]
ufunc_eval_jacobi_data[1] = &ufunc_eval_jacobi_ptr[2*1]
ufunc_eval_jacobi_data[2] = &ufunc_eval_jacobi_ptr[2*2]
ufunc_eval_jacobi_data[3] = &ufunc_eval_jacobi_ptr[2*3]
ufunc_eval_jacobi_data[4] = &ufunc_eval_jacobi_ptr[2*4]
eval_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_jacobi_loops, ufunc_eval_jacobi_data, ufunc_eval_jacobi_types, 5, 4, 1, 0, "eval_jacobi", ufunc_eval_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_laguerre_loops[5]
cdef void *ufunc_eval_laguerre_ptr[10]
cdef void *ufunc_eval_laguerre_data[5]
cdef char ufunc_eval_laguerre_types[15]
cdef char *ufunc_eval_laguerre_doc = (
    "eval_laguerre(n, x, out=None)\n"
    "\n"
    "Evaluate Laguerre polynomial at a point.\n"
    "\n"
    "The Laguerre polynomials can be defined via the confluent\n"
    "hypergeometric function :math:`{}_1F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    L_n(x) = {}_1F_1(-n, 1, x).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer the result is\n"
    "    determined via the relation to the confluent hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Laguerre polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : ndarray\n"
    "    Values of the Laguerre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_laguerre : roots and quadrature weights of Laguerre\n"
    "                 polynomials\n"
    "laguerre : Laguerre polynomial object\n"
    "numpy.polynomial.laguerre.Laguerre : Laguerre series\n"
    "eval_genlaguerre : evaluate generalized Laguerre polynomials")
ufunc_eval_laguerre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_laguerre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_laguerre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_laguerre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_laguerre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_laguerre_types[0] = <char>NPY_LONG
ufunc_eval_laguerre_types[1] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[2] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[3] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[4] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[5] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[6] = <char>NPY_FLOAT
ufunc_eval_laguerre_types[7] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[8] = <char>NPY_CFLOAT
ufunc_eval_laguerre_types[9] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[10] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[11] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[12] = <char>NPY_DOUBLE
ufunc_eval_laguerre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_laguerre_ptr[2*0] = <void*>_func_eval_laguerre_l
ufunc_eval_laguerre_ptr[2*0+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*1] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*1+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*2] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*2+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*3] = <void*>_func_eval_laguerre[double]
ufunc_eval_laguerre_ptr[2*3+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_ptr[2*4] = <void*>_func_eval_laguerre[double_complex]
ufunc_eval_laguerre_ptr[2*4+1] = <void*>(<char*>"eval_laguerre")
ufunc_eval_laguerre_data[0] = &ufunc_eval_laguerre_ptr[2*0]
ufunc_eval_laguerre_data[1] = &ufunc_eval_laguerre_ptr[2*1]
ufunc_eval_laguerre_data[2] = &ufunc_eval_laguerre_ptr[2*2]
ufunc_eval_laguerre_data[3] = &ufunc_eval_laguerre_ptr[2*3]
ufunc_eval_laguerre_data[4] = &ufunc_eval_laguerre_ptr[2*4]
eval_laguerre = np.PyUFunc_FromFuncAndData(ufunc_eval_laguerre_loops, ufunc_eval_laguerre_data, ufunc_eval_laguerre_types, 5, 2, 1, 0, "eval_laguerre", ufunc_eval_laguerre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_legendre_loops[5]
cdef void *ufunc_eval_legendre_ptr[10]
cdef void *ufunc_eval_legendre_data[5]
cdef char ufunc_eval_legendre_types[15]
cdef char *ufunc_eval_legendre_doc = (
    "eval_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate Legendre polynomial at a point.\n"
    "\n"
    "The Legendre polynomials can be defined via the Gauss\n"
    "hypergeometric function :math:`{}_2F_1` as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n(x) = {}_2F_1(-n, n + 1; 1; (1 - x)/2).\n"
    "\n"
    "When :math:`n` is an integer the result is a polynomial of degree\n"
    ":math:`n`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to the Gauss hypergeometric\n"
    "    function.\n"
    "x : array_like\n"
    "    Points at which to evaluate the Legendre polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : ndarray\n"
    "    Values of the Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_legendre : roots and quadrature weights of Legendre\n"
    "                 polynomials\n"
    "legendre : Legendre polynomial object\n"
    "hyp2f1 : Gauss hypergeometric function\n"
    "numpy.polynomial.legendre.Legendre : Legendre series")
ufunc_eval_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_legendre_types[0] = <char>NPY_LONG
ufunc_eval_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_legendre_ptr[2*0] = <void*>_func_eval_legendre_l
ufunc_eval_legendre_ptr[2*0+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*1] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*1+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*2] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*2+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*3] = <void*>_func_eval_legendre[double]
ufunc_eval_legendre_ptr[2*3+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_ptr[2*4] = <void*>_func_eval_legendre[double_complex]
ufunc_eval_legendre_ptr[2*4+1] = <void*>(<char*>"eval_legendre")
ufunc_eval_legendre_data[0] = &ufunc_eval_legendre_ptr[2*0]
ufunc_eval_legendre_data[1] = &ufunc_eval_legendre_ptr[2*1]
ufunc_eval_legendre_data[2] = &ufunc_eval_legendre_ptr[2*2]
ufunc_eval_legendre_data[3] = &ufunc_eval_legendre_ptr[2*3]
ufunc_eval_legendre_data[4] = &ufunc_eval_legendre_ptr[2*4]
eval_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_legendre_loops, ufunc_eval_legendre_data, ufunc_eval_legendre_types, 5, 2, 1, 0, "eval_legendre", ufunc_eval_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyt_loops[5]
cdef void *ufunc_eval_sh_chebyt_ptr[10]
cdef void *ufunc_eval_sh_chebyt_data[5]
cdef char ufunc_eval_sh_chebyt_types[15]
cdef char *ufunc_eval_sh_chebyt_doc = (
    "eval_sh_chebyt(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the first kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    T_n^*(x) = T_n(2x - 1)\n"
    "\n"
    "where :math:`T_n` is a Chebyshev polynomial of the first kind.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyt`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "T : ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyt : roots and quadrature weights of shifted\n"
    "                  Chebyshev polynomials of the first kind\n"
    "sh_chebyt : shifted Chebyshev polynomial object\n"
    "eval_chebyt : evaluate Chebyshev polynomials of the first kind\n"
    "numpy.polynomial.chebyshev.Chebyshev : Chebyshev series")
ufunc_eval_sh_chebyt_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_chebyt_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyt_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyt_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyt_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyt_types[0] = <char>NPY_LONG
ufunc_eval_sh_chebyt_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyt_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyt_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyt_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyt_ptr[2*0] = <void*>_func_eval_sh_chebyt_l
ufunc_eval_sh_chebyt_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*1] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*2] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*3] = <void*>_func_eval_sh_chebyt[double]
ufunc_eval_sh_chebyt_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_ptr[2*4] = <void*>_func_eval_sh_chebyt[double_complex]
ufunc_eval_sh_chebyt_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyt")
ufunc_eval_sh_chebyt_data[0] = &ufunc_eval_sh_chebyt_ptr[2*0]
ufunc_eval_sh_chebyt_data[1] = &ufunc_eval_sh_chebyt_ptr[2*1]
ufunc_eval_sh_chebyt_data[2] = &ufunc_eval_sh_chebyt_ptr[2*2]
ufunc_eval_sh_chebyt_data[3] = &ufunc_eval_sh_chebyt_ptr[2*3]
ufunc_eval_sh_chebyt_data[4] = &ufunc_eval_sh_chebyt_ptr[2*4]
eval_sh_chebyt = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyt_loops, ufunc_eval_sh_chebyt_data, ufunc_eval_sh_chebyt_types, 5, 2, 1, 0, "eval_sh_chebyt", ufunc_eval_sh_chebyt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_chebyu_loops[5]
cdef void *ufunc_eval_sh_chebyu_ptr[10]
cdef void *ufunc_eval_sh_chebyu_data[5]
cdef char ufunc_eval_sh_chebyu_types[15]
cdef char *ufunc_eval_sh_chebyu_doc = (
    "eval_sh_chebyu(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Chebyshev polynomial of the second kind at a\n"
    "point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    U_n^*(x) = U_n(2x - 1)\n"
    "\n"
    "where :math:`U_n` is a Chebyshev polynomial of the first kind.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `eval_chebyu`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Chebyshev polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "U : ndarray\n"
    "    Values of the shifted Chebyshev polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_chebyu : roots and quadrature weights of shifted\n"
    "                  Chebychev polynomials of the second kind\n"
    "sh_chebyu : shifted Chebyshev polynomial object\n"
    "eval_chebyu : evaluate Chebyshev polynomials of the second kind")
ufunc_eval_sh_chebyu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_chebyu_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_chebyu_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_chebyu_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_chebyu_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_chebyu_types[0] = <char>NPY_LONG
ufunc_eval_sh_chebyu_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_chebyu_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_chebyu_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_chebyu_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_chebyu_ptr[2*0] = <void*>_func_eval_sh_chebyu_l
ufunc_eval_sh_chebyu_ptr[2*0+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*1] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*1+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*2] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*2+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*3] = <void*>_func_eval_sh_chebyu[double]
ufunc_eval_sh_chebyu_ptr[2*3+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_ptr[2*4] = <void*>_func_eval_sh_chebyu[double_complex]
ufunc_eval_sh_chebyu_ptr[2*4+1] = <void*>(<char*>"eval_sh_chebyu")
ufunc_eval_sh_chebyu_data[0] = &ufunc_eval_sh_chebyu_ptr[2*0]
ufunc_eval_sh_chebyu_data[1] = &ufunc_eval_sh_chebyu_ptr[2*1]
ufunc_eval_sh_chebyu_data[2] = &ufunc_eval_sh_chebyu_ptr[2*2]
ufunc_eval_sh_chebyu_data[3] = &ufunc_eval_sh_chebyu_ptr[2*3]
ufunc_eval_sh_chebyu_data[4] = &ufunc_eval_sh_chebyu_ptr[2*4]
eval_sh_chebyu = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_chebyu_loops, ufunc_eval_sh_chebyu_data, ufunc_eval_sh_chebyu_types, 5, 2, 1, 0, "eval_sh_chebyu", ufunc_eval_sh_chebyu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_jacobi_loops[5]
cdef void *ufunc_eval_sh_jacobi_ptr[10]
cdef void *ufunc_eval_sh_jacobi_data[5]
cdef char ufunc_eval_sh_jacobi_types[25]
cdef char *ufunc_eval_sh_jacobi_doc = (
    "eval_sh_jacobi(n, p, q, x, out=None)\n"
    "\n"
    "Evaluate shifted Jacobi polynomial at a point.\n"
    "\n"
    "Defined by\n"
    "\n"
    ".. math::\n"
    "\n"
    "    G_n^{(p, q)}(x)\n"
    "      = \\binom{2n + p - 1}{n}^{-1} P_n^{(p - q, q - 1)}(2x - 1),\n"
    "\n"
    "where :math:`P_n^{(\\cdot, \\cdot)}` is the n-th Jacobi polynomial.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : int\n"
    "    Degree of the polynomial. If not an integer, the result is\n"
    "    determined via the relation to `binom` and `eval_jacobi`.\n"
    "p : float\n"
    "    Parameter\n"
    "q : float\n"
    "    Parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "G : ndarray\n"
    "    Values of the shifted Jacobi polynomial.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_jacobi : roots and quadrature weights of shifted Jacobi\n"
    "                  polynomials\n"
    "sh_jacobi : shifted Jacobi polynomial object\n"
    "eval_jacobi : evaluate Jacobi polynomials")
ufunc_eval_sh_jacobi_loops[0] = <np.PyUFuncGenericFunction>loop_d_lddd__As_lddd_d
ufunc_eval_sh_jacobi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_eval_sh_jacobi_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_eval_sh_jacobi_loops[3] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_eval_sh_jacobi_loops[4] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_eval_sh_jacobi_types[0] = <char>NPY_LONG
ufunc_eval_sh_jacobi_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[3] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[4] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[7] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[8] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[9] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[10] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[11] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[12] = <char>NPY_FLOAT
ufunc_eval_sh_jacobi_types[13] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[14] = <char>NPY_CFLOAT
ufunc_eval_sh_jacobi_types[15] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[16] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[17] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[18] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[19] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[20] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[21] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[22] = <char>NPY_DOUBLE
ufunc_eval_sh_jacobi_types[23] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_types[24] = <char>NPY_CDOUBLE
ufunc_eval_sh_jacobi_ptr[2*0] = <void*>_func_eval_sh_jacobi_l
ufunc_eval_sh_jacobi_ptr[2*0+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*1] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*1+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*2] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*2+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*3] = <void*>_func_eval_sh_jacobi[double]
ufunc_eval_sh_jacobi_ptr[2*3+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_ptr[2*4] = <void*>_func_eval_sh_jacobi[double_complex]
ufunc_eval_sh_jacobi_ptr[2*4+1] = <void*>(<char*>"eval_sh_jacobi")
ufunc_eval_sh_jacobi_data[0] = &ufunc_eval_sh_jacobi_ptr[2*0]
ufunc_eval_sh_jacobi_data[1] = &ufunc_eval_sh_jacobi_ptr[2*1]
ufunc_eval_sh_jacobi_data[2] = &ufunc_eval_sh_jacobi_ptr[2*2]
ufunc_eval_sh_jacobi_data[3] = &ufunc_eval_sh_jacobi_ptr[2*3]
ufunc_eval_sh_jacobi_data[4] = &ufunc_eval_sh_jacobi_ptr[2*4]
eval_sh_jacobi = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_jacobi_loops, ufunc_eval_sh_jacobi_data, ufunc_eval_sh_jacobi_types, 5, 4, 1, 0, "eval_sh_jacobi", ufunc_eval_sh_jacobi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_eval_sh_legendre_loops[5]
cdef void *ufunc_eval_sh_legendre_ptr[10]
cdef void *ufunc_eval_sh_legendre_data[5]
cdef char ufunc_eval_sh_legendre_types[15]
cdef char *ufunc_eval_sh_legendre_doc = (
    "eval_sh_legendre(n, x, out=None)\n"
    "\n"
    "Evaluate shifted Legendre polynomial at a point.\n"
    "\n"
    "These polynomials are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_n^*(x) = P_n(2x - 1)\n"
    "\n"
    "where :math:`P_n` is a Legendre polynomial.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Degree of the polynomial. If not an integer, the value is\n"
    "    determined via the relation to `eval_legendre`.\n"
    "x : array_like\n"
    "    Points at which to evaluate the shifted Legendre polynomial\n"
    "\n"
    "Returns\n"
    "-------\n"
    "P : ndarray\n"
    "    Values of the shifted Legendre polynomial\n"
    "\n"
    "See Also\n"
    "--------\n"
    "roots_sh_legendre : roots and quadrature weights of shifted\n"
    "                    Legendre polynomials\n"
    "sh_legendre : shifted Legendre polynomial object\n"
    "eval_legendre : evaluate Legendre polynomials\n"
    "numpy.polynomial.legendre.Legendre : Legendre series")
ufunc_eval_sh_legendre_loops[0] = <np.PyUFuncGenericFunction>loop_d_ld__As_ld_d
ufunc_eval_sh_legendre_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_eval_sh_legendre_loops[2] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_eval_sh_legendre_loops[3] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_eval_sh_legendre_loops[4] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_eval_sh_legendre_types[0] = <char>NPY_LONG
ufunc_eval_sh_legendre_types[1] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[2] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[3] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[4] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[5] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[6] = <char>NPY_FLOAT
ufunc_eval_sh_legendre_types[7] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[8] = <char>NPY_CFLOAT
ufunc_eval_sh_legendre_types[9] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[10] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[11] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[12] = <char>NPY_DOUBLE
ufunc_eval_sh_legendre_types[13] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_types[14] = <char>NPY_CDOUBLE
ufunc_eval_sh_legendre_ptr[2*0] = <void*>_func_eval_sh_legendre_l
ufunc_eval_sh_legendre_ptr[2*0+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*1] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*1+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*2] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*2+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*3] = <void*>_func_eval_sh_legendre[double]
ufunc_eval_sh_legendre_ptr[2*3+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_ptr[2*4] = <void*>_func_eval_sh_legendre[double_complex]
ufunc_eval_sh_legendre_ptr[2*4+1] = <void*>(<char*>"eval_sh_legendre")
ufunc_eval_sh_legendre_data[0] = &ufunc_eval_sh_legendre_ptr[2*0]
ufunc_eval_sh_legendre_data[1] = &ufunc_eval_sh_legendre_ptr[2*1]
ufunc_eval_sh_legendre_data[2] = &ufunc_eval_sh_legendre_ptr[2*2]
ufunc_eval_sh_legendre_data[3] = &ufunc_eval_sh_legendre_ptr[2*3]
ufunc_eval_sh_legendre_data[4] = &ufunc_eval_sh_legendre_ptr[2*4]
eval_sh_legendre = np.PyUFunc_FromFuncAndData(ufunc_eval_sh_legendre_loops, ufunc_eval_sh_legendre_data, ufunc_eval_sh_legendre_types, 5, 2, 1, 0, "eval_sh_legendre", ufunc_eval_sh_legendre_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp1_loops[4]
cdef void *ufunc_exp1_ptr[8]
cdef void *ufunc_exp1_data[4]
cdef char ufunc_exp1_types[8]
cdef char *ufunc_exp1_doc = (
    "exp1(z)\n"
    "\n"
    "Exponential integral E_1 of complex argument z\n"
    "\n"
    "::\n"
    "\n"
    "    integral(exp(-z*t)/t, t=1..inf).")
ufunc_exp1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp1_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_exp1_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_exp1_types[0] = <char>NPY_FLOAT
ufunc_exp1_types[1] = <char>NPY_FLOAT
ufunc_exp1_types[2] = <char>NPY_DOUBLE
ufunc_exp1_types[3] = <char>NPY_DOUBLE
ufunc_exp1_types[4] = <char>NPY_CFLOAT
ufunc_exp1_types[5] = <char>NPY_CFLOAT
ufunc_exp1_types[6] = <char>NPY_CDOUBLE
ufunc_exp1_types[7] = <char>NPY_CDOUBLE
ufunc_exp1_ptr[2*0] = <void*>_func_exp1_wrap
ufunc_exp1_ptr[2*0+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*1] = <void*>_func_exp1_wrap
ufunc_exp1_ptr[2*1+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*2] = <void*>_func_cexp1_wrap
ufunc_exp1_ptr[2*2+1] = <void*>(<char*>"exp1")
ufunc_exp1_ptr[2*3] = <void*>_func_cexp1_wrap
ufunc_exp1_ptr[2*3+1] = <void*>(<char*>"exp1")
ufunc_exp1_data[0] = &ufunc_exp1_ptr[2*0]
ufunc_exp1_data[1] = &ufunc_exp1_ptr[2*1]
ufunc_exp1_data[2] = &ufunc_exp1_ptr[2*2]
ufunc_exp1_data[3] = &ufunc_exp1_ptr[2*3]
exp1 = np.PyUFunc_FromFuncAndData(ufunc_exp1_loops, ufunc_exp1_data, ufunc_exp1_types, 4, 1, 1, 0, "exp1", ufunc_exp1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp10_loops[2]
cdef void *ufunc_exp10_ptr[4]
cdef void *ufunc_exp10_data[2]
cdef char ufunc_exp10_types[4]
cdef char *ufunc_exp10_doc = (
    "exp10(x)\n"
    "\n"
    "10**x")
ufunc_exp10_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp10_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp10_types[0] = <char>NPY_FLOAT
ufunc_exp10_types[1] = <char>NPY_FLOAT
ufunc_exp10_types[2] = <char>NPY_DOUBLE
ufunc_exp10_types[3] = <char>NPY_DOUBLE
ufunc_exp10_ptr[2*0] = <void*>_func_exp10
ufunc_exp10_ptr[2*0+1] = <void*>(<char*>"exp10")
ufunc_exp10_ptr[2*1] = <void*>_func_exp10
ufunc_exp10_ptr[2*1+1] = <void*>(<char*>"exp10")
ufunc_exp10_data[0] = &ufunc_exp10_ptr[2*0]
ufunc_exp10_data[1] = &ufunc_exp10_ptr[2*1]
exp10 = np.PyUFunc_FromFuncAndData(ufunc_exp10_loops, ufunc_exp10_data, ufunc_exp10_types, 2, 1, 1, 0, "exp10", ufunc_exp10_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exp2_loops[2]
cdef void *ufunc_exp2_ptr[4]
cdef void *ufunc_exp2_data[2]
cdef char ufunc_exp2_types[4]
cdef char *ufunc_exp2_doc = (
    "exp2(x)\n"
    "\n"
    "2**x")
ufunc_exp2_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exp2_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exp2_types[0] = <char>NPY_FLOAT
ufunc_exp2_types[1] = <char>NPY_FLOAT
ufunc_exp2_types[2] = <char>NPY_DOUBLE
ufunc_exp2_types[3] = <char>NPY_DOUBLE
ufunc_exp2_ptr[2*0] = <void*>_func_exp2
ufunc_exp2_ptr[2*0+1] = <void*>(<char*>"exp2")
ufunc_exp2_ptr[2*1] = <void*>_func_exp2
ufunc_exp2_ptr[2*1+1] = <void*>(<char*>"exp2")
ufunc_exp2_data[0] = &ufunc_exp2_ptr[2*0]
ufunc_exp2_data[1] = &ufunc_exp2_ptr[2*1]
exp2 = np.PyUFunc_FromFuncAndData(ufunc_exp2_loops, ufunc_exp2_data, ufunc_exp2_types, 2, 1, 1, 0, "exp2", ufunc_exp2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expi_loops[4]
cdef void *ufunc_expi_ptr[8]
cdef void *ufunc_expi_data[4]
cdef char ufunc_expi_types[8]
cdef char *ufunc_expi_doc = (
    "expi(x)\n"
    "\n"
    "Exponential integral Ei\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    integral(exp(t)/t, t=-inf..x)\n"
    "\n"
    "See `expn` for a different exponential integral.")
ufunc_expi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_expi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_expi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_expi_types[0] = <char>NPY_FLOAT
ufunc_expi_types[1] = <char>NPY_FLOAT
ufunc_expi_types[2] = <char>NPY_DOUBLE
ufunc_expi_types[3] = <char>NPY_DOUBLE
ufunc_expi_types[4] = <char>NPY_CFLOAT
ufunc_expi_types[5] = <char>NPY_CFLOAT
ufunc_expi_types[6] = <char>NPY_CDOUBLE
ufunc_expi_types[7] = <char>NPY_CDOUBLE
ufunc_expi_ptr[2*0] = <void*>_func_expi_wrap
ufunc_expi_ptr[2*0+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*1] = <void*>_func_expi_wrap
ufunc_expi_ptr[2*1+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*2] = <void*>_func_cexpi_wrap
ufunc_expi_ptr[2*2+1] = <void*>(<char*>"expi")
ufunc_expi_ptr[2*3] = <void*>_func_cexpi_wrap
ufunc_expi_ptr[2*3+1] = <void*>(<char*>"expi")
ufunc_expi_data[0] = &ufunc_expi_ptr[2*0]
ufunc_expi_data[1] = &ufunc_expi_ptr[2*1]
ufunc_expi_data[2] = &ufunc_expi_ptr[2*2]
ufunc_expi_data[3] = &ufunc_expi_ptr[2*3]
expi = np.PyUFunc_FromFuncAndData(ufunc_expi_loops, ufunc_expi_data, ufunc_expi_types, 4, 1, 1, 0, "expi", ufunc_expi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expit_loops[3]
cdef void *ufunc_expit_ptr[6]
cdef void *ufunc_expit_data[3]
cdef char ufunc_expit_types[6]
cdef char *ufunc_expit_doc = (
    "expit(x)\n"
    "\n"
    "Expit ufunc for ndarrays.\n"
    "\n"
    "The expit function, also known as the logistic function, is defined as\n"
    "expit(x) = 1/(1+exp(-x)). It is the inverse of the logit function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    The ndarray to apply expit to element-wise.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    An ndarray of the same shape as x. Its entries\n"
    "    are expit of the corresponding entry of x.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "logit\n"
    "\n"
    "Notes\n"
    "-----\n"
    "As a ufunc expit takes a number of optional\n"
    "keyword arguments. For more information\n"
    "see `ufuncs <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n"
    "\n"
    ".. versionadded:: 0.10.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import expit, logit\n"
    "\n"
    ">>> expit([-np.inf, -1.5, 0, 1.5, np.inf])\n"
    "array([ 0.        ,  0.18242552,  0.5       ,  0.81757448,  1.        ])\n"
    "\n"
    "`logit` is the inverse of `expit`:\n"
    "\n"
    ">>> logit(expit([-2.5, 0, 3.1, 5.0]))\n"
    "array([-2.5,  0. ,  3.1,  5. ])\n"
    "\n"
    "Plot expit(x) for x in [-6, 6]:\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-6, 6, 121)\n"
    ">>> y = expit(x)\n"
    ">>> plt.plot(x, y)\n"
    ">>> plt.grid()\n"
    ">>> plt.xlim(-6, 6)\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.title('expit(x)')\n"
    ">>> plt.show()")
ufunc_expit_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_expit_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expit_loops[2] = <np.PyUFuncGenericFunction>loop_g_g__As_g_g
ufunc_expit_types[0] = <char>NPY_FLOAT
ufunc_expit_types[1] = <char>NPY_FLOAT
ufunc_expit_types[2] = <char>NPY_DOUBLE
ufunc_expit_types[3] = <char>NPY_DOUBLE
ufunc_expit_types[4] = <char>NPY_LONGDOUBLE
ufunc_expit_types[5] = <char>NPY_LONGDOUBLE
ufunc_expit_ptr[2*0] = <void*>_func_expitf
ufunc_expit_ptr[2*0+1] = <void*>(<char*>"expit")
ufunc_expit_ptr[2*1] = <void*>_func_expit
ufunc_expit_ptr[2*1+1] = <void*>(<char*>"expit")
ufunc_expit_ptr[2*2] = <void*>_func_expitl
ufunc_expit_ptr[2*2+1] = <void*>(<char*>"expit")
ufunc_expit_data[0] = &ufunc_expit_ptr[2*0]
ufunc_expit_data[1] = &ufunc_expit_ptr[2*1]
ufunc_expit_data[2] = &ufunc_expit_ptr[2*2]
expit = np.PyUFunc_FromFuncAndData(ufunc_expit_loops, ufunc_expit_data, ufunc_expit_types, 3, 1, 1, 0, "expit", ufunc_expit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expm1_loops[4]
cdef void *ufunc_expm1_ptr[8]
cdef void *ufunc_expm1_data[4]
cdef char ufunc_expm1_types[8]
cdef char *ufunc_expm1_doc = (
    "expm1(x)\n"
    "\n"
    "exp(x) - 1 for use when `x` is near zero.")
ufunc_expm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_expm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_expm1_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_expm1_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_expm1_types[0] = <char>NPY_FLOAT
ufunc_expm1_types[1] = <char>NPY_FLOAT
ufunc_expm1_types[2] = <char>NPY_DOUBLE
ufunc_expm1_types[3] = <char>NPY_DOUBLE
ufunc_expm1_types[4] = <char>NPY_CFLOAT
ufunc_expm1_types[5] = <char>NPY_CFLOAT
ufunc_expm1_types[6] = <char>NPY_CDOUBLE
ufunc_expm1_types[7] = <char>NPY_CDOUBLE
ufunc_expm1_ptr[2*0] = <void*>_func_expm1
ufunc_expm1_ptr[2*0+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*1] = <void*>_func_expm1
ufunc_expm1_ptr[2*1+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*2] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*2+1] = <void*>(<char*>"expm1")
ufunc_expm1_ptr[2*3] = <void*>_func_cexpm1
ufunc_expm1_ptr[2*3+1] = <void*>(<char*>"expm1")
ufunc_expm1_data[0] = &ufunc_expm1_ptr[2*0]
ufunc_expm1_data[1] = &ufunc_expm1_ptr[2*1]
ufunc_expm1_data[2] = &ufunc_expm1_ptr[2*2]
ufunc_expm1_data[3] = &ufunc_expm1_ptr[2*3]
expm1 = np.PyUFunc_FromFuncAndData(ufunc_expm1_loops, ufunc_expm1_data, ufunc_expm1_types, 4, 1, 1, 0, "expm1", ufunc_expm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_expn_loops[3]
cdef void *ufunc_expn_ptr[6]
cdef void *ufunc_expn_data[3]
cdef char ufunc_expn_types[9]
cdef char *ufunc_expn_doc = (
    "expn(n, x)\n"
    "\n"
    "Exponential integral E_n\n"
    "\n"
    "Returns the exponential integral for integer `n` and non-negative `x` and\n"
    "`n`::\n"
    "\n"
    "    integral(exp(-x*t) / t**n, t=1..inf).")
ufunc_expn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_expn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_expn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_expn_types[0] = <char>NPY_LONG
ufunc_expn_types[1] = <char>NPY_DOUBLE
ufunc_expn_types[2] = <char>NPY_DOUBLE
ufunc_expn_types[3] = <char>NPY_FLOAT
ufunc_expn_types[4] = <char>NPY_FLOAT
ufunc_expn_types[5] = <char>NPY_FLOAT
ufunc_expn_types[6] = <char>NPY_DOUBLE
ufunc_expn_types[7] = <char>NPY_DOUBLE
ufunc_expn_types[8] = <char>NPY_DOUBLE
ufunc_expn_ptr[2*0] = <void*>_func_expn
ufunc_expn_ptr[2*0+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*1] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*1+1] = <void*>(<char*>"expn")
ufunc_expn_ptr[2*2] = <void*>_func_expn_unsafe
ufunc_expn_ptr[2*2+1] = <void*>(<char*>"expn")
ufunc_expn_data[0] = &ufunc_expn_ptr[2*0]
ufunc_expn_data[1] = &ufunc_expn_ptr[2*1]
ufunc_expn_data[2] = &ufunc_expn_ptr[2*2]
expn = np.PyUFunc_FromFuncAndData(ufunc_expn_loops, ufunc_expn_data, ufunc_expn_types, 3, 2, 1, 0, "expn", ufunc_expn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_exprel_loops[2]
cdef void *ufunc_exprel_ptr[4]
cdef void *ufunc_exprel_data[2]
cdef char ufunc_exprel_types[4]
cdef char *ufunc_exprel_doc = (
    "exprel(x)\n"
    "\n"
    "Relative error exponential, (exp(x)-1)/x, for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    Input array.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    Output array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1\n"
    "\n"
    ".. versionadded:: 0.17.0")
ufunc_exprel_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_exprel_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_exprel_types[0] = <char>NPY_FLOAT
ufunc_exprel_types[1] = <char>NPY_FLOAT
ufunc_exprel_types[2] = <char>NPY_DOUBLE
ufunc_exprel_types[3] = <char>NPY_DOUBLE
ufunc_exprel_ptr[2*0] = <void*>_func_exprel
ufunc_exprel_ptr[2*0+1] = <void*>(<char*>"exprel")
ufunc_exprel_ptr[2*1] = <void*>_func_exprel
ufunc_exprel_ptr[2*1+1] = <void*>(<char*>"exprel")
ufunc_exprel_data[0] = &ufunc_exprel_ptr[2*0]
ufunc_exprel_data[1] = &ufunc_exprel_ptr[2*1]
exprel = np.PyUFunc_FromFuncAndData(ufunc_exprel_loops, ufunc_exprel_data, ufunc_exprel_types, 2, 1, 1, 0, "exprel", ufunc_exprel_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtr_loops[2]
cdef void *ufunc_fdtr_ptr[4]
cdef void *ufunc_fdtr_data[2]
cdef char ufunc_fdtr_types[8]
cdef char *ufunc_fdtr_doc = (
    "fdtr(dfn, dfd, x)\n"
    "\n"
    "F cumulative distribution function.\n"
    "\n"
    "Returns the value of the cumulative density function of the\n"
    "F-distribution, also known as Snedecor's F-distribution or the\n"
    "Fisher-Snedecor distribution.\n"
    "\n"
    "The F-distribution with parameters :math:`d_n` and :math:`d_d` is the\n"
    "distribution of the random variable,\n"
    "\n"
    ".. math::\n"
    "    X = \\frac{U_n/d_n}{U_d/d_d},\n"
    "\n"
    "where :math:`U_n` and :math:`U_d` are random variables distributed\n"
    ":math:`\\chi^2`, with :math:`d_n` and :math:`d_d` degrees of freedom,\n"
    "respectively.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : ndarray\n"
    "    The CDF of the F-distribution with parameters `dfn` and `dfd` at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{xd_n/(d_d + xd_n)}(d_n/2, d_d/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_fdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtr_types[0] = <char>NPY_FLOAT
ufunc_fdtr_types[1] = <char>NPY_FLOAT
ufunc_fdtr_types[2] = <char>NPY_FLOAT
ufunc_fdtr_types[3] = <char>NPY_FLOAT
ufunc_fdtr_types[4] = <char>NPY_DOUBLE
ufunc_fdtr_types[5] = <char>NPY_DOUBLE
ufunc_fdtr_types[6] = <char>NPY_DOUBLE
ufunc_fdtr_types[7] = <char>NPY_DOUBLE
ufunc_fdtr_ptr[2*0] = <void*>_func_fdtr
ufunc_fdtr_ptr[2*0+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_ptr[2*1] = <void*>_func_fdtr
ufunc_fdtr_ptr[2*1+1] = <void*>(<char*>"fdtr")
ufunc_fdtr_data[0] = &ufunc_fdtr_ptr[2*0]
ufunc_fdtr_data[1] = &ufunc_fdtr_ptr[2*1]
fdtr = np.PyUFunc_FromFuncAndData(ufunc_fdtr_loops, ufunc_fdtr_data, ufunc_fdtr_types, 2, 3, 1, 0, "fdtr", ufunc_fdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtrc_loops[2]
cdef void *ufunc_fdtrc_ptr[4]
cdef void *ufunc_fdtrc_data[2]
cdef char ufunc_fdtrc_types[8]
cdef char *ufunc_fdtrc_doc = (
    "fdtrc(dfn, dfd, x)\n"
    "\n"
    "F survival function.\n"
    "\n"
    "Returns the complemented F-distribution function (the integral of the\n"
    "density from `x` to infinity).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "x : array_like\n"
    "    Argument (nonnegative float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : ndarray\n"
    "    The complemented F-distribution function with parameters `dfn` and\n"
    "    `dfd` at `x`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "fdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The regularized incomplete beta function is used, according to the\n"
    "formula,\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d; x) = I_{d_d/(d_d + xd_n)}(d_d/2, d_n/2).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_fdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtrc_types[0] = <char>NPY_FLOAT
ufunc_fdtrc_types[1] = <char>NPY_FLOAT
ufunc_fdtrc_types[2] = <char>NPY_FLOAT
ufunc_fdtrc_types[3] = <char>NPY_FLOAT
ufunc_fdtrc_types[4] = <char>NPY_DOUBLE
ufunc_fdtrc_types[5] = <char>NPY_DOUBLE
ufunc_fdtrc_types[6] = <char>NPY_DOUBLE
ufunc_fdtrc_types[7] = <char>NPY_DOUBLE
ufunc_fdtrc_ptr[2*0] = <void*>_func_fdtrc
ufunc_fdtrc_ptr[2*0+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_ptr[2*1] = <void*>_func_fdtrc
ufunc_fdtrc_ptr[2*1+1] = <void*>(<char*>"fdtrc")
ufunc_fdtrc_data[0] = &ufunc_fdtrc_ptr[2*0]
ufunc_fdtrc_data[1] = &ufunc_fdtrc_ptr[2*1]
fdtrc = np.PyUFunc_FromFuncAndData(ufunc_fdtrc_loops, ufunc_fdtrc_data, ufunc_fdtrc_types, 2, 3, 1, 0, "fdtrc", ufunc_fdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtri_loops[2]
cdef void *ufunc_fdtri_ptr[4]
cdef void *ufunc_fdtri_data[2]
cdef char ufunc_fdtri_types[8]
cdef char *ufunc_fdtri_doc = (
    "fdtri(dfn, dfd, p)\n"
    "\n"
    "The `p`-th quantile of the F-distribution.\n"
    "\n"
    "This function is the inverse of the F-distribution CDF, `fdtr`, returning\n"
    "the `x` such that `fdtr(dfn, dfd, x) = p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    First parameter (positive float).\n"
    "dfd : array_like\n"
    "    Second parameter (positive float).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the relation to the inverse\n"
    "regularized beta function, :math:`I^{-1}_x(a, b)`.  Let\n"
    ":math:`z = I^{-1}_p(d_d/2, d_n/2).`  Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d (1 - z)}{d_n z}.\n"
    "\n"
    "If `p` is such that :math:`x < 0.5`, the following relation is used\n"
    "instead for improved stability: let\n"
    ":math:`z' = I^{-1}_{1 - p}(d_n/2, d_d/2).` Then,\n"
    "\n"
    ".. math::\n"
    "    x = \\frac{d_d z'}{d_n (1 - z')}.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `fdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_fdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtri_types[0] = <char>NPY_FLOAT
ufunc_fdtri_types[1] = <char>NPY_FLOAT
ufunc_fdtri_types[2] = <char>NPY_FLOAT
ufunc_fdtri_types[3] = <char>NPY_FLOAT
ufunc_fdtri_types[4] = <char>NPY_DOUBLE
ufunc_fdtri_types[5] = <char>NPY_DOUBLE
ufunc_fdtri_types[6] = <char>NPY_DOUBLE
ufunc_fdtri_types[7] = <char>NPY_DOUBLE
ufunc_fdtri_ptr[2*0] = <void*>_func_fdtri
ufunc_fdtri_ptr[2*0+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_ptr[2*1] = <void*>_func_fdtri
ufunc_fdtri_ptr[2*1+1] = <void*>(<char*>"fdtri")
ufunc_fdtri_data[0] = &ufunc_fdtri_ptr[2*0]
ufunc_fdtri_data[1] = &ufunc_fdtri_ptr[2*1]
fdtri = np.PyUFunc_FromFuncAndData(ufunc_fdtri_loops, ufunc_fdtri_data, ufunc_fdtri_types, 2, 3, 1, 0, "fdtri", ufunc_fdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fdtridfd_loops[2]
cdef void *ufunc_fdtridfd_ptr[4]
cdef void *ufunc_fdtridfd_data[2]
cdef char ufunc_fdtridfd_types[8]
cdef char *ufunc_fdtridfd_doc = (
    "fdtridfd(dfn, p, x)\n"
    "\n"
    "Inverse to `fdtr` vs dfd\n"
    "\n"
    "Finds the F density argument dfd such that ``fdtr(dfn, dfd, x) == p``.")
ufunc_fdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_fdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_fdtridfd_types[0] = <char>NPY_FLOAT
ufunc_fdtridfd_types[1] = <char>NPY_FLOAT
ufunc_fdtridfd_types[2] = <char>NPY_FLOAT
ufunc_fdtridfd_types[3] = <char>NPY_FLOAT
ufunc_fdtridfd_types[4] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_fdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_fdtridfd_ptr[2*0] = <void*>_func_cdff4_wrap
ufunc_fdtridfd_ptr[2*0+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_ptr[2*1] = <void*>_func_cdff4_wrap
ufunc_fdtridfd_ptr[2*1+1] = <void*>(<char*>"fdtridfd")
ufunc_fdtridfd_data[0] = &ufunc_fdtridfd_ptr[2*0]
ufunc_fdtridfd_data[1] = &ufunc_fdtridfd_ptr[2*1]
fdtridfd = np.PyUFunc_FromFuncAndData(ufunc_fdtridfd_loops, ufunc_fdtridfd_data, ufunc_fdtridfd_types, 2, 3, 1, 0, "fdtridfd", ufunc_fdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_fresnel_loops[4]
cdef void *ufunc_fresnel_ptr[8]
cdef void *ufunc_fresnel_data[4]
cdef char ufunc_fresnel_types[12]
cdef char *ufunc_fresnel_doc = (
    "fresnel(z)\n"
    "\n"
    "Fresnel sin and cos integrals\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    ssa = integral(sin(pi/2 * t**2), t=0..z)\n"
    "    csa = integral(cos(pi/2 * t**2), t=0..z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : float or complex array_like\n"
    "    Argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ssa, csa\n"
    "    Fresnel sin and cos integral values")
ufunc_fresnel_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_fresnel_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_fresnel_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_fresnel_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_fresnel_types[0] = <char>NPY_FLOAT
ufunc_fresnel_types[1] = <char>NPY_FLOAT
ufunc_fresnel_types[2] = <char>NPY_FLOAT
ufunc_fresnel_types[3] = <char>NPY_DOUBLE
ufunc_fresnel_types[4] = <char>NPY_DOUBLE
ufunc_fresnel_types[5] = <char>NPY_DOUBLE
ufunc_fresnel_types[6] = <char>NPY_CFLOAT
ufunc_fresnel_types[7] = <char>NPY_CFLOAT
ufunc_fresnel_types[8] = <char>NPY_CFLOAT
ufunc_fresnel_types[9] = <char>NPY_CDOUBLE
ufunc_fresnel_types[10] = <char>NPY_CDOUBLE
ufunc_fresnel_types[11] = <char>NPY_CDOUBLE
ufunc_fresnel_ptr[2*0] = <void*>_func_fresnl
ufunc_fresnel_ptr[2*0+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*1] = <void*>_func_fresnl
ufunc_fresnel_ptr[2*1+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*2] = <void*>_func_cfresnl_wrap
ufunc_fresnel_ptr[2*2+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_ptr[2*3] = <void*>_func_cfresnl_wrap
ufunc_fresnel_ptr[2*3+1] = <void*>(<char*>"fresnel")
ufunc_fresnel_data[0] = &ufunc_fresnel_ptr[2*0]
ufunc_fresnel_data[1] = &ufunc_fresnel_ptr[2*1]
ufunc_fresnel_data[2] = &ufunc_fresnel_ptr[2*2]
ufunc_fresnel_data[3] = &ufunc_fresnel_ptr[2*3]
fresnel = np.PyUFunc_FromFuncAndData(ufunc_fresnel_loops, ufunc_fresnel_data, ufunc_fresnel_types, 4, 1, 2, 0, "fresnel", ufunc_fresnel_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gamma_loops[4]
cdef void *ufunc_gamma_ptr[8]
cdef void *ufunc_gamma_data[4]
cdef char ufunc_gamma_types[8]
cdef char *ufunc_gamma_doc = (
    "gamma(z)\n"
    "\n"
    "Gamma function.\n"
    "\n"
    "The gamma function is often referred to as the generalized\n"
    "factorial since ``z*gamma(z) = gamma(z+1)`` and ``gamma(n+1) =\n"
    "n!`` for natural number *n*.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : float or complex array_like\n"
    "\n"
    "Returns\n"
    "-------\n"
    "float or complex\n"
    "    The value(s) of gamma(z)\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import gamma, factorial\n"
    "\n"
    ">>> gamma([0, 0.5, 1, 5])\n"
    "array([         inf,   1.77245385,   1.        ,  24.        ])\n"
    "\n"
    ">>> z = 2.5 + 1j\n"
    ">>> gamma(z)\n"
    "(0.77476210455108352+0.70763120437959293j)\n"
    ">>> gamma(z+1), z*gamma(z)  # Recurrence property\n"
    "((1.2292740569981171+2.5438401155000685j),\n"
    " (1.2292740569981158+2.5438401155000658j))\n"
    "\n"
    ">>> gamma(0.5)**2  # gamma(0.5) = sqrt(pi)\n"
    "3.1415926535897927\n"
    "\n"
    "Plot gamma(x) for real x\n"
    "\n"
    ">>> x = np.linspace(-3.5, 5.5, 2251)\n"
    ">>> y = gamma(x)\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> plt.plot(x, y, 'b', alpha=0.6, label='gamma(x)')\n"
    ">>> k = np.arange(1, 7)\n"
    ">>> plt.plot(k, factorial(k-1), 'k*', alpha=0.6,\n"
    "...          label='(x-1)!, x = 1, 2, ...')\n"
    ">>> plt.xlim(-3.5, 5.5)\n"
    ">>> plt.ylim(-10, 25)\n"
    ">>> plt.grid()\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.legend(loc='lower right')\n"
    ">>> plt.show()")
ufunc_gamma_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gamma_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gamma_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_gamma_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_gamma_types[0] = <char>NPY_FLOAT
ufunc_gamma_types[1] = <char>NPY_FLOAT
ufunc_gamma_types[2] = <char>NPY_DOUBLE
ufunc_gamma_types[3] = <char>NPY_DOUBLE
ufunc_gamma_types[4] = <char>NPY_CFLOAT
ufunc_gamma_types[5] = <char>NPY_CFLOAT
ufunc_gamma_types[6] = <char>NPY_CDOUBLE
ufunc_gamma_types[7] = <char>NPY_CDOUBLE
ufunc_gamma_ptr[2*0] = <void*>_func_Gamma
ufunc_gamma_ptr[2*0+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*1] = <void*>_func_Gamma
ufunc_gamma_ptr[2*1+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*2] = <void*>_func_cgamma
ufunc_gamma_ptr[2*2+1] = <void*>(<char*>"gamma")
ufunc_gamma_ptr[2*3] = <void*>_func_cgamma
ufunc_gamma_ptr[2*3+1] = <void*>(<char*>"gamma")
ufunc_gamma_data[0] = &ufunc_gamma_ptr[2*0]
ufunc_gamma_data[1] = &ufunc_gamma_ptr[2*1]
ufunc_gamma_data[2] = &ufunc_gamma_ptr[2*2]
ufunc_gamma_data[3] = &ufunc_gamma_ptr[2*3]
gamma = np.PyUFunc_FromFuncAndData(ufunc_gamma_loops, ufunc_gamma_data, ufunc_gamma_types, 4, 1, 1, 0, "gamma", ufunc_gamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammainc_loops[2]
cdef void *ufunc_gammainc_ptr[4]
cdef void *ufunc_gammainc_data[2]
cdef char ufunc_gammainc_types[6]
cdef char *ufunc_gammainc_doc = (
    "gammainc(a, x)\n"
    "\n"
    "Regularized lower incomplete gamma function.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{\\Gamma(a)} \\int_0^x t^{a - 1}e^{-t} dt\n"
    "\n"
    "for :math:`a > 0` and :math:`x \\geq 0`. The function satisfies the\n"
    "relation ``gammainc(a, x) + gammaincc(a, x) = 1`` where\n"
    "`gammaincc` is the regularized upper incomplete gamma function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The implementation largely follows that of [1]_.\n"
    "\n"
    "See also\n"
    "--------\n"
    "gammaincc : regularized upper incomplete gamma function\n"
    "gammaincinv : inverse to ``gammainc`` versus ``x``\n"
    "gammainccinv : inverse to ``gammaincc`` versus ``x``\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Maddock et. al., \"Incomplete Gamma Functions\",\n"
    "   http://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html")
ufunc_gammainc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammainc_types[0] = <char>NPY_FLOAT
ufunc_gammainc_types[1] = <char>NPY_FLOAT
ufunc_gammainc_types[2] = <char>NPY_FLOAT
ufunc_gammainc_types[3] = <char>NPY_DOUBLE
ufunc_gammainc_types[4] = <char>NPY_DOUBLE
ufunc_gammainc_types[5] = <char>NPY_DOUBLE
ufunc_gammainc_ptr[2*0] = <void*>_func_igam
ufunc_gammainc_ptr[2*0+1] = <void*>(<char*>"gammainc")
ufunc_gammainc_ptr[2*1] = <void*>_func_igam
ufunc_gammainc_ptr[2*1+1] = <void*>(<char*>"gammainc")
ufunc_gammainc_data[0] = &ufunc_gammainc_ptr[2*0]
ufunc_gammainc_data[1] = &ufunc_gammainc_ptr[2*1]
gammainc = np.PyUFunc_FromFuncAndData(ufunc_gammainc_loops, ufunc_gammainc_data, ufunc_gammainc_types, 2, 2, 1, 0, "gammainc", ufunc_gammainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaincc_loops[2]
cdef void *ufunc_gammaincc_ptr[4]
cdef void *ufunc_gammaincc_data[2]
cdef char ufunc_gammaincc_types[6]
cdef char *ufunc_gammaincc_doc = (
    "gammaincc(a, x)\n"
    "\n"
    "Regularized upper incomplete gamma function.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{\\Gamma(a)} \\int_x^\\infty t^{a - 1}e^{-t} dt\n"
    "\n"
    "for :math:`a > 0` and :math:`x \\geq 0`. The function satisfies the\n"
    "relation ``gammainc(a, x) + gammaincc(a, x) = 1`` where `gammainc`\n"
    "is the regularized lower incomplete gamma function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The implementation largely follows that of [1]_.\n"
    "\n"
    "See also\n"
    "--------\n"
    "gammainc : regularized lower incomplete gamma function\n"
    "gammaincinv : inverse to ``gammainc`` versus ``x``\n"
    "gammainccinv : inverse to ``gammaincc`` versus ``x``\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Maddock et. al., \"Incomplete Gamma Functions\",\n"
    "   http://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html")
ufunc_gammaincc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammaincc_types[0] = <char>NPY_FLOAT
ufunc_gammaincc_types[1] = <char>NPY_FLOAT
ufunc_gammaincc_types[2] = <char>NPY_FLOAT
ufunc_gammaincc_types[3] = <char>NPY_DOUBLE
ufunc_gammaincc_types[4] = <char>NPY_DOUBLE
ufunc_gammaincc_types[5] = <char>NPY_DOUBLE
ufunc_gammaincc_ptr[2*0] = <void*>_func_igamc
ufunc_gammaincc_ptr[2*0+1] = <void*>(<char*>"gammaincc")
ufunc_gammaincc_ptr[2*1] = <void*>_func_igamc
ufunc_gammaincc_ptr[2*1+1] = <void*>(<char*>"gammaincc")
ufunc_gammaincc_data[0] = &ufunc_gammaincc_ptr[2*0]
ufunc_gammaincc_data[1] = &ufunc_gammaincc_ptr[2*1]
gammaincc = np.PyUFunc_FromFuncAndData(ufunc_gammaincc_loops, ufunc_gammaincc_data, ufunc_gammaincc_types, 2, 2, 1, 0, "gammaincc", ufunc_gammaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammainccinv_loops[2]
cdef void *ufunc_gammainccinv_ptr[4]
cdef void *ufunc_gammainccinv_data[2]
cdef char ufunc_gammainccinv_types[6]
cdef char *ufunc_gammainccinv_doc = (
    "gammainccinv(a, y)\n"
    "\n"
    "Inverse to `gammaincc`\n"
    "\n"
    "Returns `x` such that ``gammaincc(a, x) == y``.")
ufunc_gammainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammainccinv_types[0] = <char>NPY_FLOAT
ufunc_gammainccinv_types[1] = <char>NPY_FLOAT
ufunc_gammainccinv_types[2] = <char>NPY_FLOAT
ufunc_gammainccinv_types[3] = <char>NPY_DOUBLE
ufunc_gammainccinv_types[4] = <char>NPY_DOUBLE
ufunc_gammainccinv_types[5] = <char>NPY_DOUBLE
ufunc_gammainccinv_ptr[2*0] = <void*>_func_igami
ufunc_gammainccinv_ptr[2*0+1] = <void*>(<char*>"gammainccinv")
ufunc_gammainccinv_ptr[2*1] = <void*>_func_igami
ufunc_gammainccinv_ptr[2*1+1] = <void*>(<char*>"gammainccinv")
ufunc_gammainccinv_data[0] = &ufunc_gammainccinv_ptr[2*0]
ufunc_gammainccinv_data[1] = &ufunc_gammainccinv_ptr[2*1]
gammainccinv = np.PyUFunc_FromFuncAndData(ufunc_gammainccinv_loops, ufunc_gammainccinv_data, ufunc_gammainccinv_types, 2, 2, 1, 0, "gammainccinv", ufunc_gammainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaincinv_loops[2]
cdef void *ufunc_gammaincinv_ptr[4]
cdef void *ufunc_gammaincinv_data[2]
cdef char ufunc_gammaincinv_types[6]
cdef char *ufunc_gammaincinv_doc = (
    "gammaincinv(a, y)\n"
    "\n"
    "Inverse to `gammainc`\n"
    "\n"
    "Returns `x` such that ``gammainc(a, x) = y``.")
ufunc_gammaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_gammaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_gammaincinv_types[0] = <char>NPY_FLOAT
ufunc_gammaincinv_types[1] = <char>NPY_FLOAT
ufunc_gammaincinv_types[2] = <char>NPY_FLOAT
ufunc_gammaincinv_types[3] = <char>NPY_DOUBLE
ufunc_gammaincinv_types[4] = <char>NPY_DOUBLE
ufunc_gammaincinv_types[5] = <char>NPY_DOUBLE
ufunc_gammaincinv_ptr[2*0] = <void*>_func_gammaincinv
ufunc_gammaincinv_ptr[2*0+1] = <void*>(<char*>"gammaincinv")
ufunc_gammaincinv_ptr[2*1] = <void*>_func_gammaincinv
ufunc_gammaincinv_ptr[2*1+1] = <void*>(<char*>"gammaincinv")
ufunc_gammaincinv_data[0] = &ufunc_gammaincinv_ptr[2*0]
ufunc_gammaincinv_data[1] = &ufunc_gammaincinv_ptr[2*1]
gammaincinv = np.PyUFunc_FromFuncAndData(ufunc_gammaincinv_loops, ufunc_gammaincinv_data, ufunc_gammaincinv_types, 2, 2, 1, 0, "gammaincinv", ufunc_gammaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammaln_loops[2]
cdef void *ufunc_gammaln_ptr[4]
cdef void *ufunc_gammaln_data[2]
cdef char ufunc_gammaln_types[4]
cdef char *ufunc_gammaln_doc = (
    "Logarithm of the absolute value of the Gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array-like\n"
    "    Values on the real line at which to compute ``gammaln``\n"
    "\n"
    "Returns\n"
    "-------\n"
    "gammaln : ndarray\n"
    "    Values of ``gammaln`` at x.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammasgn : sign of the gamma function\n"
    "loggamma : principal branch of the logarithm of the gamma function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "When used in conjunction with `gammasgn`, this function is useful\n"
    "for working in logspace on the real axis without having to deal with\n"
    "complex numbers, via the relation ``exp(gammaln(x)) = gammasgn(x)*gamma(x)``.\n"
    "\n"
    "For complex-valued log-gamma, use `loggamma` instead of `gammaln`.")
ufunc_gammaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gammaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gammaln_types[0] = <char>NPY_FLOAT
ufunc_gammaln_types[1] = <char>NPY_FLOAT
ufunc_gammaln_types[2] = <char>NPY_DOUBLE
ufunc_gammaln_types[3] = <char>NPY_DOUBLE
ufunc_gammaln_ptr[2*0] = <void*>_func_lgam
ufunc_gammaln_ptr[2*0+1] = <void*>(<char*>"gammaln")
ufunc_gammaln_ptr[2*1] = <void*>_func_lgam
ufunc_gammaln_ptr[2*1+1] = <void*>(<char*>"gammaln")
ufunc_gammaln_data[0] = &ufunc_gammaln_ptr[2*0]
ufunc_gammaln_data[1] = &ufunc_gammaln_ptr[2*1]
gammaln = np.PyUFunc_FromFuncAndData(ufunc_gammaln_loops, ufunc_gammaln_data, ufunc_gammaln_types, 2, 1, 1, 0, "gammaln", ufunc_gammaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gammasgn_loops[2]
cdef void *ufunc_gammasgn_ptr[4]
cdef void *ufunc_gammasgn_data[2]
cdef char ufunc_gammasgn_types[4]
cdef char *ufunc_gammasgn_doc = (
    "gammasgn(x)\n"
    "\n"
    "Sign of the gamma function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gammaln\n"
    "loggamma")
ufunc_gammasgn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_gammasgn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_gammasgn_types[0] = <char>NPY_FLOAT
ufunc_gammasgn_types[1] = <char>NPY_FLOAT
ufunc_gammasgn_types[2] = <char>NPY_DOUBLE
ufunc_gammasgn_types[3] = <char>NPY_DOUBLE
ufunc_gammasgn_ptr[2*0] = <void*>_func_gammasgn
ufunc_gammasgn_ptr[2*0+1] = <void*>(<char*>"gammasgn")
ufunc_gammasgn_ptr[2*1] = <void*>_func_gammasgn
ufunc_gammasgn_ptr[2*1+1] = <void*>(<char*>"gammasgn")
ufunc_gammasgn_data[0] = &ufunc_gammasgn_ptr[2*0]
ufunc_gammasgn_data[1] = &ufunc_gammasgn_ptr[2*1]
gammasgn = np.PyUFunc_FromFuncAndData(ufunc_gammasgn_loops, ufunc_gammasgn_data, ufunc_gammasgn_types, 2, 1, 1, 0, "gammasgn", ufunc_gammasgn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtr_loops[2]
cdef void *ufunc_gdtr_ptr[4]
cdef void *ufunc_gdtr_data[2]
cdef char ufunc_gdtr_types[8]
cdef char *ufunc_gdtr_doc = (
    "gdtr(a, b, x)\n"
    "\n"
    "Gamma distribution cumulative density function.\n"
    "\n"
    "Returns the integral from zero to `x` of the gamma probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_0^x \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float).  It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (upper limit of integration; float).\n"
    "\n"
    "See also\n"
    "--------\n"
    "gdtrc : 1 - CDF of the gamma distribution.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : ndarray\n"
    "    The CDF of the gamma distribution with parameters `a` and `b`\n"
    "    evaluated at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_gdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtr_types[0] = <char>NPY_FLOAT
ufunc_gdtr_types[1] = <char>NPY_FLOAT
ufunc_gdtr_types[2] = <char>NPY_FLOAT
ufunc_gdtr_types[3] = <char>NPY_FLOAT
ufunc_gdtr_types[4] = <char>NPY_DOUBLE
ufunc_gdtr_types[5] = <char>NPY_DOUBLE
ufunc_gdtr_types[6] = <char>NPY_DOUBLE
ufunc_gdtr_types[7] = <char>NPY_DOUBLE
ufunc_gdtr_ptr[2*0] = <void*>_func_gdtr
ufunc_gdtr_ptr[2*0+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_ptr[2*1] = <void*>_func_gdtr
ufunc_gdtr_ptr[2*1+1] = <void*>(<char*>"gdtr")
ufunc_gdtr_data[0] = &ufunc_gdtr_ptr[2*0]
ufunc_gdtr_data[1] = &ufunc_gdtr_ptr[2*1]
gdtr = np.PyUFunc_FromFuncAndData(ufunc_gdtr_loops, ufunc_gdtr_data, ufunc_gdtr_types, 2, 3, 1, 0, "gdtr", ufunc_gdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrc_loops[2]
cdef void *ufunc_gdtrc_ptr[4]
cdef void *ufunc_gdtrc_data[2]
cdef char ufunc_gdtrc_types[8]
cdef char *ufunc_gdtrc_doc = (
    "gdtrc(a, b, x)\n"
    "\n"
    "Gamma distribution survival function.\n"
    "\n"
    "Integral from `x` to infinity of the gamma probability density function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\int_x^\\infty \\frac{a^b}{\\Gamma(b)} t^{b-1} e^{-at}\\,dt,\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    The rate parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\beta` (float).  It is also the reciprocal of the scale\n"
    "    parameter :math:`\\theta`.\n"
    "b : array_like\n"
    "    The shape parameter of the gamma distribution, sometimes denoted\n"
    "    :math:`\\alpha` (float).\n"
    "x : array_like\n"
    "    The quantile (lower limit of integration; float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : ndarray\n"
    "    The survival function of the gamma distribution with parameters `a`\n"
    "    and `b` evaluated at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr, gdtri\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The evaluation is carried out using the relation to the incomplete gamma\n"
    "integral (regularized gamma function).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `gdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_gdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrc_types[0] = <char>NPY_FLOAT
ufunc_gdtrc_types[1] = <char>NPY_FLOAT
ufunc_gdtrc_types[2] = <char>NPY_FLOAT
ufunc_gdtrc_types[3] = <char>NPY_FLOAT
ufunc_gdtrc_types[4] = <char>NPY_DOUBLE
ufunc_gdtrc_types[5] = <char>NPY_DOUBLE
ufunc_gdtrc_types[6] = <char>NPY_DOUBLE
ufunc_gdtrc_types[7] = <char>NPY_DOUBLE
ufunc_gdtrc_ptr[2*0] = <void*>_func_gdtrc
ufunc_gdtrc_ptr[2*0+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_ptr[2*1] = <void*>_func_gdtrc
ufunc_gdtrc_ptr[2*1+1] = <void*>(<char*>"gdtrc")
ufunc_gdtrc_data[0] = &ufunc_gdtrc_ptr[2*0]
ufunc_gdtrc_data[1] = &ufunc_gdtrc_ptr[2*1]
gdtrc = np.PyUFunc_FromFuncAndData(ufunc_gdtrc_loops, ufunc_gdtrc_data, ufunc_gdtrc_types, 2, 3, 1, 0, "gdtrc", ufunc_gdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtria_loops[2]
cdef void *ufunc_gdtria_ptr[4]
cdef void *ufunc_gdtria_data[2]
cdef char ufunc_gdtria_types[8]
cdef char *ufunc_gdtria_doc = (
    "gdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs a.\n"
    "\n"
    "Returns the inverse with respect to the parameter `a` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability values.\n"
    "b : array_like\n"
    "    `b` parameter values of `gdtr(a, b, x)`.  `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : ndarray\n"
    "    Values of the `a` parameter such that `p = gdtr(a, b, x)`.  `1/a`\n"
    "    is the \"scale\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_.  Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`.  The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtria\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtria(p, 3.4, 5.6)\n"
    "1.2")
ufunc_gdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtria_types[0] = <char>NPY_FLOAT
ufunc_gdtria_types[1] = <char>NPY_FLOAT
ufunc_gdtria_types[2] = <char>NPY_FLOAT
ufunc_gdtria_types[3] = <char>NPY_FLOAT
ufunc_gdtria_types[4] = <char>NPY_DOUBLE
ufunc_gdtria_types[5] = <char>NPY_DOUBLE
ufunc_gdtria_types[6] = <char>NPY_DOUBLE
ufunc_gdtria_types[7] = <char>NPY_DOUBLE
ufunc_gdtria_ptr[2*0] = <void*>_func_cdfgam4_wrap
ufunc_gdtria_ptr[2*0+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_ptr[2*1] = <void*>_func_cdfgam4_wrap
ufunc_gdtria_ptr[2*1+1] = <void*>(<char*>"gdtria")
ufunc_gdtria_data[0] = &ufunc_gdtria_ptr[2*0]
ufunc_gdtria_data[1] = &ufunc_gdtria_ptr[2*1]
gdtria = np.PyUFunc_FromFuncAndData(ufunc_gdtria_loops, ufunc_gdtria_data, ufunc_gdtria_types, 2, 3, 1, 0, "gdtria", ufunc_gdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrib_loops[2]
cdef void *ufunc_gdtrib_ptr[4]
cdef void *ufunc_gdtrib_data[2]
cdef char ufunc_gdtrib_types[8]
cdef char *ufunc_gdtrib_doc = (
    "gdtrib(a, p, x, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs b.\n"
    "\n"
    "Returns the inverse with respect to the parameter `b` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of `gdtr(a, b, x)`. `1/a` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "x : array_like\n"
    "    Nonnegative real values, from the domain of the gamma distribution.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : ndarray\n"
    "    Values of the `b` parameter such that `p = gdtr(a, b, x)`.  `b` is\n"
    "    the \"shape\" parameter of the gamma distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n"
    "gdtrix : Inverse with respect to `x` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_.  Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`.  The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrib\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrib(1.2, p, 5.6)\n"
    "3.3999999999723882")
ufunc_gdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrib_types[0] = <char>NPY_FLOAT
ufunc_gdtrib_types[1] = <char>NPY_FLOAT
ufunc_gdtrib_types[2] = <char>NPY_FLOAT
ufunc_gdtrib_types[3] = <char>NPY_FLOAT
ufunc_gdtrib_types[4] = <char>NPY_DOUBLE
ufunc_gdtrib_types[5] = <char>NPY_DOUBLE
ufunc_gdtrib_types[6] = <char>NPY_DOUBLE
ufunc_gdtrib_types[7] = <char>NPY_DOUBLE
ufunc_gdtrib_ptr[2*0] = <void*>_func_cdfgam3_wrap
ufunc_gdtrib_ptr[2*0+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_ptr[2*1] = <void*>_func_cdfgam3_wrap
ufunc_gdtrib_ptr[2*1+1] = <void*>(<char*>"gdtrib")
ufunc_gdtrib_data[0] = &ufunc_gdtrib_ptr[2*0]
ufunc_gdtrib_data[1] = &ufunc_gdtrib_ptr[2*1]
gdtrib = np.PyUFunc_FromFuncAndData(ufunc_gdtrib_loops, ufunc_gdtrib_data, ufunc_gdtrib_types, 2, 3, 1, 0, "gdtrib", ufunc_gdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_gdtrix_loops[2]
cdef void *ufunc_gdtrix_ptr[4]
cdef void *ufunc_gdtrix_data[2]
cdef char ufunc_gdtrix_types[8]
cdef char *ufunc_gdtrix_doc = (
    "gdtrix(a, b, p, out=None)\n"
    "\n"
    "Inverse of `gdtr` vs x.\n"
    "\n"
    "Returns the inverse with respect to the parameter `x` of ``p =\n"
    "gdtr(a, b, x)``, the cumulative distribution function of the gamma\n"
    "distribution. This is also known as the p'th quantile of the\n"
    "distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    `a` parameter values of `gdtr(a, b, x)`.  `1/a` is the \"scale\"\n"
    "    parameter of the gamma distribution.\n"
    "b : array_like\n"
    "    `b` parameter values of `gdtr(a, b, x)`.  `b` is the \"shape\" parameter\n"
    "    of the gamma distribution.\n"
    "p : array_like\n"
    "    Probability values.\n"
    "out : ndarray, optional\n"
    "    If a fourth argument is given, it must be a numpy.ndarray whose size\n"
    "    matches the broadcast result of `a`, `b` and `x`.  `out` is then the\n"
    "    array returned by the function.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : ndarray\n"
    "    Values of the `x` parameter such that `p = gdtr(a, b, x)`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gdtr : CDF of the gamma distribution.\n"
    "gdtria : Inverse with respect to `a` of `gdtr(a, b, x)`.\n"
    "gdtrib : Inverse with respect to `b` of `gdtr(a, b, x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfgam`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_.  Computation of `x` involves a search for a value\n"
    "that produces the desired value of `p`.  The search relies on the\n"
    "monotonicity of `p` with `x`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Computation of the incomplete gamma function ratios and their\n"
    "       inverse.  ACM Trans. Math. Softw. 12 (1986), 377-393.\n"
    "\n"
    "Examples\n"
    "--------\n"
    "First evaluate `gdtr`.\n"
    "\n"
    ">>> from scipy.special import gdtr, gdtrix\n"
    ">>> p = gdtr(1.2, 3.4, 5.6)\n"
    ">>> print(p)\n"
    "0.94378087442\n"
    "\n"
    "Verify the inverse.\n"
    "\n"
    ">>> gdtrix(1.2, 3.4, p)\n"
    "5.5999999999999996")
ufunc_gdtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_gdtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_gdtrix_types[0] = <char>NPY_FLOAT
ufunc_gdtrix_types[1] = <char>NPY_FLOAT
ufunc_gdtrix_types[2] = <char>NPY_FLOAT
ufunc_gdtrix_types[3] = <char>NPY_FLOAT
ufunc_gdtrix_types[4] = <char>NPY_DOUBLE
ufunc_gdtrix_types[5] = <char>NPY_DOUBLE
ufunc_gdtrix_types[6] = <char>NPY_DOUBLE
ufunc_gdtrix_types[7] = <char>NPY_DOUBLE
ufunc_gdtrix_ptr[2*0] = <void*>_func_cdfgam2_wrap
ufunc_gdtrix_ptr[2*0+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_ptr[2*1] = <void*>_func_cdfgam2_wrap
ufunc_gdtrix_ptr[2*1+1] = <void*>(<char*>"gdtrix")
ufunc_gdtrix_data[0] = &ufunc_gdtrix_ptr[2*0]
ufunc_gdtrix_data[1] = &ufunc_gdtrix_ptr[2*1]
gdtrix = np.PyUFunc_FromFuncAndData(ufunc_gdtrix_loops, ufunc_gdtrix_data, ufunc_gdtrix_types, 2, 3, 1, 0, "gdtrix", ufunc_gdtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel1_loops[2]
cdef void *ufunc_hankel1_ptr[4]
cdef void *ufunc_hankel1_data[2]
cdef char ufunc_hankel1_types[6]
cdef char *ufunc_hankel1_doc = (
    "hankel1(v, z)\n"
    "\n"
    "Hankel function of the first kind\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : Values of the Hankel function of the first kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(1)}_v(z) = \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "See also\n"
    "--------\n"
    "hankel1e : this function with leading exponential behavior stripped off.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel1_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel1_types[0] = <char>NPY_FLOAT
ufunc_hankel1_types[1] = <char>NPY_CFLOAT
ufunc_hankel1_types[2] = <char>NPY_CFLOAT
ufunc_hankel1_types[3] = <char>NPY_DOUBLE
ufunc_hankel1_types[4] = <char>NPY_CDOUBLE
ufunc_hankel1_types[5] = <char>NPY_CDOUBLE
ufunc_hankel1_ptr[2*0] = <void*>_func_cbesh_wrap1
ufunc_hankel1_ptr[2*0+1] = <void*>(<char*>"hankel1")
ufunc_hankel1_ptr[2*1] = <void*>_func_cbesh_wrap1
ufunc_hankel1_ptr[2*1+1] = <void*>(<char*>"hankel1")
ufunc_hankel1_data[0] = &ufunc_hankel1_ptr[2*0]
ufunc_hankel1_data[1] = &ufunc_hankel1_ptr[2*1]
hankel1 = np.PyUFunc_FromFuncAndData(ufunc_hankel1_loops, ufunc_hankel1_data, ufunc_hankel1_types, 2, 2, 1, 0, "hankel1", ufunc_hankel1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel1e_loops[2]
cdef void *ufunc_hankel1e_ptr[4]
cdef void *ufunc_hankel1e_data[2]
cdef char ufunc_hankel1e_types[6]
cdef char *ufunc_hankel1e_doc = (
    "hankel1e(v, z)\n"
    "\n"
    "Exponentially scaled Hankel function of the first kind\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    hankel1e(v, z) = hankel1(v, z) * exp(-1j * z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : Values of the exponentially scaled Hankel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(1)}_v(z) = \\frac{2}{\\imath\\pi} \\exp(-\\imath \\pi v/2) K_v(z \\exp(-\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(1)}_{-v}(z) = H^{(1)}_v(z) \\exp(\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel1e_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel1e_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel1e_types[0] = <char>NPY_FLOAT
ufunc_hankel1e_types[1] = <char>NPY_CFLOAT
ufunc_hankel1e_types[2] = <char>NPY_CFLOAT
ufunc_hankel1e_types[3] = <char>NPY_DOUBLE
ufunc_hankel1e_types[4] = <char>NPY_CDOUBLE
ufunc_hankel1e_types[5] = <char>NPY_CDOUBLE
ufunc_hankel1e_ptr[2*0] = <void*>_func_cbesh_wrap1_e
ufunc_hankel1e_ptr[2*0+1] = <void*>(<char*>"hankel1e")
ufunc_hankel1e_ptr[2*1] = <void*>_func_cbesh_wrap1_e
ufunc_hankel1e_ptr[2*1+1] = <void*>(<char*>"hankel1e")
ufunc_hankel1e_data[0] = &ufunc_hankel1e_ptr[2*0]
ufunc_hankel1e_data[1] = &ufunc_hankel1e_ptr[2*1]
hankel1e = np.PyUFunc_FromFuncAndData(ufunc_hankel1e_loops, ufunc_hankel1e_data, ufunc_hankel1e_types, 2, 2, 1, 0, "hankel1e", ufunc_hankel1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel2_loops[2]
cdef void *ufunc_hankel2_ptr[4]
cdef void *ufunc_hankel2_data[2]
cdef char ufunc_hankel2_types[6]
cdef char *ufunc_hankel2_doc = (
    "hankel2(v, z)\n"
    "\n"
    "Hankel function of the second kind\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : Values of the Hankel function of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(2)}_v(z) = -\\frac{2}{\\imath\\pi} \\exp(\\imath \\pi v/2) K_v(z \\exp(\\imath\\pi/2))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "See also\n"
    "--------\n"
    "hankel2e : this function with leading exponential behavior stripped off.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel2_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel2_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel2_types[0] = <char>NPY_FLOAT
ufunc_hankel2_types[1] = <char>NPY_CFLOAT
ufunc_hankel2_types[2] = <char>NPY_CFLOAT
ufunc_hankel2_types[3] = <char>NPY_DOUBLE
ufunc_hankel2_types[4] = <char>NPY_CDOUBLE
ufunc_hankel2_types[5] = <char>NPY_CDOUBLE
ufunc_hankel2_ptr[2*0] = <void*>_func_cbesh_wrap2
ufunc_hankel2_ptr[2*0+1] = <void*>(<char*>"hankel2")
ufunc_hankel2_ptr[2*1] = <void*>_func_cbesh_wrap2
ufunc_hankel2_ptr[2*1+1] = <void*>(<char*>"hankel2")
ufunc_hankel2_data[0] = &ufunc_hankel2_ptr[2*0]
ufunc_hankel2_data[1] = &ufunc_hankel2_ptr[2*1]
hankel2 = np.PyUFunc_FromFuncAndData(ufunc_hankel2_loops, ufunc_hankel2_data, ufunc_hankel2_types, 2, 2, 1, 0, "hankel2", ufunc_hankel2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hankel2e_loops[2]
cdef void *ufunc_hankel2e_ptr[4]
cdef void *ufunc_hankel2e_data[2]
cdef char ufunc_hankel2e_types[6]
cdef char *ufunc_hankel2e_doc = (
    "hankel2e(v, z)\n"
    "\n"
    "Exponentially scaled Hankel function of the second kind\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    hankel2e(v, z) = hankel2(v, z) * exp(1j * z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : Values of the exponentially scaled Hankel function of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "A wrapper for the AMOS [1]_ routine `zbesh`, which carries out the\n"
    "computation using the relation,\n"
    "\n"
    ".. math:: H^{(2)}_v(z) = -\\frac{2}{\\imath\\pi} \\exp(\\frac{\\imath \\pi v}{2}) K_v(z exp(\\frac{\\imath\\pi}{2}))\n"
    "\n"
    "where :math:`K_v` is the modified Bessel function of the second kind.\n"
    "For negative orders, the relation\n"
    "\n"
    ".. math:: H^{(2)}_{-v}(z) = H^{(2)}_v(z) \\exp(-\\imath\\pi v)\n"
    "\n"
    "is used.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_hankel2e_loops[0] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hankel2e_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hankel2e_types[0] = <char>NPY_FLOAT
ufunc_hankel2e_types[1] = <char>NPY_CFLOAT
ufunc_hankel2e_types[2] = <char>NPY_CFLOAT
ufunc_hankel2e_types[3] = <char>NPY_DOUBLE
ufunc_hankel2e_types[4] = <char>NPY_CDOUBLE
ufunc_hankel2e_types[5] = <char>NPY_CDOUBLE
ufunc_hankel2e_ptr[2*0] = <void*>_func_cbesh_wrap2_e
ufunc_hankel2e_ptr[2*0+1] = <void*>(<char*>"hankel2e")
ufunc_hankel2e_ptr[2*1] = <void*>_func_cbesh_wrap2_e
ufunc_hankel2e_ptr[2*1+1] = <void*>(<char*>"hankel2e")
ufunc_hankel2e_data[0] = &ufunc_hankel2e_ptr[2*0]
ufunc_hankel2e_data[1] = &ufunc_hankel2e_ptr[2*1]
hankel2e = np.PyUFunc_FromFuncAndData(ufunc_hankel2e_loops, ufunc_hankel2e_data, ufunc_hankel2e_types, 2, 2, 1, 0, "hankel2e", ufunc_hankel2e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_huber_loops[2]
cdef void *ufunc_huber_ptr[4]
cdef void *ufunc_huber_data[2]
cdef char ufunc_huber_types[6]
cdef char *ufunc_huber_doc = (
    "huber(delta, r)\n"
    "\n"
    "Huber loss function.\n"
    "\n"
    ".. math:: \\text{huber}(\\delta, r) = \\begin{cases} \\infty & \\delta < 0  \\\\ \\frac{1}{2}r^2 & 0 \\le \\delta, | r | \\le \\delta \\\\ \\delta ( |r| - \\frac{1}{2}\\delta ) & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : ndarray\n"
    "    Input array, indicating the quadratic vs. linear loss changepoint.\n"
    "r : ndarray\n"
    "    Input array, possibly representing residuals.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    The computed Huber loss function values.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is convex in r.\n"
    "\n"
    ".. versionadded:: 0.15.0")
ufunc_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_huber_types[0] = <char>NPY_FLOAT
ufunc_huber_types[1] = <char>NPY_FLOAT
ufunc_huber_types[2] = <char>NPY_FLOAT
ufunc_huber_types[3] = <char>NPY_DOUBLE
ufunc_huber_types[4] = <char>NPY_DOUBLE
ufunc_huber_types[5] = <char>NPY_DOUBLE
ufunc_huber_ptr[2*0] = <void*>_func_huber
ufunc_huber_ptr[2*0+1] = <void*>(<char*>"huber")
ufunc_huber_ptr[2*1] = <void*>_func_huber
ufunc_huber_ptr[2*1+1] = <void*>(<char*>"huber")
ufunc_huber_data[0] = &ufunc_huber_ptr[2*0]
ufunc_huber_data[1] = &ufunc_huber_ptr[2*1]
huber = np.PyUFunc_FromFuncAndData(ufunc_huber_loops, ufunc_huber_data, ufunc_huber_types, 2, 2, 1, 0, "huber", ufunc_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp0f1_loops[4]
cdef void *ufunc_hyp0f1_ptr[8]
cdef void *ufunc_hyp0f1_data[4]
cdef char ufunc_hyp0f1_types[12]
cdef char *ufunc_hyp0f1_doc = (
    "hyp0f1(v, x)\n"
    "\n"
    "Confluent hypergeometric limit function 0F1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v, z : array_like\n"
    "    Input values.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "hyp0f1 : ndarray\n"
    "    The confluent hypergeometric limit function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is defined as:\n"
    "\n"
    ".. math:: _0F_1(v, z) = \\sum_{k=0}^{\\infty}\\frac{z^k}{(v)_k k!}.\n"
    "\n"
    "It's also the limit as :math:`q \\to \\infty` of :math:`_1F_1(q; v; z/q)`,\n"
    "and satisfies the differential equation :math:`f''(z) + vf'(z) = f(z)`.")
ufunc_hyp0f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_hyp0f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_hyp0f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_hyp0f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_hyp0f1_types[0] = <char>NPY_FLOAT
ufunc_hyp0f1_types[1] = <char>NPY_FLOAT
ufunc_hyp0f1_types[2] = <char>NPY_FLOAT
ufunc_hyp0f1_types[3] = <char>NPY_FLOAT
ufunc_hyp0f1_types[4] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[5] = <char>NPY_CFLOAT
ufunc_hyp0f1_types[6] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[7] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp0f1_types[10] = <char>NPY_CDOUBLE
ufunc_hyp0f1_types[11] = <char>NPY_CDOUBLE
ufunc_hyp0f1_ptr[2*0] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*0+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*1] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*1+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*2] = <void*>_func__hyp0f1_real
ufunc_hyp0f1_ptr[2*2+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_ptr[2*3] = <void*>_func__hyp0f1_cmplx
ufunc_hyp0f1_ptr[2*3+1] = <void*>(<char*>"hyp0f1")
ufunc_hyp0f1_data[0] = &ufunc_hyp0f1_ptr[2*0]
ufunc_hyp0f1_data[1] = &ufunc_hyp0f1_ptr[2*1]
ufunc_hyp0f1_data[2] = &ufunc_hyp0f1_ptr[2*2]
ufunc_hyp0f1_data[3] = &ufunc_hyp0f1_ptr[2*3]
hyp0f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp0f1_loops, ufunc_hyp0f1_data, ufunc_hyp0f1_types, 4, 2, 1, 0, "hyp0f1", ufunc_hyp0f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp1f1_loops[4]
cdef void *ufunc_hyp1f1_ptr[8]
cdef void *ufunc_hyp1f1_data[4]
cdef char ufunc_hyp1f1_types[16]
cdef char *ufunc_hyp1f1_doc = (
    "hyp1f1(a, b, x)\n"
    "\n"
    "Confluent hypergeometric function 1F1(a, b; x)")
ufunc_hyp1f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyp1f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ffF_F
ufunc_hyp1f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyp1f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_ddD__As_ddD_D
ufunc_hyp1f1_types[0] = <char>NPY_FLOAT
ufunc_hyp1f1_types[1] = <char>NPY_FLOAT
ufunc_hyp1f1_types[2] = <char>NPY_FLOAT
ufunc_hyp1f1_types[3] = <char>NPY_FLOAT
ufunc_hyp1f1_types[4] = <char>NPY_FLOAT
ufunc_hyp1f1_types[5] = <char>NPY_FLOAT
ufunc_hyp1f1_types[6] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[7] = <char>NPY_CFLOAT
ufunc_hyp1f1_types[8] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[9] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[10] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[11] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[12] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[13] = <char>NPY_DOUBLE
ufunc_hyp1f1_types[14] = <char>NPY_CDOUBLE
ufunc_hyp1f1_types[15] = <char>NPY_CDOUBLE
ufunc_hyp1f1_ptr[2*0] = <void*>_func_hyp1f1_wrap
ufunc_hyp1f1_ptr[2*0+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*1] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*1+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*2] = <void*>_func_hyp1f1_wrap
ufunc_hyp1f1_ptr[2*2+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_ptr[2*3] = <void*>_func_chyp1f1_wrap
ufunc_hyp1f1_ptr[2*3+1] = <void*>(<char*>"hyp1f1")
ufunc_hyp1f1_data[0] = &ufunc_hyp1f1_ptr[2*0]
ufunc_hyp1f1_data[1] = &ufunc_hyp1f1_ptr[2*1]
ufunc_hyp1f1_data[2] = &ufunc_hyp1f1_ptr[2*2]
ufunc_hyp1f1_data[3] = &ufunc_hyp1f1_ptr[2*3]
hyp1f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f1_loops, ufunc_hyp1f1_data, ufunc_hyp1f1_types, 4, 3, 1, 0, "hyp1f1", ufunc_hyp1f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp1f2_loops[2]
cdef void *ufunc_hyp1f2_ptr[4]
cdef void *ufunc_hyp1f2_data[2]
cdef char ufunc_hyp1f2_types[12]
cdef char *ufunc_hyp1f2_doc = (
    "hyp1f2(a, b, c, x)\n"
    "\n"
    "Hypergeometric function 1F2 and error estimate\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "err\n"
    "    Error estimate")
ufunc_hyp1f2_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_hyp1f2_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_hyp1f2_types[0] = <char>NPY_FLOAT
ufunc_hyp1f2_types[1] = <char>NPY_FLOAT
ufunc_hyp1f2_types[2] = <char>NPY_FLOAT
ufunc_hyp1f2_types[3] = <char>NPY_FLOAT
ufunc_hyp1f2_types[4] = <char>NPY_FLOAT
ufunc_hyp1f2_types[5] = <char>NPY_FLOAT
ufunc_hyp1f2_types[6] = <char>NPY_DOUBLE
ufunc_hyp1f2_types[7] = <char>NPY_DOUBLE
ufunc_hyp1f2_types[8] = <char>NPY_DOUBLE
ufunc_hyp1f2_types[9] = <char>NPY_DOUBLE
ufunc_hyp1f2_types[10] = <char>NPY_DOUBLE
ufunc_hyp1f2_types[11] = <char>NPY_DOUBLE
ufunc_hyp1f2_ptr[2*0] = <void*>_func_onef2
ufunc_hyp1f2_ptr[2*0+1] = <void*>(<char*>"hyp1f2")
ufunc_hyp1f2_ptr[2*1] = <void*>_func_onef2
ufunc_hyp1f2_ptr[2*1+1] = <void*>(<char*>"hyp1f2")
ufunc_hyp1f2_data[0] = &ufunc_hyp1f2_ptr[2*0]
ufunc_hyp1f2_data[1] = &ufunc_hyp1f2_ptr[2*1]
hyp1f2 = np.PyUFunc_FromFuncAndData(ufunc_hyp1f2_loops, ufunc_hyp1f2_data, ufunc_hyp1f2_types, 2, 4, 2, 0, "hyp1f2", ufunc_hyp1f2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp2f0_loops[3]
cdef void *ufunc_hyp2f0_ptr[6]
cdef void *ufunc_hyp2f0_data[3]
cdef char ufunc_hyp2f0_types[18]
cdef char *ufunc_hyp2f0_doc = (
    "hyp2f0(a, b, x, type)\n"
    "\n"
    "Hypergeometric function 2F0 in y and an error estimate\n"
    "\n"
    "The parameter `type` determines a convergence factor and can be\n"
    "either 1 or 2.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "err\n"
    "    Error estimate")
ufunc_hyp2f0_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_hyp2f0_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddi_d_As_dddl_dd
ufunc_hyp2f0_loops[2] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_hyp2f0_types[0] = <char>NPY_FLOAT
ufunc_hyp2f0_types[1] = <char>NPY_FLOAT
ufunc_hyp2f0_types[2] = <char>NPY_FLOAT
ufunc_hyp2f0_types[3] = <char>NPY_FLOAT
ufunc_hyp2f0_types[4] = <char>NPY_FLOAT
ufunc_hyp2f0_types[5] = <char>NPY_FLOAT
ufunc_hyp2f0_types[6] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[7] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[8] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[9] = <char>NPY_LONG
ufunc_hyp2f0_types[10] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[11] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[12] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[13] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[14] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[15] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[16] = <char>NPY_DOUBLE
ufunc_hyp2f0_types[17] = <char>NPY_DOUBLE
ufunc_hyp2f0_ptr[2*0] = <void*>_func_hyp2f0_unsafe
ufunc_hyp2f0_ptr[2*0+1] = <void*>(<char*>"hyp2f0")
ufunc_hyp2f0_ptr[2*1] = <void*>_func_hyp2f0
ufunc_hyp2f0_ptr[2*1+1] = <void*>(<char*>"hyp2f0")
ufunc_hyp2f0_ptr[2*2] = <void*>_func_hyp2f0_unsafe
ufunc_hyp2f0_ptr[2*2+1] = <void*>(<char*>"hyp2f0")
ufunc_hyp2f0_data[0] = &ufunc_hyp2f0_ptr[2*0]
ufunc_hyp2f0_data[1] = &ufunc_hyp2f0_ptr[2*1]
ufunc_hyp2f0_data[2] = &ufunc_hyp2f0_ptr[2*2]
hyp2f0 = np.PyUFunc_FromFuncAndData(ufunc_hyp2f0_loops, ufunc_hyp2f0_data, ufunc_hyp2f0_types, 3, 4, 2, 0, "hyp2f0", ufunc_hyp2f0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp2f1_loops[4]
cdef void *ufunc_hyp2f1_ptr[8]
cdef void *ufunc_hyp2f1_data[4]
cdef char ufunc_hyp2f1_types[20]
cdef char *ufunc_hyp2f1_doc = (
    "hyp2f1(a, b, c, z)\n"
    "\n"
    "Gauss hypergeometric function 2F1(a, b; c; z).")
ufunc_hyp2f1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_hyp2f1_loops[1] = <np.PyUFuncGenericFunction>loop_D_dddD__As_fffF_F
ufunc_hyp2f1_loops[2] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_hyp2f1_loops[3] = <np.PyUFuncGenericFunction>loop_D_dddD__As_dddD_D
ufunc_hyp2f1_types[0] = <char>NPY_FLOAT
ufunc_hyp2f1_types[1] = <char>NPY_FLOAT
ufunc_hyp2f1_types[2] = <char>NPY_FLOAT
ufunc_hyp2f1_types[3] = <char>NPY_FLOAT
ufunc_hyp2f1_types[4] = <char>NPY_FLOAT
ufunc_hyp2f1_types[5] = <char>NPY_FLOAT
ufunc_hyp2f1_types[6] = <char>NPY_FLOAT
ufunc_hyp2f1_types[7] = <char>NPY_FLOAT
ufunc_hyp2f1_types[8] = <char>NPY_CFLOAT
ufunc_hyp2f1_types[9] = <char>NPY_CFLOAT
ufunc_hyp2f1_types[10] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[11] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[12] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[13] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[14] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[15] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[16] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[17] = <char>NPY_DOUBLE
ufunc_hyp2f1_types[18] = <char>NPY_CDOUBLE
ufunc_hyp2f1_types[19] = <char>NPY_CDOUBLE
ufunc_hyp2f1_ptr[2*0] = <void*>_func_hyp2f1
ufunc_hyp2f1_ptr[2*0+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*1] = <void*>_func_chyp2f1_wrap
ufunc_hyp2f1_ptr[2*1+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*2] = <void*>_func_hyp2f1
ufunc_hyp2f1_ptr[2*2+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_ptr[2*3] = <void*>_func_chyp2f1_wrap
ufunc_hyp2f1_ptr[2*3+1] = <void*>(<char*>"hyp2f1")
ufunc_hyp2f1_data[0] = &ufunc_hyp2f1_ptr[2*0]
ufunc_hyp2f1_data[1] = &ufunc_hyp2f1_ptr[2*1]
ufunc_hyp2f1_data[2] = &ufunc_hyp2f1_ptr[2*2]
ufunc_hyp2f1_data[3] = &ufunc_hyp2f1_ptr[2*3]
hyp2f1 = np.PyUFunc_FromFuncAndData(ufunc_hyp2f1_loops, ufunc_hyp2f1_data, ufunc_hyp2f1_types, 4, 4, 1, 0, "hyp2f1", ufunc_hyp2f1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyp3f0_loops[2]
cdef void *ufunc_hyp3f0_ptr[4]
cdef void *ufunc_hyp3f0_data[2]
cdef char ufunc_hyp3f0_types[12]
cdef char *ufunc_hyp3f0_doc = (
    "hyp3f0(a, b, c, x)\n"
    "\n"
    "Hypergeometric function 3F0 in y and an error estimate\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "err\n"
    "    Error estimate")
ufunc_hyp3f0_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_hyp3f0_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_hyp3f0_types[0] = <char>NPY_FLOAT
ufunc_hyp3f0_types[1] = <char>NPY_FLOAT
ufunc_hyp3f0_types[2] = <char>NPY_FLOAT
ufunc_hyp3f0_types[3] = <char>NPY_FLOAT
ufunc_hyp3f0_types[4] = <char>NPY_FLOAT
ufunc_hyp3f0_types[5] = <char>NPY_FLOAT
ufunc_hyp3f0_types[6] = <char>NPY_DOUBLE
ufunc_hyp3f0_types[7] = <char>NPY_DOUBLE
ufunc_hyp3f0_types[8] = <char>NPY_DOUBLE
ufunc_hyp3f0_types[9] = <char>NPY_DOUBLE
ufunc_hyp3f0_types[10] = <char>NPY_DOUBLE
ufunc_hyp3f0_types[11] = <char>NPY_DOUBLE
ufunc_hyp3f0_ptr[2*0] = <void*>_func_threef0
ufunc_hyp3f0_ptr[2*0+1] = <void*>(<char*>"hyp3f0")
ufunc_hyp3f0_ptr[2*1] = <void*>_func_threef0
ufunc_hyp3f0_ptr[2*1+1] = <void*>(<char*>"hyp3f0")
ufunc_hyp3f0_data[0] = &ufunc_hyp3f0_ptr[2*0]
ufunc_hyp3f0_data[1] = &ufunc_hyp3f0_ptr[2*1]
hyp3f0 = np.PyUFunc_FromFuncAndData(ufunc_hyp3f0_loops, ufunc_hyp3f0_data, ufunc_hyp3f0_types, 2, 4, 2, 0, "hyp3f0", ufunc_hyp3f0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_hyperu_loops[2]
cdef void *ufunc_hyperu_ptr[4]
cdef void *ufunc_hyperu_data[2]
cdef char ufunc_hyperu_types[8]
cdef char *ufunc_hyperu_doc = (
    "hyperu(a, b, x)\n"
    "\n"
    "Confluent hypergeometric function U(a, b, x) of the second kind")
ufunc_hyperu_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_hyperu_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_hyperu_types[0] = <char>NPY_FLOAT
ufunc_hyperu_types[1] = <char>NPY_FLOAT
ufunc_hyperu_types[2] = <char>NPY_FLOAT
ufunc_hyperu_types[3] = <char>NPY_FLOAT
ufunc_hyperu_types[4] = <char>NPY_DOUBLE
ufunc_hyperu_types[5] = <char>NPY_DOUBLE
ufunc_hyperu_types[6] = <char>NPY_DOUBLE
ufunc_hyperu_types[7] = <char>NPY_DOUBLE
ufunc_hyperu_ptr[2*0] = <void*>_func_hypU_wrap
ufunc_hyperu_ptr[2*0+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_ptr[2*1] = <void*>_func_hypU_wrap
ufunc_hyperu_ptr[2*1+1] = <void*>(<char*>"hyperu")
ufunc_hyperu_data[0] = &ufunc_hyperu_ptr[2*0]
ufunc_hyperu_data[1] = &ufunc_hyperu_ptr[2*1]
hyperu = np.PyUFunc_FromFuncAndData(ufunc_hyperu_loops, ufunc_hyperu_data, ufunc_hyperu_types, 2, 3, 1, 0, "hyperu", ufunc_hyperu_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i0_loops[2]
cdef void *ufunc_i0_ptr[4]
cdef void *ufunc_i0_data[2]
cdef char ufunc_i0_types[4]
cdef char *ufunc_i0_doc = (
    "i0(x)\n"
    "\n"
    "Modified Bessel function of order 0.\n"
    "\n"
    "Defined as,\n"
    "\n"
    ".. math::\n"
    "    I_0(x) = \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{(k!)^2} = J_0(\\imath x),\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    Value of the modified Bessel function of order 0 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i0`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "iv\n"
    "i0e\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_i0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i0_types[0] = <char>NPY_FLOAT
ufunc_i0_types[1] = <char>NPY_FLOAT
ufunc_i0_types[2] = <char>NPY_DOUBLE
ufunc_i0_types[3] = <char>NPY_DOUBLE
ufunc_i0_ptr[2*0] = <void*>_func_i0
ufunc_i0_ptr[2*0+1] = <void*>(<char*>"i0")
ufunc_i0_ptr[2*1] = <void*>_func_i0
ufunc_i0_ptr[2*1+1] = <void*>(<char*>"i0")
ufunc_i0_data[0] = &ufunc_i0_ptr[2*0]
ufunc_i0_data[1] = &ufunc_i0_ptr[2*1]
i0 = np.PyUFunc_FromFuncAndData(ufunc_i0_loops, ufunc_i0_data, ufunc_i0_types, 2, 1, 1, 0, "i0", ufunc_i0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i0e_loops[2]
cdef void *ufunc_i0e_ptr[4]
cdef void *ufunc_i0e_data[2]
cdef char ufunc_i0e_types[4]
cdef char *ufunc_i0e_doc = (
    "i0e(x)\n"
    "\n"
    "Exponentially scaled modified Bessel function of order 0.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    i0e(x) = exp(-abs(x)) * i0(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    Value of the exponentially scaled modified Bessel function of order 0\n"
    "    at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.  The\n"
    "polynomial expansions used are the same as those in `i0`, but\n"
    "they are not multiplied by the dominant exponential factor.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i0e`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "iv\n"
    "i0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_i0e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i0e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i0e_types[0] = <char>NPY_FLOAT
ufunc_i0e_types[1] = <char>NPY_FLOAT
ufunc_i0e_types[2] = <char>NPY_DOUBLE
ufunc_i0e_types[3] = <char>NPY_DOUBLE
ufunc_i0e_ptr[2*0] = <void*>_func_i0e
ufunc_i0e_ptr[2*0+1] = <void*>(<char*>"i0e")
ufunc_i0e_ptr[2*1] = <void*>_func_i0e
ufunc_i0e_ptr[2*1+1] = <void*>(<char*>"i0e")
ufunc_i0e_data[0] = &ufunc_i0e_ptr[2*0]
ufunc_i0e_data[1] = &ufunc_i0e_ptr[2*1]
i0e = np.PyUFunc_FromFuncAndData(ufunc_i0e_loops, ufunc_i0e_data, ufunc_i0e_types, 2, 1, 1, 0, "i0e", ufunc_i0e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i1_loops[2]
cdef void *ufunc_i1_ptr[4]
cdef void *ufunc_i1_data[2]
cdef char ufunc_i1_types[4]
cdef char *ufunc_i1_doc = (
    "i1(x)\n"
    "\n"
    "Modified Bessel function of order 1.\n"
    "\n"
    "Defined as,\n"
    "\n"
    ".. math::\n"
    "    I_1(x) = \\frac{1}{2}x \\sum_{k=0}^\\infty \\frac{(x^2/4)^k}{k! (k + 1)!}\n"
    "           = -\\imath J_1(\\imath x),\n"
    "\n"
    "where :math:`J_1` is the Bessel function of the first kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    Value of the modified Bessel function of order 1 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i1`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "iv\n"
    "i1e\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_i1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i1_types[0] = <char>NPY_FLOAT
ufunc_i1_types[1] = <char>NPY_FLOAT
ufunc_i1_types[2] = <char>NPY_DOUBLE
ufunc_i1_types[3] = <char>NPY_DOUBLE
ufunc_i1_ptr[2*0] = <void*>_func_i1
ufunc_i1_ptr[2*0+1] = <void*>(<char*>"i1")
ufunc_i1_ptr[2*1] = <void*>_func_i1
ufunc_i1_ptr[2*1+1] = <void*>(<char*>"i1")
ufunc_i1_data[0] = &ufunc_i1_ptr[2*0]
ufunc_i1_data[1] = &ufunc_i1_ptr[2*1]
i1 = np.PyUFunc_FromFuncAndData(ufunc_i1_loops, ufunc_i1_data, ufunc_i1_types, 2, 1, 1, 0, "i1", ufunc_i1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_i1e_loops[2]
cdef void *ufunc_i1e_ptr[4]
cdef void *ufunc_i1e_data[2]
cdef char ufunc_i1e_types[4]
cdef char *ufunc_i1e_doc = (
    "i1e(x)\n"
    "\n"
    "Exponentially scaled modified Bessel function of order 1.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    i1e(x) = exp(-abs(x)) * i1(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    Value of the exponentially scaled modified Bessel function of order 1\n"
    "    at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 8] and (8, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval. The\n"
    "polynomial expansions used are the same as those in `i1`, but\n"
    "they are not multiplied by the dominant exponential factor.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `i1e`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "iv\n"
    "i1\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_i1e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_i1e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_i1e_types[0] = <char>NPY_FLOAT
ufunc_i1e_types[1] = <char>NPY_FLOAT
ufunc_i1e_types[2] = <char>NPY_DOUBLE
ufunc_i1e_types[3] = <char>NPY_DOUBLE
ufunc_i1e_ptr[2*0] = <void*>_func_i1e
ufunc_i1e_ptr[2*0+1] = <void*>(<char*>"i1e")
ufunc_i1e_ptr[2*1] = <void*>_func_i1e
ufunc_i1e_ptr[2*1+1] = <void*>(<char*>"i1e")
ufunc_i1e_data[0] = &ufunc_i1e_ptr[2*0]
ufunc_i1e_data[1] = &ufunc_i1e_ptr[2*1]
i1e = np.PyUFunc_FromFuncAndData(ufunc_i1e_loops, ufunc_i1e_data, ufunc_i1e_types, 2, 1, 1, 0, "i1e", ufunc_i1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox_loops[2]
cdef void *ufunc_inv_boxcox_ptr[4]
cdef void *ufunc_inv_boxcox_data[2]
cdef char ufunc_inv_boxcox_types[6]
cdef char *ufunc_inv_boxcox_doc = (
    "inv_boxcox(y, lmbda)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : array\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox, inv_boxcox\n"
    ">>> y = boxcox([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox_ptr[2*0] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*0+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_ptr[2*1] = <void*>_func_inv_boxcox
ufunc_inv_boxcox_ptr[2*1+1] = <void*>(<char*>"inv_boxcox")
ufunc_inv_boxcox_data[0] = &ufunc_inv_boxcox_ptr[2*0]
ufunc_inv_boxcox_data[1] = &ufunc_inv_boxcox_ptr[2*1]
inv_boxcox = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox_loops, ufunc_inv_boxcox_data, ufunc_inv_boxcox_types, 2, 2, 1, 0, "inv_boxcox", ufunc_inv_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_inv_boxcox1p_loops[2]
cdef void *ufunc_inv_boxcox1p_ptr[4]
cdef void *ufunc_inv_boxcox1p_data[2]
cdef char ufunc_inv_boxcox1p_types[6]
cdef char *ufunc_inv_boxcox1p_doc = (
    "inv_boxcox1p(y, lmbda)\n"
    "\n"
    "Compute the inverse of the Box-Cox transformation.\n"
    "\n"
    "Find ``x`` such that::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : array\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.16.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p, inv_boxcox1p\n"
    ">>> y = boxcox1p([1, 4, 10], 2.5)\n"
    ">>> inv_boxcox1p(y, 2.5)\n"
    "array([1., 4., 10.])")
ufunc_inv_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_inv_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_inv_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_inv_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_inv_boxcox1p_ptr[2*0] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*0+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_ptr[2*1] = <void*>_func_inv_boxcox1p
ufunc_inv_boxcox1p_ptr[2*1+1] = <void*>(<char*>"inv_boxcox1p")
ufunc_inv_boxcox1p_data[0] = &ufunc_inv_boxcox1p_ptr[2*0]
ufunc_inv_boxcox1p_data[1] = &ufunc_inv_boxcox1p_ptr[2*1]
inv_boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_inv_boxcox1p_loops, ufunc_inv_boxcox1p_data, ufunc_inv_boxcox1p_types, 2, 2, 1, 0, "inv_boxcox1p", ufunc_inv_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2i0k0_loops[2]
cdef void *ufunc_it2i0k0_ptr[4]
cdef void *ufunc_it2i0k0_data[2]
cdef char ufunc_it2i0k0_types[6]
cdef char *ufunc_it2i0k0_doc = (
    "it2i0k0(x)\n"
    "\n"
    "Integrals related to modified Bessel functions of order 0\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ii0\n"
    "    ``integral((i0(t)-1)/t, t=0..x)``\n"
    "ik0\n"
    "    ``int(k0(t)/t, t=x..inf)``")
ufunc_it2i0k0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_it2i0k0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_it2i0k0_types[0] = <char>NPY_FLOAT
ufunc_it2i0k0_types[1] = <char>NPY_FLOAT
ufunc_it2i0k0_types[2] = <char>NPY_FLOAT
ufunc_it2i0k0_types[3] = <char>NPY_DOUBLE
ufunc_it2i0k0_types[4] = <char>NPY_DOUBLE
ufunc_it2i0k0_types[5] = <char>NPY_DOUBLE
ufunc_it2i0k0_ptr[2*0] = <void*>_func_it2i0k0_wrap
ufunc_it2i0k0_ptr[2*0+1] = <void*>(<char*>"it2i0k0")
ufunc_it2i0k0_ptr[2*1] = <void*>_func_it2i0k0_wrap
ufunc_it2i0k0_ptr[2*1+1] = <void*>(<char*>"it2i0k0")
ufunc_it2i0k0_data[0] = &ufunc_it2i0k0_ptr[2*0]
ufunc_it2i0k0_data[1] = &ufunc_it2i0k0_ptr[2*1]
it2i0k0 = np.PyUFunc_FromFuncAndData(ufunc_it2i0k0_loops, ufunc_it2i0k0_data, ufunc_it2i0k0_types, 2, 1, 2, 0, "it2i0k0", ufunc_it2i0k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2j0y0_loops[2]
cdef void *ufunc_it2j0y0_ptr[4]
cdef void *ufunc_it2j0y0_data[2]
cdef char ufunc_it2j0y0_types[6]
cdef char *ufunc_it2j0y0_doc = (
    "it2j0y0(x)\n"
    "\n"
    "Integrals related to Bessel functions of order 0\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ij0\n"
    "    ``integral((1-j0(t))/t, t=0..x)``\n"
    "iy0\n"
    "    ``integral(y0(t)/t, t=x..inf)``")
ufunc_it2j0y0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_it2j0y0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_it2j0y0_types[0] = <char>NPY_FLOAT
ufunc_it2j0y0_types[1] = <char>NPY_FLOAT
ufunc_it2j0y0_types[2] = <char>NPY_FLOAT
ufunc_it2j0y0_types[3] = <char>NPY_DOUBLE
ufunc_it2j0y0_types[4] = <char>NPY_DOUBLE
ufunc_it2j0y0_types[5] = <char>NPY_DOUBLE
ufunc_it2j0y0_ptr[2*0] = <void*>_func_it2j0y0_wrap
ufunc_it2j0y0_ptr[2*0+1] = <void*>(<char*>"it2j0y0")
ufunc_it2j0y0_ptr[2*1] = <void*>_func_it2j0y0_wrap
ufunc_it2j0y0_ptr[2*1+1] = <void*>(<char*>"it2j0y0")
ufunc_it2j0y0_data[0] = &ufunc_it2j0y0_ptr[2*0]
ufunc_it2j0y0_data[1] = &ufunc_it2j0y0_ptr[2*1]
it2j0y0 = np.PyUFunc_FromFuncAndData(ufunc_it2j0y0_loops, ufunc_it2j0y0_data, ufunc_it2j0y0_types, 2, 1, 2, 0, "it2j0y0", ufunc_it2j0y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_it2struve0_loops[2]
cdef void *ufunc_it2struve0_ptr[4]
cdef void *ufunc_it2struve0_data[2]
cdef char ufunc_it2struve0_types[4]
cdef char *ufunc_it2struve0_doc = (
    "it2struve0(x)\n"
    "\n"
    "Integral related to the Struve function of order 0.\n"
    "\n"
    "Returns the integral,\n"
    "\n"
    ".. math::\n"
    "    \\int_x^\\infty \\frac{H_0(t)}{t}\\,dt\n"
    "\n"
    "where :math:`H_0` is the Struve function of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Lower limit of integration.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    The value of the integral.\n"
    "\n"
    "See also\n"
    "--------\n"
    "struve\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       http://jin.ece.illinois.edu/specfunc.html")
ufunc_it2struve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_it2struve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_it2struve0_types[0] = <char>NPY_FLOAT
ufunc_it2struve0_types[1] = <char>NPY_FLOAT
ufunc_it2struve0_types[2] = <char>NPY_DOUBLE
ufunc_it2struve0_types[3] = <char>NPY_DOUBLE
ufunc_it2struve0_ptr[2*0] = <void*>_func_it2struve0_wrap
ufunc_it2struve0_ptr[2*0+1] = <void*>(<char*>"it2struve0")
ufunc_it2struve0_ptr[2*1] = <void*>_func_it2struve0_wrap
ufunc_it2struve0_ptr[2*1+1] = <void*>(<char*>"it2struve0")
ufunc_it2struve0_data[0] = &ufunc_it2struve0_ptr[2*0]
ufunc_it2struve0_data[1] = &ufunc_it2struve0_ptr[2*1]
it2struve0 = np.PyUFunc_FromFuncAndData(ufunc_it2struve0_loops, ufunc_it2struve0_data, ufunc_it2struve0_types, 2, 1, 1, 0, "it2struve0", ufunc_it2struve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itairy_loops[2]
cdef void *ufunc_itairy_ptr[4]
cdef void *ufunc_itairy_data[2]
cdef char ufunc_itairy_types[10]
cdef char *ufunc_itairy_doc = (
    "itairy(x)\n"
    "\n"
    "Integrals of Airy functions\n"
    "\n"
    "Calculates the integrals of Airy functions from 0 to `x`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "\n"
    "x: array_like\n"
    "    Upper limit of integration (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Apt\n"
    "    Integral of Ai(t) from 0 to x.\n"
    "Bpt\n"
    "    Integral of Bi(t) from 0 to x.\n"
    "Ant\n"
    "    Integral of Ai(-t) from 0 to x.\n"
    "Bnt\n"
    "    Integral of Bi(-t) from 0 to x.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    "\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       http://jin.ece.illinois.edu/specfunc.html")
ufunc_itairy_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_f_ffff
ufunc_itairy_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dddd_As_d_dddd
ufunc_itairy_types[0] = <char>NPY_FLOAT
ufunc_itairy_types[1] = <char>NPY_FLOAT
ufunc_itairy_types[2] = <char>NPY_FLOAT
ufunc_itairy_types[3] = <char>NPY_FLOAT
ufunc_itairy_types[4] = <char>NPY_FLOAT
ufunc_itairy_types[5] = <char>NPY_DOUBLE
ufunc_itairy_types[6] = <char>NPY_DOUBLE
ufunc_itairy_types[7] = <char>NPY_DOUBLE
ufunc_itairy_types[8] = <char>NPY_DOUBLE
ufunc_itairy_types[9] = <char>NPY_DOUBLE
ufunc_itairy_ptr[2*0] = <void*>_func_itairy_wrap
ufunc_itairy_ptr[2*0+1] = <void*>(<char*>"itairy")
ufunc_itairy_ptr[2*1] = <void*>_func_itairy_wrap
ufunc_itairy_ptr[2*1+1] = <void*>(<char*>"itairy")
ufunc_itairy_data[0] = &ufunc_itairy_ptr[2*0]
ufunc_itairy_data[1] = &ufunc_itairy_ptr[2*1]
itairy = np.PyUFunc_FromFuncAndData(ufunc_itairy_loops, ufunc_itairy_data, ufunc_itairy_types, 2, 1, 4, 0, "itairy", ufunc_itairy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_iti0k0_loops[2]
cdef void *ufunc_iti0k0_ptr[4]
cdef void *ufunc_iti0k0_data[2]
cdef char ufunc_iti0k0_types[6]
cdef char *ufunc_iti0k0_doc = (
    "iti0k0(x)\n"
    "\n"
    "Integrals of modified Bessel functions of order 0\n"
    "\n"
    "Returns simple integrals from 0 to `x` of the zeroth order modified\n"
    "Bessel functions `i0` and `k0`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ii0, ik0")
ufunc_iti0k0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_iti0k0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_iti0k0_types[0] = <char>NPY_FLOAT
ufunc_iti0k0_types[1] = <char>NPY_FLOAT
ufunc_iti0k0_types[2] = <char>NPY_FLOAT
ufunc_iti0k0_types[3] = <char>NPY_DOUBLE
ufunc_iti0k0_types[4] = <char>NPY_DOUBLE
ufunc_iti0k0_types[5] = <char>NPY_DOUBLE
ufunc_iti0k0_ptr[2*0] = <void*>_func_it1i0k0_wrap
ufunc_iti0k0_ptr[2*0+1] = <void*>(<char*>"iti0k0")
ufunc_iti0k0_ptr[2*1] = <void*>_func_it1i0k0_wrap
ufunc_iti0k0_ptr[2*1+1] = <void*>(<char*>"iti0k0")
ufunc_iti0k0_data[0] = &ufunc_iti0k0_ptr[2*0]
ufunc_iti0k0_data[1] = &ufunc_iti0k0_ptr[2*1]
iti0k0 = np.PyUFunc_FromFuncAndData(ufunc_iti0k0_loops, ufunc_iti0k0_data, ufunc_iti0k0_types, 2, 1, 2, 0, "iti0k0", ufunc_iti0k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itj0y0_loops[2]
cdef void *ufunc_itj0y0_ptr[4]
cdef void *ufunc_itj0y0_data[2]
cdef char ufunc_itj0y0_types[6]
cdef char *ufunc_itj0y0_doc = (
    "itj0y0(x)\n"
    "\n"
    "Integrals of Bessel functions of order 0\n"
    "\n"
    "Returns simple integrals from 0 to `x` of the zeroth order Bessel\n"
    "functions `j0` and `y0`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ij0, iy0")
ufunc_itj0y0_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_itj0y0_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_itj0y0_types[0] = <char>NPY_FLOAT
ufunc_itj0y0_types[1] = <char>NPY_FLOAT
ufunc_itj0y0_types[2] = <char>NPY_FLOAT
ufunc_itj0y0_types[3] = <char>NPY_DOUBLE
ufunc_itj0y0_types[4] = <char>NPY_DOUBLE
ufunc_itj0y0_types[5] = <char>NPY_DOUBLE
ufunc_itj0y0_ptr[2*0] = <void*>_func_it1j0y0_wrap
ufunc_itj0y0_ptr[2*0+1] = <void*>(<char*>"itj0y0")
ufunc_itj0y0_ptr[2*1] = <void*>_func_it1j0y0_wrap
ufunc_itj0y0_ptr[2*1+1] = <void*>(<char*>"itj0y0")
ufunc_itj0y0_data[0] = &ufunc_itj0y0_ptr[2*0]
ufunc_itj0y0_data[1] = &ufunc_itj0y0_ptr[2*1]
itj0y0 = np.PyUFunc_FromFuncAndData(ufunc_itj0y0_loops, ufunc_itj0y0_data, ufunc_itj0y0_types, 2, 1, 2, 0, "itj0y0", ufunc_itj0y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itmodstruve0_loops[2]
cdef void *ufunc_itmodstruve0_ptr[4]
cdef void *ufunc_itmodstruve0_data[2]
cdef char ufunc_itmodstruve0_types[4]
cdef char *ufunc_itmodstruve0_doc = (
    "itmodstruve0(x)\n"
    "\n"
    "Integral of the modified Struve function of order 0.\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x L_0(t)\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper limit of integration (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    The integral of :math:`L_0` from 0 to `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       http://jin.ece.illinois.edu/specfunc.html")
ufunc_itmodstruve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_itmodstruve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_itmodstruve0_types[0] = <char>NPY_FLOAT
ufunc_itmodstruve0_types[1] = <char>NPY_FLOAT
ufunc_itmodstruve0_types[2] = <char>NPY_DOUBLE
ufunc_itmodstruve0_types[3] = <char>NPY_DOUBLE
ufunc_itmodstruve0_ptr[2*0] = <void*>_func_itmodstruve0_wrap
ufunc_itmodstruve0_ptr[2*0+1] = <void*>(<char*>"itmodstruve0")
ufunc_itmodstruve0_ptr[2*1] = <void*>_func_itmodstruve0_wrap
ufunc_itmodstruve0_ptr[2*1+1] = <void*>(<char*>"itmodstruve0")
ufunc_itmodstruve0_data[0] = &ufunc_itmodstruve0_ptr[2*0]
ufunc_itmodstruve0_data[1] = &ufunc_itmodstruve0_ptr[2*1]
itmodstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itmodstruve0_loops, ufunc_itmodstruve0_data, ufunc_itmodstruve0_types, 2, 1, 1, 0, "itmodstruve0", ufunc_itmodstruve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_itstruve0_loops[2]
cdef void *ufunc_itstruve0_ptr[4]
cdef void *ufunc_itstruve0_data[2]
cdef char ufunc_itstruve0_types[4]
cdef char *ufunc_itstruve0_doc = (
    "itstruve0(x)\n"
    "\n"
    "Integral of the Struve function of order 0.\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x H_0(t)\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper limit of integration (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : ndarray\n"
    "    The integral of :math:`H_0` from 0 to `x`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "struve\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for a Fortran routine created by Shanjie Zhang and Jianming\n"
    "Jin [1]_.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       http://jin.ece.illinois.edu/specfunc.html")
ufunc_itstruve0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_itstruve0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_itstruve0_types[0] = <char>NPY_FLOAT
ufunc_itstruve0_types[1] = <char>NPY_FLOAT
ufunc_itstruve0_types[2] = <char>NPY_DOUBLE
ufunc_itstruve0_types[3] = <char>NPY_DOUBLE
ufunc_itstruve0_ptr[2*0] = <void*>_func_itstruve0_wrap
ufunc_itstruve0_ptr[2*0+1] = <void*>(<char*>"itstruve0")
ufunc_itstruve0_ptr[2*1] = <void*>_func_itstruve0_wrap
ufunc_itstruve0_ptr[2*1+1] = <void*>(<char*>"itstruve0")
ufunc_itstruve0_data[0] = &ufunc_itstruve0_ptr[2*0]
ufunc_itstruve0_data[1] = &ufunc_itstruve0_ptr[2*1]
itstruve0 = np.PyUFunc_FromFuncAndData(ufunc_itstruve0_loops, ufunc_itstruve0_data, ufunc_itstruve0_types, 2, 1, 1, 0, "itstruve0", ufunc_itstruve0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_iv_loops[4]
cdef void *ufunc_iv_ptr[8]
cdef void *ufunc_iv_data[4]
cdef char ufunc_iv_types[12]
cdef char *ufunc_iv_doc = (
    "iv(v, z)\n"
    "\n"
    "Modified Bessel function of the first kind of real order.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order. If `z` is of real type and negative, `v` must be integer\n"
    "    valued.\n"
    "z : array_like of float or complex\n"
    "    Argument.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    Values of the modified Bessel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real `z` and :math:`v \\in [-50, 50]`, the evaluation is carried out\n"
    "using Temme's method [1]_.  For larger orders, uniform asymptotic\n"
    "expansions are applied.\n"
    "\n"
    "For complex `z` and positive `v`, the AMOS [2]_ `zbesi` routine is\n"
    "called. It uses a power series for small `z`, the asymptotic expansion\n"
    "for large `abs(z)`, the Miller algorithm normalized by the Wronskian\n"
    "and a Neumann series for intermediate magnitudes, and the uniform\n"
    "asymptotic expansions for :math:`I_v(z)` and :math:`J_v(z)` for large\n"
    "orders.  Backward recurrence is used to generate sequences or reduce\n"
    "orders when necessary.\n"
    "\n"
    "The calculations above are done in the right half plane and continued\n"
    "into the left half plane by the formula,\n"
    "\n"
    ".. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n"
    "\n"
    "(valid when the real part of `z` is positive).  For negative `v`, the\n"
    "formula\n"
    "\n"
    ".. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n"
    "\n"
    "is used, where :math:`K_v(z)` is the modified Bessel function of the\n"
    "second kind, evaluated using the AMOS routine `zbesk`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "kve : This function with leading exponential behavior stripped off.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Temme, Journal of Computational Physics, vol 21, 343 (1976)\n"
    ".. [2] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_iv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_iv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_iv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_iv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_iv_types[0] = <char>NPY_FLOAT
ufunc_iv_types[1] = <char>NPY_FLOAT
ufunc_iv_types[2] = <char>NPY_FLOAT
ufunc_iv_types[3] = <char>NPY_FLOAT
ufunc_iv_types[4] = <char>NPY_CFLOAT
ufunc_iv_types[5] = <char>NPY_CFLOAT
ufunc_iv_types[6] = <char>NPY_DOUBLE
ufunc_iv_types[7] = <char>NPY_DOUBLE
ufunc_iv_types[8] = <char>NPY_DOUBLE
ufunc_iv_types[9] = <char>NPY_DOUBLE
ufunc_iv_types[10] = <char>NPY_CDOUBLE
ufunc_iv_types[11] = <char>NPY_CDOUBLE
ufunc_iv_ptr[2*0] = <void*>_func_iv
ufunc_iv_ptr[2*0+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*1] = <void*>_func_cbesi_wrap
ufunc_iv_ptr[2*1+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*2] = <void*>_func_iv
ufunc_iv_ptr[2*2+1] = <void*>(<char*>"iv")
ufunc_iv_ptr[2*3] = <void*>_func_cbesi_wrap
ufunc_iv_ptr[2*3+1] = <void*>(<char*>"iv")
ufunc_iv_data[0] = &ufunc_iv_ptr[2*0]
ufunc_iv_data[1] = &ufunc_iv_ptr[2*1]
ufunc_iv_data[2] = &ufunc_iv_ptr[2*2]
ufunc_iv_data[3] = &ufunc_iv_ptr[2*3]
iv = np.PyUFunc_FromFuncAndData(ufunc_iv_loops, ufunc_iv_data, ufunc_iv_types, 4, 2, 1, 0, "iv", ufunc_iv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ive_loops[4]
cdef void *ufunc_ive_ptr[8]
cdef void *ufunc_ive_data[4]
cdef char ufunc_ive_types[12]
cdef char *ufunc_ive_doc = (
    "ive(v, z)\n"
    "\n"
    "Exponentially scaled modified Bessel function of the first kind\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    ive(v, z) = iv(v, z) * exp(-abs(z.real))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order.\n"
    "z : array_like of float or complex\n"
    "    Argument.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    Values of the exponentially scaled modified Bessel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v`, the AMOS [1]_ `zbesi` routine is called. It uses a\n"
    "power series for small `z`, the asymptotic expansion for large\n"
    "`abs(z)`, the Miller algorithm normalized by the Wronskian and a\n"
    "Neumann series for intermediate magnitudes, and the uniform asymptotic\n"
    "expansions for :math:`I_v(z)` and :math:`J_v(z)` for large orders.\n"
    "Backward recurrence is used to generate sequences or reduce orders when\n"
    "necessary.\n"
    "\n"
    "The calculations above are done in the right half plane and continued\n"
    "into the left half plane by the formula,\n"
    "\n"
    ".. math:: I_v(z \\exp(\\pm\\imath\\pi)) = \\exp(\\pm\\pi v) I_v(z)\n"
    "\n"
    "(valid when the real part of `z` is positive).  For negative `v`, the\n"
    "formula\n"
    "\n"
    ".. math:: I_{-v}(z) = I_v(z) + \\frac{2}{\\pi} \\sin(\\pi v) K_v(z)\n"
    "\n"
    "is used, where :math:`K_v(z)` is the modified Bessel function of the\n"
    "second kind, evaluated using the AMOS routine `zbesk`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_ive_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_ive_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_ive_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_ive_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_ive_types[0] = <char>NPY_FLOAT
ufunc_ive_types[1] = <char>NPY_FLOAT
ufunc_ive_types[2] = <char>NPY_FLOAT
ufunc_ive_types[3] = <char>NPY_FLOAT
ufunc_ive_types[4] = <char>NPY_CFLOAT
ufunc_ive_types[5] = <char>NPY_CFLOAT
ufunc_ive_types[6] = <char>NPY_DOUBLE
ufunc_ive_types[7] = <char>NPY_DOUBLE
ufunc_ive_types[8] = <char>NPY_DOUBLE
ufunc_ive_types[9] = <char>NPY_DOUBLE
ufunc_ive_types[10] = <char>NPY_CDOUBLE
ufunc_ive_types[11] = <char>NPY_CDOUBLE
ufunc_ive_ptr[2*0] = <void*>_func_cbesi_wrap_e_real
ufunc_ive_ptr[2*0+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*1] = <void*>_func_cbesi_wrap_e
ufunc_ive_ptr[2*1+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*2] = <void*>_func_cbesi_wrap_e_real
ufunc_ive_ptr[2*2+1] = <void*>(<char*>"ive")
ufunc_ive_ptr[2*3] = <void*>_func_cbesi_wrap_e
ufunc_ive_ptr[2*3+1] = <void*>(<char*>"ive")
ufunc_ive_data[0] = &ufunc_ive_ptr[2*0]
ufunc_ive_data[1] = &ufunc_ive_ptr[2*1]
ufunc_ive_data[2] = &ufunc_ive_ptr[2*2]
ufunc_ive_data[3] = &ufunc_ive_ptr[2*3]
ive = np.PyUFunc_FromFuncAndData(ufunc_ive_loops, ufunc_ive_data, ufunc_ive_types, 4, 2, 1, 0, "ive", ufunc_ive_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_j0_loops[2]
cdef void *ufunc_j0_ptr[4]
cdef void *ufunc_j0_data[2]
cdef char ufunc_j0_types[4]
cdef char *ufunc_j0_doc = (
    "j0(x)\n"
    "\n"
    "Bessel function of the first kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : ndarray\n"
    "    Value of the Bessel function of the first kind of order 0 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 5] and (5, infinity). In the\n"
    "first interval the following rational approximation is used:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    J_0(x) \\approx (w - r_1^2)(w - r_2^2) \\frac{P_3(w)}{Q_8(w)},\n"
    "\n"
    "where :math:`w = x^2` and :math:`r_1`, :math:`r_2` are the zeros of\n"
    ":math:`J_0`, and :math:`P_3` and :math:`Q_8` are polynomials of degrees 3\n"
    "and 8, respectively.\n"
    "\n"
    "In the second interval, the Hankel asymptotic expansion is employed with\n"
    "two rational functions of degree 6/6 and 7/7.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `j0`.\n"
    "It should not to be confused with the spherical Bessel functions (see\n"
    "`spherical_jn`).\n"
    "\n"
    "See also\n"
    "--------\n"
    "jv : Bessel function of real order and complex argument.\n"
    "spherical_jn : spherical Bessel functions.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_j0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_j0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_j0_types[0] = <char>NPY_FLOAT
ufunc_j0_types[1] = <char>NPY_FLOAT
ufunc_j0_types[2] = <char>NPY_DOUBLE
ufunc_j0_types[3] = <char>NPY_DOUBLE
ufunc_j0_ptr[2*0] = <void*>_func_j0
ufunc_j0_ptr[2*0+1] = <void*>(<char*>"j0")
ufunc_j0_ptr[2*1] = <void*>_func_j0
ufunc_j0_ptr[2*1+1] = <void*>(<char*>"j0")
ufunc_j0_data[0] = &ufunc_j0_ptr[2*0]
ufunc_j0_data[1] = &ufunc_j0_ptr[2*1]
j0 = np.PyUFunc_FromFuncAndData(ufunc_j0_loops, ufunc_j0_data, ufunc_j0_types, 2, 1, 1, 0, "j0", ufunc_j0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_j1_loops[2]
cdef void *ufunc_j1_ptr[4]
cdef void *ufunc_j1_data[2]
cdef char ufunc_j1_types[4]
cdef char *ufunc_j1_doc = (
    "j1(x)\n"
    "\n"
    "Bessel function of the first kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : ndarray\n"
    "    Value of the Bessel function of the first kind of order 1 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The domain is divided into the intervals [0, 8] and (8, infinity). In the\n"
    "first interval a 24 term Chebyshev expansion is used. In the second, the\n"
    "asymptotic trigonometric representation is employed using two rational\n"
    "functions of degree 5/5.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `j1`.\n"
    "It should not to be confused with the spherical Bessel functions (see\n"
    "`spherical_jn`).\n"
    "\n"
    "See also\n"
    "--------\n"
    "jv\n"
    "spherical_jn : spherical Bessel functions.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_j1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_j1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_j1_types[0] = <char>NPY_FLOAT
ufunc_j1_types[1] = <char>NPY_FLOAT
ufunc_j1_types[2] = <char>NPY_DOUBLE
ufunc_j1_types[3] = <char>NPY_DOUBLE
ufunc_j1_ptr[2*0] = <void*>_func_j1
ufunc_j1_ptr[2*0+1] = <void*>(<char*>"j1")
ufunc_j1_ptr[2*1] = <void*>_func_j1
ufunc_j1_ptr[2*1+1] = <void*>(<char*>"j1")
ufunc_j1_data[0] = &ufunc_j1_ptr[2*0]
ufunc_j1_data[1] = &ufunc_j1_ptr[2*1]
j1 = np.PyUFunc_FromFuncAndData(ufunc_j1_loops, ufunc_j1_data, ufunc_j1_types, 2, 1, 1, 0, "j1", ufunc_j1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_jv_loops[4]
cdef void *ufunc_jv_ptr[8]
cdef void *ufunc_jv_data[4]
cdef char ufunc_jv_types[12]
cdef char *ufunc_jv_doc = (
    "jv(v, z)\n"
    "\n"
    "Bessel function of the first kind of real order and complex argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : ndarray\n"
    "    Value of the Bessel function, :math:`J_v(z)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the AMOS\n"
    "[1]_ `zbesj` routine, which exploits the connection to the modified\n"
    "Bessel function :math:`I_v`,\n"
    "\n"
    ".. math::\n"
    "    J_v(z) = \\exp(n\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z > 0)\n"
    "\n"
    "    J_v(z) = \\exp(-n\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z < 0)\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`Y_v(z)` is the Bessel function of the second\n"
    "kind, computed using the AMOS routine `zbesy`.  Note that the second\n"
    "term is exactly zero for integer `v`; to improve accuracy the second\n"
    "term is explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "Not to be confused with the spherical Bessel functions (see `spherical_jn`).\n"
    "\n"
    "See also\n"
    "--------\n"
    "jve : :math:`J_v` with leading exponential behavior stripped off.\n"
    "spherical_jn : spherical Bessel functions.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_jv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_jv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_jv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_jv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_jv_types[0] = <char>NPY_FLOAT
ufunc_jv_types[1] = <char>NPY_FLOAT
ufunc_jv_types[2] = <char>NPY_FLOAT
ufunc_jv_types[3] = <char>NPY_FLOAT
ufunc_jv_types[4] = <char>NPY_CFLOAT
ufunc_jv_types[5] = <char>NPY_CFLOAT
ufunc_jv_types[6] = <char>NPY_DOUBLE
ufunc_jv_types[7] = <char>NPY_DOUBLE
ufunc_jv_types[8] = <char>NPY_DOUBLE
ufunc_jv_types[9] = <char>NPY_DOUBLE
ufunc_jv_types[10] = <char>NPY_CDOUBLE
ufunc_jv_types[11] = <char>NPY_CDOUBLE
ufunc_jv_ptr[2*0] = <void*>_func_cbesj_wrap_real
ufunc_jv_ptr[2*0+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*1] = <void*>_func_cbesj_wrap
ufunc_jv_ptr[2*1+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*2] = <void*>_func_cbesj_wrap_real
ufunc_jv_ptr[2*2+1] = <void*>(<char*>"jv")
ufunc_jv_ptr[2*3] = <void*>_func_cbesj_wrap
ufunc_jv_ptr[2*3+1] = <void*>(<char*>"jv")
ufunc_jv_data[0] = &ufunc_jv_ptr[2*0]
ufunc_jv_data[1] = &ufunc_jv_ptr[2*1]
ufunc_jv_data[2] = &ufunc_jv_ptr[2*2]
ufunc_jv_data[3] = &ufunc_jv_ptr[2*3]
jv = np.PyUFunc_FromFuncAndData(ufunc_jv_loops, ufunc_jv_data, ufunc_jv_types, 4, 2, 1, 0, "jv", ufunc_jv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_jve_loops[4]
cdef void *ufunc_jve_ptr[8]
cdef void *ufunc_jve_data[4]
cdef char ufunc_jve_types[12]
cdef char *ufunc_jve_doc = (
    "jve(v, z)\n"
    "\n"
    "Exponentially scaled Bessel function of order `v`.\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    jve(v, z) = jv(v, z) * exp(-abs(z.imag))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "J : ndarray\n"
    "    Value of the exponentially scaled Bessel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the AMOS\n"
    "[1]_ `zbesj` routine, which exploits the connection to the modified\n"
    "Bessel function :math:`I_v`,\n"
    "\n"
    ".. math::\n"
    "    J_v(z) = \\exp(n\\pi\\imath/2) I_v(-\\imath z)\\qquad (\\Im z > 0)\n"
    "\n"
    "    J_v(z) = \\exp(-n\\pi\\imath/2) I_v(\\imath z)\\qquad (\\Im z < 0)\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: J_{-v}(z) = J_v(z) \\cos(\\pi v) - Y_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`Y_v(z)` is the Bessel function of the second\n"
    "kind, computed using the AMOS routine `zbesy`.  Note that the second\n"
    "term is exactly zero for integer `v`; to improve accuracy the second\n"
    "term is explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_jve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_jve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_jve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_jve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_jve_types[0] = <char>NPY_FLOAT
ufunc_jve_types[1] = <char>NPY_FLOAT
ufunc_jve_types[2] = <char>NPY_FLOAT
ufunc_jve_types[3] = <char>NPY_FLOAT
ufunc_jve_types[4] = <char>NPY_CFLOAT
ufunc_jve_types[5] = <char>NPY_CFLOAT
ufunc_jve_types[6] = <char>NPY_DOUBLE
ufunc_jve_types[7] = <char>NPY_DOUBLE
ufunc_jve_types[8] = <char>NPY_DOUBLE
ufunc_jve_types[9] = <char>NPY_DOUBLE
ufunc_jve_types[10] = <char>NPY_CDOUBLE
ufunc_jve_types[11] = <char>NPY_CDOUBLE
ufunc_jve_ptr[2*0] = <void*>_func_cbesj_wrap_e_real
ufunc_jve_ptr[2*0+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*1] = <void*>_func_cbesj_wrap_e
ufunc_jve_ptr[2*1+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*2] = <void*>_func_cbesj_wrap_e_real
ufunc_jve_ptr[2*2+1] = <void*>(<char*>"jve")
ufunc_jve_ptr[2*3] = <void*>_func_cbesj_wrap_e
ufunc_jve_ptr[2*3+1] = <void*>(<char*>"jve")
ufunc_jve_data[0] = &ufunc_jve_ptr[2*0]
ufunc_jve_data[1] = &ufunc_jve_ptr[2*1]
ufunc_jve_data[2] = &ufunc_jve_ptr[2*2]
ufunc_jve_data[3] = &ufunc_jve_ptr[2*3]
jve = np.PyUFunc_FromFuncAndData(ufunc_jve_loops, ufunc_jve_data, ufunc_jve_types, 4, 2, 1, 0, "jve", ufunc_jve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k0_loops[2]
cdef void *ufunc_k0_ptr[4]
cdef void *ufunc_k0_data[2]
cdef char ufunc_k0_types[4]
cdef char *ufunc_k0_doc = (
    "k0(x)\n"
    "\n"
    "Modified Bessel function of the second kind of order 0, :math:`K_0`.\n"
    "\n"
    "This function is also sometimes referred to as the modified Bessel\n"
    "function of the third kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the modified Bessel function :math:`K_0` at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k0`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "kv\n"
    "k0e\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_k0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k0_types[0] = <char>NPY_FLOAT
ufunc_k0_types[1] = <char>NPY_FLOAT
ufunc_k0_types[2] = <char>NPY_DOUBLE
ufunc_k0_types[3] = <char>NPY_DOUBLE
ufunc_k0_ptr[2*0] = <void*>_func_k0
ufunc_k0_ptr[2*0+1] = <void*>(<char*>"k0")
ufunc_k0_ptr[2*1] = <void*>_func_k0
ufunc_k0_ptr[2*1+1] = <void*>(<char*>"k0")
ufunc_k0_data[0] = &ufunc_k0_ptr[2*0]
ufunc_k0_data[1] = &ufunc_k0_ptr[2*1]
k0 = np.PyUFunc_FromFuncAndData(ufunc_k0_loops, ufunc_k0_data, ufunc_k0_types, 2, 1, 1, 0, "k0", ufunc_k0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k0e_loops[2]
cdef void *ufunc_k0e_ptr[4]
cdef void *ufunc_k0e_data[2]
cdef char ufunc_k0e_types[4]
cdef char *ufunc_k0e_doc = (
    "k0e(x)\n"
    "\n"
    "Exponentially scaled modified Bessel function K of order 0\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    k0e(x) = exp(x) * k0(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the exponentially scaled modified Bessel function K of order\n"
    "    0 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k0e`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "kv\n"
    "k0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_k0e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k0e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k0e_types[0] = <char>NPY_FLOAT
ufunc_k0e_types[1] = <char>NPY_FLOAT
ufunc_k0e_types[2] = <char>NPY_DOUBLE
ufunc_k0e_types[3] = <char>NPY_DOUBLE
ufunc_k0e_ptr[2*0] = <void*>_func_k0e
ufunc_k0e_ptr[2*0+1] = <void*>(<char*>"k0e")
ufunc_k0e_ptr[2*1] = <void*>_func_k0e
ufunc_k0e_ptr[2*1+1] = <void*>(<char*>"k0e")
ufunc_k0e_data[0] = &ufunc_k0e_ptr[2*0]
ufunc_k0e_data[1] = &ufunc_k0e_ptr[2*1]
k0e = np.PyUFunc_FromFuncAndData(ufunc_k0e_loops, ufunc_k0e_data, ufunc_k0e_types, 2, 1, 1, 0, "k0e", ufunc_k0e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k1_loops[2]
cdef void *ufunc_k1_ptr[4]
cdef void *ufunc_k1_data[2]
cdef char ufunc_k1_types[4]
cdef char *ufunc_k1_doc = (
    "k1(x)\n"
    "\n"
    "Modified Bessel function of the second kind of order 1, :math:`K_1(x)`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the modified Bessel function K of order 1 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k1`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "kv\n"
    "k1e\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_k1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k1_types[0] = <char>NPY_FLOAT
ufunc_k1_types[1] = <char>NPY_FLOAT
ufunc_k1_types[2] = <char>NPY_DOUBLE
ufunc_k1_types[3] = <char>NPY_DOUBLE
ufunc_k1_ptr[2*0] = <void*>_func_k1
ufunc_k1_ptr[2*0+1] = <void*>(<char*>"k1")
ufunc_k1_ptr[2*1] = <void*>_func_k1
ufunc_k1_ptr[2*1+1] = <void*>(<char*>"k1")
ufunc_k1_data[0] = &ufunc_k1_ptr[2*0]
ufunc_k1_data[1] = &ufunc_k1_ptr[2*1]
k1 = np.PyUFunc_FromFuncAndData(ufunc_k1_loops, ufunc_k1_data, ufunc_k1_types, 2, 1, 1, 0, "k1", ufunc_k1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_k1e_loops[2]
cdef void *ufunc_k1e_ptr[4]
cdef void *ufunc_k1e_data[2]
cdef char ufunc_k1e_types[4]
cdef char *ufunc_k1e_doc = (
    "k1e(x)\n"
    "\n"
    "Exponentially scaled modified Bessel function K of order 1\n"
    "\n"
    "Defined as::\n"
    "\n"
    "    k1e(x) = exp(x) * k1(x)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float)\n"
    "\n"
    "Returns\n"
    "-------\n"
    "K : ndarray\n"
    "    Value of the exponentially scaled modified Bessel function K of order\n"
    "    1 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The range is partitioned into the two intervals [0, 2] and (2, infinity).\n"
    "Chebyshev polynomial expansions are employed in each interval.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `k1e`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "kv\n"
    "k1\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_k1e_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_k1e_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_k1e_types[0] = <char>NPY_FLOAT
ufunc_k1e_types[1] = <char>NPY_FLOAT
ufunc_k1e_types[2] = <char>NPY_DOUBLE
ufunc_k1e_types[3] = <char>NPY_DOUBLE
ufunc_k1e_ptr[2*0] = <void*>_func_k1e
ufunc_k1e_ptr[2*0+1] = <void*>(<char*>"k1e")
ufunc_k1e_ptr[2*1] = <void*>_func_k1e
ufunc_k1e_ptr[2*1+1] = <void*>(<char*>"k1e")
ufunc_k1e_data[0] = &ufunc_k1e_ptr[2*0]
ufunc_k1e_data[1] = &ufunc_k1e_ptr[2*1]
k1e = np.PyUFunc_FromFuncAndData(ufunc_k1e_loops, ufunc_k1e_data, ufunc_k1e_types, 2, 1, 1, 0, "k1e", ufunc_k1e_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kei_loops[2]
cdef void *ufunc_kei_ptr[4]
cdef void *ufunc_kei_data[2]
cdef char ufunc_kei_types[4]
cdef char *ufunc_kei_doc = (
    "kei(x)\n"
    "\n"
    "Kelvin function ker")
ufunc_kei_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kei_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kei_types[0] = <char>NPY_FLOAT
ufunc_kei_types[1] = <char>NPY_FLOAT
ufunc_kei_types[2] = <char>NPY_DOUBLE
ufunc_kei_types[3] = <char>NPY_DOUBLE
ufunc_kei_ptr[2*0] = <void*>_func_kei_wrap
ufunc_kei_ptr[2*0+1] = <void*>(<char*>"kei")
ufunc_kei_ptr[2*1] = <void*>_func_kei_wrap
ufunc_kei_ptr[2*1+1] = <void*>(<char*>"kei")
ufunc_kei_data[0] = &ufunc_kei_ptr[2*0]
ufunc_kei_data[1] = &ufunc_kei_ptr[2*1]
kei = np.PyUFunc_FromFuncAndData(ufunc_kei_loops, ufunc_kei_data, ufunc_kei_types, 2, 1, 1, 0, "kei", ufunc_kei_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_keip_loops[2]
cdef void *ufunc_keip_ptr[4]
cdef void *ufunc_keip_data[2]
cdef char ufunc_keip_types[4]
cdef char *ufunc_keip_doc = (
    "keip(x)\n"
    "\n"
    "Derivative of the Kelvin function kei")
ufunc_keip_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_keip_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_keip_types[0] = <char>NPY_FLOAT
ufunc_keip_types[1] = <char>NPY_FLOAT
ufunc_keip_types[2] = <char>NPY_DOUBLE
ufunc_keip_types[3] = <char>NPY_DOUBLE
ufunc_keip_ptr[2*0] = <void*>_func_keip_wrap
ufunc_keip_ptr[2*0+1] = <void*>(<char*>"keip")
ufunc_keip_ptr[2*1] = <void*>_func_keip_wrap
ufunc_keip_ptr[2*1+1] = <void*>(<char*>"keip")
ufunc_keip_data[0] = &ufunc_keip_ptr[2*0]
ufunc_keip_data[1] = &ufunc_keip_ptr[2*1]
keip = np.PyUFunc_FromFuncAndData(ufunc_keip_loops, ufunc_keip_data, ufunc_keip_types, 2, 1, 1, 0, "keip", ufunc_keip_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kelvin_loops[2]
cdef void *ufunc_kelvin_ptr[4]
cdef void *ufunc_kelvin_data[2]
cdef char ufunc_kelvin_types[10]
cdef char *ufunc_kelvin_doc = (
    "kelvin(x)\n"
    "\n"
    "Kelvin functions as complex numbers\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Be, Ke, Bep, Kep\n"
    "    The tuple (Be, Ke, Bep, Kep) contains complex numbers\n"
    "    representing the real and imaginary Kelvin functions and their\n"
    "    derivatives evaluated at `x`.  For example, kelvin(x)[0].real =\n"
    "    ber x and kelvin(x)[0].imag = bei x with similar relationships\n"
    "    for ker and kei.")
ufunc_kelvin_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DDDD_As_f_FFFF
ufunc_kelvin_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DDDD_As_d_DDDD
ufunc_kelvin_types[0] = <char>NPY_FLOAT
ufunc_kelvin_types[1] = <char>NPY_CFLOAT
ufunc_kelvin_types[2] = <char>NPY_CFLOAT
ufunc_kelvin_types[3] = <char>NPY_CFLOAT
ufunc_kelvin_types[4] = <char>NPY_CFLOAT
ufunc_kelvin_types[5] = <char>NPY_DOUBLE
ufunc_kelvin_types[6] = <char>NPY_CDOUBLE
ufunc_kelvin_types[7] = <char>NPY_CDOUBLE
ufunc_kelvin_types[8] = <char>NPY_CDOUBLE
ufunc_kelvin_types[9] = <char>NPY_CDOUBLE
ufunc_kelvin_ptr[2*0] = <void*>_func_kelvin_wrap
ufunc_kelvin_ptr[2*0+1] = <void*>(<char*>"kelvin")
ufunc_kelvin_ptr[2*1] = <void*>_func_kelvin_wrap
ufunc_kelvin_ptr[2*1+1] = <void*>(<char*>"kelvin")
ufunc_kelvin_data[0] = &ufunc_kelvin_ptr[2*0]
ufunc_kelvin_data[1] = &ufunc_kelvin_ptr[2*1]
kelvin = np.PyUFunc_FromFuncAndData(ufunc_kelvin_loops, ufunc_kelvin_data, ufunc_kelvin_types, 2, 1, 4, 0, "kelvin", ufunc_kelvin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ker_loops[2]
cdef void *ufunc_ker_ptr[4]
cdef void *ufunc_ker_data[2]
cdef char ufunc_ker_types[4]
cdef char *ufunc_ker_doc = (
    "ker(x)\n"
    "\n"
    "Kelvin function ker")
ufunc_ker_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ker_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ker_types[0] = <char>NPY_FLOAT
ufunc_ker_types[1] = <char>NPY_FLOAT
ufunc_ker_types[2] = <char>NPY_DOUBLE
ufunc_ker_types[3] = <char>NPY_DOUBLE
ufunc_ker_ptr[2*0] = <void*>_func_ker_wrap
ufunc_ker_ptr[2*0+1] = <void*>(<char*>"ker")
ufunc_ker_ptr[2*1] = <void*>_func_ker_wrap
ufunc_ker_ptr[2*1+1] = <void*>(<char*>"ker")
ufunc_ker_data[0] = &ufunc_ker_ptr[2*0]
ufunc_ker_data[1] = &ufunc_ker_ptr[2*1]
ker = np.PyUFunc_FromFuncAndData(ufunc_ker_loops, ufunc_ker_data, ufunc_ker_types, 2, 1, 1, 0, "ker", ufunc_ker_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kerp_loops[2]
cdef void *ufunc_kerp_ptr[4]
cdef void *ufunc_kerp_data[2]
cdef char ufunc_kerp_types[4]
cdef char *ufunc_kerp_doc = (
    "kerp(x)\n"
    "\n"
    "Derivative of the Kelvin function ker")
ufunc_kerp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kerp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kerp_types[0] = <char>NPY_FLOAT
ufunc_kerp_types[1] = <char>NPY_FLOAT
ufunc_kerp_types[2] = <char>NPY_DOUBLE
ufunc_kerp_types[3] = <char>NPY_DOUBLE
ufunc_kerp_ptr[2*0] = <void*>_func_kerp_wrap
ufunc_kerp_ptr[2*0+1] = <void*>(<char*>"kerp")
ufunc_kerp_ptr[2*1] = <void*>_func_kerp_wrap
ufunc_kerp_ptr[2*1+1] = <void*>(<char*>"kerp")
ufunc_kerp_data[0] = &ufunc_kerp_ptr[2*0]
ufunc_kerp_data[1] = &ufunc_kerp_ptr[2*1]
kerp = np.PyUFunc_FromFuncAndData(ufunc_kerp_loops, ufunc_kerp_data, ufunc_kerp_types, 2, 1, 1, 0, "kerp", ufunc_kerp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kl_div_loops[2]
cdef void *ufunc_kl_div_ptr[4]
cdef void *ufunc_kl_div_data[2]
cdef char ufunc_kl_div_types[6]
cdef char *ufunc_kl_div_doc = (
    "kl_div(x, y)\n"
    "\n"
    "Elementwise function for computing Kullback-Leibler divergence.\n"
    "\n"
    ".. math:: \\mathrm{kl\\_div}(x, y) = \\begin{cases} x \\log(x / y) - x + y & x > 0, y > 0 \\\\ y & x = 0, y \\ge 0 \\\\ \\infty & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    First input array.\n"
    "y : ndarray\n"
    "    Second input array.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    Output array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, rel_entr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is non-negative and is jointly convex in `x` and `y`.\n"
    "\n"
    ".. versionadded:: 0.15.0")
ufunc_kl_div_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kl_div_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kl_div_types[0] = <char>NPY_FLOAT
ufunc_kl_div_types[1] = <char>NPY_FLOAT
ufunc_kl_div_types[2] = <char>NPY_FLOAT
ufunc_kl_div_types[3] = <char>NPY_DOUBLE
ufunc_kl_div_types[4] = <char>NPY_DOUBLE
ufunc_kl_div_types[5] = <char>NPY_DOUBLE
ufunc_kl_div_ptr[2*0] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*0+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_ptr[2*1] = <void*>_func_kl_div
ufunc_kl_div_ptr[2*1+1] = <void*>(<char*>"kl_div")
ufunc_kl_div_data[0] = &ufunc_kl_div_ptr[2*0]
ufunc_kl_div_data[1] = &ufunc_kl_div_ptr[2*1]
kl_div = np.PyUFunc_FromFuncAndData(ufunc_kl_div_loops, ufunc_kl_div_data, ufunc_kl_div_types, 2, 2, 1, 0, "kl_div", ufunc_kl_div_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kn_loops[3]
cdef void *ufunc_kn_ptr[6]
cdef void *ufunc_kn_data[3]
cdef char ufunc_kn_types[9]
cdef char *ufunc_kn_doc = (
    "kn(n, x)\n"
    "\n"
    "Modified Bessel function of the second kind of integer order `n`\n"
    "\n"
    "Returns the modified Bessel function of the second kind for integer order\n"
    "`n` at real `z`.\n"
    "\n"
    "These are also sometimes called functions of the third kind, Basset\n"
    "functions, or Macdonald functions.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like of int\n"
    "    Order of Bessel functions (floats will truncate with a warning)\n"
    "z : array_like of float\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    The results\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kv : Same function, but accepts real order and complex argument\n"
    "kvp : Derivative of this function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Plot the function of several orders for real input:\n"
    "\n"
    ">>> from scipy.special import kn\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 5, 1000)\n"
    ">>> for N in range(6):\n"
    "...     plt.plot(x, kn(N, x), label='$K_{}(x)$'.format(N))\n"
    ">>> plt.ylim(0, 10)\n"
    ">>> plt.legend()\n"
    ">>> plt.title(r'Modified Bessel function of the second kind $K_n(x)$')\n"
    ">>> plt.show()\n"
    "\n"
    "Calculate for a single value at multiple orders:\n"
    "\n"
    ">>> kn([4, 5, 6], 1)\n"
    "array([   44.23241585,   360.9605896 ,  3653.83831186])")
ufunc_kn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_kn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kn_types[0] = <char>NPY_LONG
ufunc_kn_types[1] = <char>NPY_DOUBLE
ufunc_kn_types[2] = <char>NPY_DOUBLE
ufunc_kn_types[3] = <char>NPY_FLOAT
ufunc_kn_types[4] = <char>NPY_FLOAT
ufunc_kn_types[5] = <char>NPY_FLOAT
ufunc_kn_types[6] = <char>NPY_DOUBLE
ufunc_kn_types[7] = <char>NPY_DOUBLE
ufunc_kn_types[8] = <char>NPY_DOUBLE
ufunc_kn_ptr[2*0] = <void*>_func_cbesk_wrap_real_int
ufunc_kn_ptr[2*0+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*1] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*1+1] = <void*>(<char*>"kn")
ufunc_kn_ptr[2*2] = <void*>_func_kn_unsafe
ufunc_kn_ptr[2*2+1] = <void*>(<char*>"kn")
ufunc_kn_data[0] = &ufunc_kn_ptr[2*0]
ufunc_kn_data[1] = &ufunc_kn_ptr[2*1]
ufunc_kn_data[2] = &ufunc_kn_ptr[2*2]
kn = np.PyUFunc_FromFuncAndData(ufunc_kn_loops, ufunc_kn_data, ufunc_kn_types, 3, 2, 1, 0, "kn", ufunc_kn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogi_loops[2]
cdef void *ufunc_kolmogi_ptr[4]
cdef void *ufunc_kolmogi_data[2]
cdef char ufunc_kolmogi_types[4]
cdef char *ufunc_kolmogi_doc = (
    "kolmogi(p)\n"
    "\n"
    "Inverse function to kolmogorov\n"
    "\n"
    "Returns y such that ``kolmogorov(y) == p``.")
ufunc_kolmogi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogi_types[0] = <char>NPY_FLOAT
ufunc_kolmogi_types[1] = <char>NPY_FLOAT
ufunc_kolmogi_types[2] = <char>NPY_DOUBLE
ufunc_kolmogi_types[3] = <char>NPY_DOUBLE
ufunc_kolmogi_ptr[2*0] = <void*>_func_kolmogi
ufunc_kolmogi_ptr[2*0+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_ptr[2*1] = <void*>_func_kolmogi
ufunc_kolmogi_ptr[2*1+1] = <void*>(<char*>"kolmogi")
ufunc_kolmogi_data[0] = &ufunc_kolmogi_ptr[2*0]
ufunc_kolmogi_data[1] = &ufunc_kolmogi_ptr[2*1]
kolmogi = np.PyUFunc_FromFuncAndData(ufunc_kolmogi_loops, ufunc_kolmogi_data, ufunc_kolmogi_types, 2, 1, 1, 0, "kolmogi", ufunc_kolmogi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kolmogorov_loops[2]
cdef void *ufunc_kolmogorov_ptr[4]
cdef void *ufunc_kolmogorov_data[2]
cdef char ufunc_kolmogorov_types[4]
cdef char *ufunc_kolmogorov_doc = (
    "kolmogorov(y)\n"
    "\n"
    "Complementary cumulative distribution function of Kolmogorov distribution\n"
    "\n"
    "Returns the complementary cumulative distribution function of\n"
    "Kolmogorov's limiting distribution (Kn* for large n) of a\n"
    "two-sided test for equality between an empirical and a theoretical\n"
    "distribution. It is equal to the (limit as n->infinity of the)\n"
    "probability that sqrt(n) * max absolute deviation > y.")
ufunc_kolmogorov_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_kolmogorov_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_kolmogorov_types[0] = <char>NPY_FLOAT
ufunc_kolmogorov_types[1] = <char>NPY_FLOAT
ufunc_kolmogorov_types[2] = <char>NPY_DOUBLE
ufunc_kolmogorov_types[3] = <char>NPY_DOUBLE
ufunc_kolmogorov_ptr[2*0] = <void*>_func_kolmogorov
ufunc_kolmogorov_ptr[2*0+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_ptr[2*1] = <void*>_func_kolmogorov
ufunc_kolmogorov_ptr[2*1+1] = <void*>(<char*>"kolmogorov")
ufunc_kolmogorov_data[0] = &ufunc_kolmogorov_ptr[2*0]
ufunc_kolmogorov_data[1] = &ufunc_kolmogorov_ptr[2*1]
kolmogorov = np.PyUFunc_FromFuncAndData(ufunc_kolmogorov_loops, ufunc_kolmogorov_data, ufunc_kolmogorov_types, 2, 1, 1, 0, "kolmogorov", ufunc_kolmogorov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kv_loops[4]
cdef void *ufunc_kv_ptr[8]
cdef void *ufunc_kv_data[4]
cdef char ufunc_kv_types[12]
cdef char *ufunc_kv_doc = (
    "kv(v, z)\n"
    "\n"
    "Modified Bessel function of the second kind of real order `v`\n"
    "\n"
    "Returns the modified Bessel function of the second kind for real order\n"
    "`v` at complex `z`.\n"
    "\n"
    "These are also sometimes called functions of the third kind, Basset\n"
    "functions, or Macdonald functions.  They are defined as those solutions\n"
    "of the modified Bessel equation for which,\n"
    "\n"
    ".. math::\n"
    "    K_v(x) \\sim \\sqrt{\\pi/(2x)} \\exp(-x)\n"
    "\n"
    "as :math:`x \\to \\infty` [3]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order of Bessel functions\n"
    "z : array_like of complex\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    The results. Note that input must be of complex type to get complex\n"
    "    output, e.g. ``kv(3, -2+0j)`` instead of ``kv(3, -2)``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "kve : This function with leading exponential behavior stripped off.\n"
    "kvp : Derivative of this function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265\n"
    ".. [3] NIST Digital Library of Mathematical Functions,\n"
    "       Eq. 10.25.E3. http://dlmf.nist.gov/10.25.E3\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Plot the function of several orders for real input:\n"
    "\n"
    ">>> from scipy.special import kv\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 5, 1000)\n"
    ">>> for N in np.linspace(0, 6, 5):\n"
    "...     plt.plot(x, kv(N, x), label='$K_{{{}}}(x)$'.format(N))\n"
    ">>> plt.ylim(0, 10)\n"
    ">>> plt.legend()\n"
    ">>> plt.title(r'Modified Bessel function of the second kind $K_\\nu(x)$')\n"
    ">>> plt.show()\n"
    "\n"
    "Calculate for a single value at multiple orders:\n"
    "\n"
    ">>> kv([4, 4.5, 5], 1+2j)\n"
    "array([ 0.1992+2.3892j,  2.3493+3.6j   ,  7.2827+3.8104j])")
ufunc_kv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_kv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_kv_types[0] = <char>NPY_FLOAT
ufunc_kv_types[1] = <char>NPY_FLOAT
ufunc_kv_types[2] = <char>NPY_FLOAT
ufunc_kv_types[3] = <char>NPY_FLOAT
ufunc_kv_types[4] = <char>NPY_CFLOAT
ufunc_kv_types[5] = <char>NPY_CFLOAT
ufunc_kv_types[6] = <char>NPY_DOUBLE
ufunc_kv_types[7] = <char>NPY_DOUBLE
ufunc_kv_types[8] = <char>NPY_DOUBLE
ufunc_kv_types[9] = <char>NPY_DOUBLE
ufunc_kv_types[10] = <char>NPY_CDOUBLE
ufunc_kv_types[11] = <char>NPY_CDOUBLE
ufunc_kv_ptr[2*0] = <void*>_func_cbesk_wrap_real
ufunc_kv_ptr[2*0+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*1] = <void*>_func_cbesk_wrap
ufunc_kv_ptr[2*1+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*2] = <void*>_func_cbesk_wrap_real
ufunc_kv_ptr[2*2+1] = <void*>(<char*>"kv")
ufunc_kv_ptr[2*3] = <void*>_func_cbesk_wrap
ufunc_kv_ptr[2*3+1] = <void*>(<char*>"kv")
ufunc_kv_data[0] = &ufunc_kv_ptr[2*0]
ufunc_kv_data[1] = &ufunc_kv_ptr[2*1]
ufunc_kv_data[2] = &ufunc_kv_ptr[2*2]
ufunc_kv_data[3] = &ufunc_kv_ptr[2*3]
kv = np.PyUFunc_FromFuncAndData(ufunc_kv_loops, ufunc_kv_data, ufunc_kv_types, 4, 2, 1, 0, "kv", ufunc_kv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_kve_loops[4]
cdef void *ufunc_kve_ptr[8]
cdef void *ufunc_kve_data[4]
cdef char ufunc_kve_types[12]
cdef char *ufunc_kve_doc = (
    "kve(v, z)\n"
    "\n"
    "Exponentially scaled modified Bessel function of the second kind.\n"
    "\n"
    "Returns the exponentially scaled, modified Bessel function of the\n"
    "second kind (sometimes called the third kind) for real order `v` at\n"
    "complex `z`::\n"
    "\n"
    "    kve(v, z) = kv(v, z) * exp(z)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like of float\n"
    "    Order of Bessel functions\n"
    "z : array_like of complex\n"
    "    Argument at which to evaluate the Bessel functions\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    The exponentially scaled modified Bessel function of the second kind.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for AMOS [1]_ routine `zbesk`.  For a discussion of the\n"
    "algorithm used, see [2]_ and the references therein.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/\n"
    ".. [2] Donald E. Amos, \"Algorithm 644: A portable package for Bessel\n"
    "       functions of a complex argument and nonnegative order\", ACM\n"
    "       TOMS Vol. 12 Issue 3, Sept. 1986, p. 265")
ufunc_kve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_kve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_kve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_kve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_kve_types[0] = <char>NPY_FLOAT
ufunc_kve_types[1] = <char>NPY_FLOAT
ufunc_kve_types[2] = <char>NPY_FLOAT
ufunc_kve_types[3] = <char>NPY_FLOAT
ufunc_kve_types[4] = <char>NPY_CFLOAT
ufunc_kve_types[5] = <char>NPY_CFLOAT
ufunc_kve_types[6] = <char>NPY_DOUBLE
ufunc_kve_types[7] = <char>NPY_DOUBLE
ufunc_kve_types[8] = <char>NPY_DOUBLE
ufunc_kve_types[9] = <char>NPY_DOUBLE
ufunc_kve_types[10] = <char>NPY_CDOUBLE
ufunc_kve_types[11] = <char>NPY_CDOUBLE
ufunc_kve_ptr[2*0] = <void*>_func_cbesk_wrap_e_real
ufunc_kve_ptr[2*0+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*1] = <void*>_func_cbesk_wrap_e
ufunc_kve_ptr[2*1+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*2] = <void*>_func_cbesk_wrap_e_real
ufunc_kve_ptr[2*2+1] = <void*>(<char*>"kve")
ufunc_kve_ptr[2*3] = <void*>_func_cbesk_wrap_e
ufunc_kve_ptr[2*3+1] = <void*>(<char*>"kve")
ufunc_kve_data[0] = &ufunc_kve_ptr[2*0]
ufunc_kve_data[1] = &ufunc_kve_ptr[2*1]
ufunc_kve_data[2] = &ufunc_kve_ptr[2*2]
ufunc_kve_data[3] = &ufunc_kve_ptr[2*3]
kve = np.PyUFunc_FromFuncAndData(ufunc_kve_loops, ufunc_kve_data, ufunc_kve_types, 4, 2, 1, 0, "kve", ufunc_kve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log1p_loops[4]
cdef void *ufunc_log1p_ptr[8]
cdef void *ufunc_log1p_data[4]
cdef char ufunc_log1p_types[8]
cdef char *ufunc_log1p_doc = (
    "log1p(x)\n"
    "\n"
    "Calculates log(1+x) for use when `x` is near zero")
ufunc_log1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log1p_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log1p_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log1p_types[0] = <char>NPY_FLOAT
ufunc_log1p_types[1] = <char>NPY_FLOAT
ufunc_log1p_types[2] = <char>NPY_DOUBLE
ufunc_log1p_types[3] = <char>NPY_DOUBLE
ufunc_log1p_types[4] = <char>NPY_CFLOAT
ufunc_log1p_types[5] = <char>NPY_CFLOAT
ufunc_log1p_types[6] = <char>NPY_CDOUBLE
ufunc_log1p_types[7] = <char>NPY_CDOUBLE
ufunc_log1p_ptr[2*0] = <void*>_func_log1p
ufunc_log1p_ptr[2*0+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*1] = <void*>_func_log1p
ufunc_log1p_ptr[2*1+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*2] = <void*>_func_clog1p
ufunc_log1p_ptr[2*2+1] = <void*>(<char*>"log1p")
ufunc_log1p_ptr[2*3] = <void*>_func_clog1p
ufunc_log1p_ptr[2*3+1] = <void*>(<char*>"log1p")
ufunc_log1p_data[0] = &ufunc_log1p_ptr[2*0]
ufunc_log1p_data[1] = &ufunc_log1p_ptr[2*1]
ufunc_log1p_data[2] = &ufunc_log1p_ptr[2*2]
ufunc_log1p_data[3] = &ufunc_log1p_ptr[2*3]
log1p = np.PyUFunc_FromFuncAndData(ufunc_log1p_loops, ufunc_log1p_data, ufunc_log1p_types, 4, 1, 1, 0, "log1p", ufunc_log1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_log_ndtr_loops[4]
cdef void *ufunc_log_ndtr_ptr[8]
cdef void *ufunc_log_ndtr_data[4]
cdef char ufunc_log_ndtr_types[8]
cdef char *ufunc_log_ndtr_doc = (
    "log_ndtr(x)\n"
    "\n"
    "Logarithm of Gaussian cumulative distribution function.\n"
    "\n"
    "Returns the log of the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`::\n"
    "\n"
    "    log(1/sqrt(2*pi) * integral(exp(-t**2 / 2), t=-inf..x))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ndarray\n"
    "    The value of the log of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf\n"
    "erfc\n"
    "scipy.stats.norm\n"
    "ndtr")
ufunc_log_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_log_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_log_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_log_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_log_ndtr_types[0] = <char>NPY_FLOAT
ufunc_log_ndtr_types[1] = <char>NPY_FLOAT
ufunc_log_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_log_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_log_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_log_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_log_ndtr_ptr[2*0] = <void*>_func_log_ndtr
ufunc_log_ndtr_ptr[2*0+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*1] = <void*>_func_log_ndtr
ufunc_log_ndtr_ptr[2*1+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*2+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_log_ndtr
ufunc_log_ndtr_ptr[2*3+1] = <void*>(<char*>"log_ndtr")
ufunc_log_ndtr_data[0] = &ufunc_log_ndtr_ptr[2*0]
ufunc_log_ndtr_data[1] = &ufunc_log_ndtr_ptr[2*1]
ufunc_log_ndtr_data[2] = &ufunc_log_ndtr_ptr[2*2]
ufunc_log_ndtr_data[3] = &ufunc_log_ndtr_ptr[2*3]
log_ndtr = np.PyUFunc_FromFuncAndData(ufunc_log_ndtr_loops, ufunc_log_ndtr_data, ufunc_log_ndtr_types, 4, 1, 1, 0, "log_ndtr", ufunc_log_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_loggamma_loops[2]
cdef void *ufunc_loggamma_ptr[4]
cdef void *ufunc_loggamma_data[2]
cdef char ufunc_loggamma_types[4]
cdef char *ufunc_loggamma_doc = (
    "loggamma(z, out=None)\n"
    "\n"
    "Principal branch of the logarithm of the Gamma function.\n"
    "\n"
    "Defined to be :math:`\\log(\\Gamma(x))` for :math:`x > 0` and\n"
    "extended to the complex plane by analytic continuation. The\n"
    "function has a single branch cut on the negative real axis.\n"
    "\n"
    ".. versionadded:: 0.18.0\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array-like\n"
    "    Values in the complex plain at which to compute ``loggamma``\n"
    "out : ndarray, optional\n"
    "    Output array for computed values of ``loggamma``\n"
    "\n"
    "Returns\n"
    "-------\n"
    "loggamma : ndarray\n"
    "    Values of ``loggamma`` at z.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "It is not generally true that :math:`\\log\\Gamma(z) =\n"
    "\\log(\\Gamma(z))`, though the real parts of the functions do\n"
    "agree. The benefit of not defining ``loggamma`` as\n"
    ":math:`\\log(\\Gamma(z))` is that the latter function has a\n"
    "complicated branch cut structure whereas ``loggamma`` is analytic\n"
    "except for on the negative real axis.\n"
    "\n"
    "The identities\n"
    "\n"
    ".. math::\n"
    "  \\exp(\\log\\Gamma(z)) &= \\Gamma(z) \\\\\n"
    "  \\log\\Gamma(z + 1) &= \\log(z) + \\log\\Gamma(z)\n"
    "\n"
    "make ``loggama`` useful for working in complex logspace. However,\n"
    "``loggamma`` necessarily returns complex outputs for real inputs,\n"
    "so if you want to work only with real numbers use `gammaln`. On\n"
    "the real line the two functions are related by ``exp(loggamma(x))\n"
    "= gammasgn(x)*exp(gammaln(x))``, though in practice rounding\n"
    "errors will introduce small spurious imaginary components in\n"
    "``exp(loggamma(x))``.\n"
    "\n"
    "The implementation here is based on [hare1997]_.\n"
    "\n"
    "See also\n"
    "--------\n"
    "gammaln : logarithm of the absolute value of the Gamma function\n"
    "gammasgn : sign of the gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [hare1997] D.E.G. Hare,\n"
    "  *Computing the Principal Branch of log-Gamma*,\n"
    "  Journal of Algorithms, Volume 25, Issue 2, November 1997, pages 221-236.")
ufunc_loggamma_loops[0] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_loggamma_loops[1] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_loggamma_types[0] = <char>NPY_CFLOAT
ufunc_loggamma_types[1] = <char>NPY_CFLOAT
ufunc_loggamma_types[2] = <char>NPY_CDOUBLE
ufunc_loggamma_types[3] = <char>NPY_CDOUBLE
ufunc_loggamma_ptr[2*0] = <void*>_func_loggamma
ufunc_loggamma_ptr[2*0+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_ptr[2*1] = <void*>_func_loggamma
ufunc_loggamma_ptr[2*1+1] = <void*>(<char*>"loggamma")
ufunc_loggamma_data[0] = &ufunc_loggamma_ptr[2*0]
ufunc_loggamma_data[1] = &ufunc_loggamma_ptr[2*1]
loggamma = np.PyUFunc_FromFuncAndData(ufunc_loggamma_loops, ufunc_loggamma_data, ufunc_loggamma_types, 2, 1, 1, 0, "loggamma", ufunc_loggamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_logit_loops[3]
cdef void *ufunc_logit_ptr[6]
cdef void *ufunc_logit_data[3]
cdef char ufunc_logit_types[6]
cdef char *ufunc_logit_doc = (
    "logit(x)\n"
    "\n"
    "Logit ufunc for ndarrays.\n"
    "\n"
    "The logit function is defined as logit(p) = log(p/(1-p)).\n"
    "Note that logit(0) = -inf, logit(1) = inf, and logit(p)\n"
    "for p<0 or p>1 yields nan.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    The ndarray to apply logit to element-wise.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "out : ndarray\n"
    "    An ndarray of the same shape as x. Its entries\n"
    "    are logit of the corresponding entry of x.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expit\n"
    "\n"
    "Notes\n"
    "-----\n"
    "As a ufunc logit takes a number of optional\n"
    "keyword arguments. For more information\n"
    "see `ufuncs <https://docs.scipy.org/doc/numpy/reference/ufuncs.html>`_\n"
    "\n"
    ".. versionadded:: 0.10.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import logit, expit\n"
    "\n"
    ">>> logit([0, 0.25, 0.5, 0.75, 1])\n"
    "array([       -inf, -1.09861229,  0.        ,  1.09861229,         inf])\n"
    "\n"
    "`expit` is the inverse of `logit`:\n"
    "\n"
    ">>> expit(logit([0.1, 0.75, 0.999]))\n"
    "array([ 0.1  ,  0.75 ,  0.999])\n"
    "\n"
    "Plot logit(x) for x in [0, 1]:\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(0, 1, 501)\n"
    ">>> y = logit(x)\n"
    ">>> plt.plot(x, y)\n"
    ">>> plt.grid()\n"
    ">>> plt.ylim(-6, 6)\n"
    ">>> plt.xlabel('x')\n"
    ">>> plt.title('logit(x)')\n"
    ">>> plt.show()")
ufunc_logit_loops[0] = <np.PyUFuncGenericFunction>loop_f_f__As_f_f
ufunc_logit_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_logit_loops[2] = <np.PyUFuncGenericFunction>loop_g_g__As_g_g
ufunc_logit_types[0] = <char>NPY_FLOAT
ufunc_logit_types[1] = <char>NPY_FLOAT
ufunc_logit_types[2] = <char>NPY_DOUBLE
ufunc_logit_types[3] = <char>NPY_DOUBLE
ufunc_logit_types[4] = <char>NPY_LONGDOUBLE
ufunc_logit_types[5] = <char>NPY_LONGDOUBLE
ufunc_logit_ptr[2*0] = <void*>_func_logitf
ufunc_logit_ptr[2*0+1] = <void*>(<char*>"logit")
ufunc_logit_ptr[2*1] = <void*>_func_logit
ufunc_logit_ptr[2*1+1] = <void*>(<char*>"logit")
ufunc_logit_ptr[2*2] = <void*>_func_logitl
ufunc_logit_ptr[2*2+1] = <void*>(<char*>"logit")
ufunc_logit_data[0] = &ufunc_logit_ptr[2*0]
ufunc_logit_data[1] = &ufunc_logit_ptr[2*1]
ufunc_logit_data[2] = &ufunc_logit_ptr[2*2]
logit = np.PyUFunc_FromFuncAndData(ufunc_logit_loops, ufunc_logit_data, ufunc_logit_types, 3, 1, 1, 0, "logit", ufunc_logit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_lpmv_loops[2]
cdef void *ufunc_lpmv_ptr[4]
cdef void *ufunc_lpmv_data[2]
cdef char ufunc_lpmv_types[8]
cdef char *ufunc_lpmv_doc = (
    "lpmv(m, v, x)\n"
    "\n"
    "Associated Legendre function of integer order and real degree.\n"
    "\n"
    "Defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v^m = (-1)^m (1 - x^2)^{m/2} \\frac{d^m}{dx^m} P_v(x)\n"
    "\n"
    "where\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P_v = \\sum_{k = 0}^\\infty \\frac{(-v)_k (v + 1)_k}{(k!)^2}\n"
    "            \\left(\\frac{1 - x}{2}\\right)^k\n"
    "\n"
    "is the Legendre function of the first kind. Here :math:`(\\cdot)_k`\n"
    "is the Pochhammer symbol; see `poch`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order (int or float). If passed a float not equal to an\n"
    "    integer the function returns NaN.\n"
    "v : array_like\n"
    "    Degree (float).\n"
    "x : array_like\n"
    "    Argument (float). Must have ``|x| <= 1``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "pmv : ndarray\n"
    "    Value of the associated Legendre function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lpmn : Compute the associated Legendre function for all orders\n"
    "       ``0, ..., m`` and degrees ``0, ..., n``.\n"
    "clpmn : Compute the associated Legendre function at complex\n"
    "        arguments.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Note that this implementation includes the Condon-Shortley phase.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Zhang, Jin, \"Computation of Special Functions\", John Wiley\n"
    "       and Sons, Inc, 1996.")
ufunc_lpmv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_lpmv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_lpmv_types[0] = <char>NPY_FLOAT
ufunc_lpmv_types[1] = <char>NPY_FLOAT
ufunc_lpmv_types[2] = <char>NPY_FLOAT
ufunc_lpmv_types[3] = <char>NPY_FLOAT
ufunc_lpmv_types[4] = <char>NPY_DOUBLE
ufunc_lpmv_types[5] = <char>NPY_DOUBLE
ufunc_lpmv_types[6] = <char>NPY_DOUBLE
ufunc_lpmv_types[7] = <char>NPY_DOUBLE
ufunc_lpmv_ptr[2*0] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*0+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_ptr[2*1] = <void*>_func_pmv_wrap
ufunc_lpmv_ptr[2*1+1] = <void*>(<char*>"lpmv")
ufunc_lpmv_data[0] = &ufunc_lpmv_ptr[2*0]
ufunc_lpmv_data[1] = &ufunc_lpmv_ptr[2*1]
lpmv = np.PyUFunc_FromFuncAndData(ufunc_lpmv_loops, ufunc_lpmv_data, ufunc_lpmv_types, 2, 3, 1, 0, "lpmv", ufunc_lpmv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_a_loops[2]
cdef void *ufunc_mathieu_a_ptr[4]
cdef void *ufunc_mathieu_a_data[2]
cdef char ufunc_mathieu_a_types[6]
cdef char *ufunc_mathieu_a_doc = (
    "mathieu_a(m, q)\n"
    "\n"
    "Characteristic value of even Mathieu functions\n"
    "\n"
    "Returns the characteristic value for the even solution,\n"
    "``ce_m(z, q)``, of Mathieu's equation.")
ufunc_mathieu_a_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_mathieu_a_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_mathieu_a_types[0] = <char>NPY_FLOAT
ufunc_mathieu_a_types[1] = <char>NPY_FLOAT
ufunc_mathieu_a_types[2] = <char>NPY_FLOAT
ufunc_mathieu_a_types[3] = <char>NPY_DOUBLE
ufunc_mathieu_a_types[4] = <char>NPY_DOUBLE
ufunc_mathieu_a_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_a_ptr[2*0] = <void*>_func_cem_cva_wrap
ufunc_mathieu_a_ptr[2*0+1] = <void*>(<char*>"mathieu_a")
ufunc_mathieu_a_ptr[2*1] = <void*>_func_cem_cva_wrap
ufunc_mathieu_a_ptr[2*1+1] = <void*>(<char*>"mathieu_a")
ufunc_mathieu_a_data[0] = &ufunc_mathieu_a_ptr[2*0]
ufunc_mathieu_a_data[1] = &ufunc_mathieu_a_ptr[2*1]
mathieu_a = np.PyUFunc_FromFuncAndData(ufunc_mathieu_a_loops, ufunc_mathieu_a_data, ufunc_mathieu_a_types, 2, 2, 1, 0, "mathieu_a", ufunc_mathieu_a_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_b_loops[2]
cdef void *ufunc_mathieu_b_ptr[4]
cdef void *ufunc_mathieu_b_data[2]
cdef char ufunc_mathieu_b_types[6]
cdef char *ufunc_mathieu_b_doc = (
    "mathieu_b(m, q)\n"
    "\n"
    "Characteristic value of odd Mathieu functions\n"
    "\n"
    "Returns the characteristic value for the odd solution,\n"
    "``se_m(z, q)``, of Mathieu's equation.")
ufunc_mathieu_b_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_mathieu_b_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_mathieu_b_types[0] = <char>NPY_FLOAT
ufunc_mathieu_b_types[1] = <char>NPY_FLOAT
ufunc_mathieu_b_types[2] = <char>NPY_FLOAT
ufunc_mathieu_b_types[3] = <char>NPY_DOUBLE
ufunc_mathieu_b_types[4] = <char>NPY_DOUBLE
ufunc_mathieu_b_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_b_ptr[2*0] = <void*>_func_sem_cva_wrap
ufunc_mathieu_b_ptr[2*0+1] = <void*>(<char*>"mathieu_b")
ufunc_mathieu_b_ptr[2*1] = <void*>_func_sem_cva_wrap
ufunc_mathieu_b_ptr[2*1+1] = <void*>(<char*>"mathieu_b")
ufunc_mathieu_b_data[0] = &ufunc_mathieu_b_ptr[2*0]
ufunc_mathieu_b_data[1] = &ufunc_mathieu_b_ptr[2*1]
mathieu_b = np.PyUFunc_FromFuncAndData(ufunc_mathieu_b_loops, ufunc_mathieu_b_data, ufunc_mathieu_b_types, 2, 2, 1, 0, "mathieu_b", ufunc_mathieu_b_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_cem_loops[2]
cdef void *ufunc_mathieu_cem_ptr[4]
cdef void *ufunc_mathieu_cem_data[2]
cdef char ufunc_mathieu_cem_types[10]
cdef char *ufunc_mathieu_cem_doc = (
    "mathieu_cem(m, q, x)\n"
    "\n"
    "Even Mathieu function and its derivative\n"
    "\n"
    "Returns the even Mathieu function, ``ce_m(x, q)``, of order `m` and\n"
    "parameter `q` evaluated at `x` (given in degrees).  Also returns the\n"
    "derivative with respect to `x` of ce_m(x, q)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m\n"
    "    Order of the function\n"
    "q\n"
    "    Parameter of the function\n"
    "x\n"
    "    Argument of the function, *given in degrees, not radians*\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_cem_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_cem_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_cem_types[0] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[1] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[2] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[3] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[4] = <char>NPY_FLOAT
ufunc_mathieu_cem_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_cem_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_cem_ptr[2*0] = <void*>_func_cem_wrap
ufunc_mathieu_cem_ptr[2*0+1] = <void*>(<char*>"mathieu_cem")
ufunc_mathieu_cem_ptr[2*1] = <void*>_func_cem_wrap
ufunc_mathieu_cem_ptr[2*1+1] = <void*>(<char*>"mathieu_cem")
ufunc_mathieu_cem_data[0] = &ufunc_mathieu_cem_ptr[2*0]
ufunc_mathieu_cem_data[1] = &ufunc_mathieu_cem_ptr[2*1]
mathieu_cem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_cem_loops, ufunc_mathieu_cem_data, ufunc_mathieu_cem_types, 2, 3, 2, 0, "mathieu_cem", ufunc_mathieu_cem_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem1_loops[2]
cdef void *ufunc_mathieu_modcem1_ptr[4]
cdef void *ufunc_mathieu_modcem1_data[2]
cdef char ufunc_mathieu_modcem1_types[10]
cdef char *ufunc_mathieu_modcem1_doc = (
    "mathieu_modcem1(m, q, x)\n"
    "\n"
    "Even modified Mathieu function of the first kind and its derivative\n"
    "\n"
    "Evaluates the even modified Mathieu function of the first kind,\n"
    "``Mc1m(x, q)``, and its derivative at `x` for order `m` and parameter\n"
    "`q`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_modcem1_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modcem1_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modcem1_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modcem1_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modcem1_ptr[2*0] = <void*>_func_mcm1_wrap
ufunc_mathieu_modcem1_ptr[2*0+1] = <void*>(<char*>"mathieu_modcem1")
ufunc_mathieu_modcem1_ptr[2*1] = <void*>_func_mcm1_wrap
ufunc_mathieu_modcem1_ptr[2*1+1] = <void*>(<char*>"mathieu_modcem1")
ufunc_mathieu_modcem1_data[0] = &ufunc_mathieu_modcem1_ptr[2*0]
ufunc_mathieu_modcem1_data[1] = &ufunc_mathieu_modcem1_ptr[2*1]
mathieu_modcem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem1_loops, ufunc_mathieu_modcem1_data, ufunc_mathieu_modcem1_types, 2, 3, 2, 0, "mathieu_modcem1", ufunc_mathieu_modcem1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modcem2_loops[2]
cdef void *ufunc_mathieu_modcem2_ptr[4]
cdef void *ufunc_mathieu_modcem2_data[2]
cdef char ufunc_mathieu_modcem2_types[10]
cdef char *ufunc_mathieu_modcem2_doc = (
    "mathieu_modcem2(m, q, x)\n"
    "\n"
    "Even modified Mathieu function of the second kind and its derivative\n"
    "\n"
    "Evaluates the even modified Mathieu function of the second kind,\n"
    "Mc2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter `q`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_modcem2_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modcem2_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modcem2_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modcem2_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modcem2_ptr[2*0] = <void*>_func_mcm2_wrap
ufunc_mathieu_modcem2_ptr[2*0+1] = <void*>(<char*>"mathieu_modcem2")
ufunc_mathieu_modcem2_ptr[2*1] = <void*>_func_mcm2_wrap
ufunc_mathieu_modcem2_ptr[2*1+1] = <void*>(<char*>"mathieu_modcem2")
ufunc_mathieu_modcem2_data[0] = &ufunc_mathieu_modcem2_ptr[2*0]
ufunc_mathieu_modcem2_data[1] = &ufunc_mathieu_modcem2_ptr[2*1]
mathieu_modcem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modcem2_loops, ufunc_mathieu_modcem2_data, ufunc_mathieu_modcem2_types, 2, 3, 2, 0, "mathieu_modcem2", ufunc_mathieu_modcem2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem1_loops[2]
cdef void *ufunc_mathieu_modsem1_ptr[4]
cdef void *ufunc_mathieu_modsem1_data[2]
cdef char ufunc_mathieu_modsem1_types[10]
cdef char *ufunc_mathieu_modsem1_doc = (
    "mathieu_modsem1(m, q, x)\n"
    "\n"
    "Odd modified Mathieu function of the first kind and its derivative\n"
    "\n"
    "Evaluates the odd modified Mathieu function of the first kind,\n"
    "Ms1m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter `q`.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_modsem1_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modsem1_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modsem1_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modsem1_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modsem1_ptr[2*0] = <void*>_func_msm1_wrap
ufunc_mathieu_modsem1_ptr[2*0+1] = <void*>(<char*>"mathieu_modsem1")
ufunc_mathieu_modsem1_ptr[2*1] = <void*>_func_msm1_wrap
ufunc_mathieu_modsem1_ptr[2*1+1] = <void*>(<char*>"mathieu_modsem1")
ufunc_mathieu_modsem1_data[0] = &ufunc_mathieu_modsem1_ptr[2*0]
ufunc_mathieu_modsem1_data[1] = &ufunc_mathieu_modsem1_ptr[2*1]
mathieu_modsem1 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem1_loops, ufunc_mathieu_modsem1_data, ufunc_mathieu_modsem1_types, 2, 3, 2, 0, "mathieu_modsem1", ufunc_mathieu_modsem1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_modsem2_loops[2]
cdef void *ufunc_mathieu_modsem2_ptr[4]
cdef void *ufunc_mathieu_modsem2_data[2]
cdef char ufunc_mathieu_modsem2_types[10]
cdef char *ufunc_mathieu_modsem2_doc = (
    "mathieu_modsem2(m, q, x)\n"
    "\n"
    "Odd modified Mathieu function of the second kind and its derivative\n"
    "\n"
    "Evaluates the odd modified Mathieu function of the second kind,\n"
    "Ms2m(x, q), and its derivative at `x` (given in degrees) for order `m`\n"
    "and parameter q.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_modsem2_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_modsem2_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_modsem2_types[0] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[1] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[2] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[3] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[4] = <char>NPY_FLOAT
ufunc_mathieu_modsem2_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_modsem2_ptr[2*0] = <void*>_func_msm2_wrap
ufunc_mathieu_modsem2_ptr[2*0+1] = <void*>(<char*>"mathieu_modsem2")
ufunc_mathieu_modsem2_ptr[2*1] = <void*>_func_msm2_wrap
ufunc_mathieu_modsem2_ptr[2*1+1] = <void*>(<char*>"mathieu_modsem2")
ufunc_mathieu_modsem2_data[0] = &ufunc_mathieu_modsem2_ptr[2*0]
ufunc_mathieu_modsem2_data[1] = &ufunc_mathieu_modsem2_ptr[2*1]
mathieu_modsem2 = np.PyUFunc_FromFuncAndData(ufunc_mathieu_modsem2_loops, ufunc_mathieu_modsem2_data, ufunc_mathieu_modsem2_types, 2, 3, 2, 0, "mathieu_modsem2", ufunc_mathieu_modsem2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_mathieu_sem_loops[2]
cdef void *ufunc_mathieu_sem_ptr[4]
cdef void *ufunc_mathieu_sem_data[2]
cdef char ufunc_mathieu_sem_types[10]
cdef char *ufunc_mathieu_sem_doc = (
    "mathieu_sem(m, q, x)\n"
    "\n"
    "Odd Mathieu function and its derivative\n"
    "\n"
    "Returns the odd Mathieu function, se_m(x, q), of order `m` and\n"
    "parameter `q` evaluated at `x` (given in degrees).  Also returns the\n"
    "derivative with respect to `x` of se_m(x, q).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m\n"
    "    Order of the function\n"
    "q\n"
    "    Parameter of the function\n"
    "x\n"
    "    Argument of the function, *given in degrees, not radians*.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y\n"
    "    Value of the function\n"
    "yp\n"
    "    Value of the derivative vs x")
ufunc_mathieu_sem_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_fff_ff
ufunc_mathieu_sem_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddd_dd_As_ddd_dd
ufunc_mathieu_sem_types[0] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[1] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[2] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[3] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[4] = <char>NPY_FLOAT
ufunc_mathieu_sem_types[5] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[6] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[7] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[8] = <char>NPY_DOUBLE
ufunc_mathieu_sem_types[9] = <char>NPY_DOUBLE
ufunc_mathieu_sem_ptr[2*0] = <void*>_func_sem_wrap
ufunc_mathieu_sem_ptr[2*0+1] = <void*>(<char*>"mathieu_sem")
ufunc_mathieu_sem_ptr[2*1] = <void*>_func_sem_wrap
ufunc_mathieu_sem_ptr[2*1+1] = <void*>(<char*>"mathieu_sem")
ufunc_mathieu_sem_data[0] = &ufunc_mathieu_sem_ptr[2*0]
ufunc_mathieu_sem_data[1] = &ufunc_mathieu_sem_ptr[2*1]
mathieu_sem = np.PyUFunc_FromFuncAndData(ufunc_mathieu_sem_loops, ufunc_mathieu_sem_data, ufunc_mathieu_sem_types, 2, 3, 2, 0, "mathieu_sem", ufunc_mathieu_sem_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modfresnelm_loops[2]
cdef void *ufunc_modfresnelm_ptr[4]
cdef void *ufunc_modfresnelm_data[2]
cdef char ufunc_modfresnelm_types[6]
cdef char *ufunc_modfresnelm_doc = (
    "modfresnelm(x)\n"
    "\n"
    "Modified Fresnel negative integrals\n"
    "\n"
    "Returns\n"
    "-------\n"
    "fm\n"
    "    Integral ``F_-(x)``: ``integral(exp(-1j*t*t), t=x..inf)``\n"
    "km\n"
    "    Integral ``K_-(x)``: ``1/sqrt(pi)*exp(1j*(x*x+pi/4))*fp``")
ufunc_modfresnelm_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_f_FF
ufunc_modfresnelm_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_d_DD
ufunc_modfresnelm_types[0] = <char>NPY_FLOAT
ufunc_modfresnelm_types[1] = <char>NPY_CFLOAT
ufunc_modfresnelm_types[2] = <char>NPY_CFLOAT
ufunc_modfresnelm_types[3] = <char>NPY_DOUBLE
ufunc_modfresnelm_types[4] = <char>NPY_CDOUBLE
ufunc_modfresnelm_types[5] = <char>NPY_CDOUBLE
ufunc_modfresnelm_ptr[2*0] = <void*>_func_modified_fresnel_minus_wrap
ufunc_modfresnelm_ptr[2*0+1] = <void*>(<char*>"modfresnelm")
ufunc_modfresnelm_ptr[2*1] = <void*>_func_modified_fresnel_minus_wrap
ufunc_modfresnelm_ptr[2*1+1] = <void*>(<char*>"modfresnelm")
ufunc_modfresnelm_data[0] = &ufunc_modfresnelm_ptr[2*0]
ufunc_modfresnelm_data[1] = &ufunc_modfresnelm_ptr[2*1]
modfresnelm = np.PyUFunc_FromFuncAndData(ufunc_modfresnelm_loops, ufunc_modfresnelm_data, ufunc_modfresnelm_types, 2, 1, 2, 0, "modfresnelm", ufunc_modfresnelm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modfresnelp_loops[2]
cdef void *ufunc_modfresnelp_ptr[4]
cdef void *ufunc_modfresnelp_data[2]
cdef char ufunc_modfresnelp_types[6]
cdef char *ufunc_modfresnelp_doc = (
    "modfresnelp(x)\n"
    "\n"
    "Modified Fresnel positive integrals\n"
    "\n"
    "Returns\n"
    "-------\n"
    "fp\n"
    "    Integral ``F_+(x)``: ``integral(exp(1j*t*t), t=x..inf)``\n"
    "kp\n"
    "    Integral ``K_+(x)``: ``1/sqrt(pi)*exp(-1j*(x*x+pi/4))*fp``")
ufunc_modfresnelp_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_f_FF
ufunc_modfresnelp_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_DD_As_d_DD
ufunc_modfresnelp_types[0] = <char>NPY_FLOAT
ufunc_modfresnelp_types[1] = <char>NPY_CFLOAT
ufunc_modfresnelp_types[2] = <char>NPY_CFLOAT
ufunc_modfresnelp_types[3] = <char>NPY_DOUBLE
ufunc_modfresnelp_types[4] = <char>NPY_CDOUBLE
ufunc_modfresnelp_types[5] = <char>NPY_CDOUBLE
ufunc_modfresnelp_ptr[2*0] = <void*>_func_modified_fresnel_plus_wrap
ufunc_modfresnelp_ptr[2*0+1] = <void*>(<char*>"modfresnelp")
ufunc_modfresnelp_ptr[2*1] = <void*>_func_modified_fresnel_plus_wrap
ufunc_modfresnelp_ptr[2*1+1] = <void*>(<char*>"modfresnelp")
ufunc_modfresnelp_data[0] = &ufunc_modfresnelp_ptr[2*0]
ufunc_modfresnelp_data[1] = &ufunc_modfresnelp_ptr[2*1]
modfresnelp = np.PyUFunc_FromFuncAndData(ufunc_modfresnelp_loops, ufunc_modfresnelp_data, ufunc_modfresnelp_types, 2, 1, 2, 0, "modfresnelp", ufunc_modfresnelp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_modstruve_loops[2]
cdef void *ufunc_modstruve_ptr[4]
cdef void *ufunc_modstruve_data[2]
cdef char ufunc_modstruve_types[6]
cdef char *ufunc_modstruve_doc = (
    "modstruve(v, x)\n"
    "\n"
    "Modified Struve function.\n"
    "\n"
    "Return the value of the modified Struve function of order `v` at `x`.  The\n"
    "modified Struve function is defined as,\n"
    "\n"
    ".. math::\n"
    "    L_v(x) = -\\imath \\exp(-\\pi\\imath v/2) H_v(x),\n"
    "\n"
    "where :math:`H_v` is the Struve function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order of the modified Struve function (float).\n"
    "x : array_like\n"
    "    Argument of the Struve function (float; must be positive unless `v` is\n"
    "    an integer).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "L : ndarray\n"
    "    Value of the modified Struve function of order `v` at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Three methods discussed in [1]_ are used to evaluate the function:\n"
    "\n"
    "- power series\n"
    "- expansion in Bessel functions (if :math:`|z| < |v| + 20`)\n"
    "- asymptotic large-z expansion (if :math:`z \\geq 0.7v + 12`)\n"
    "\n"
    "Rounding errors are estimated based on the largest terms in the sums, and\n"
    "the result associated with the smallest error is returned.\n"
    "\n"
    "See also\n"
    "--------\n"
    "struve\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       http://dlmf.nist.gov/11")
ufunc_modstruve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_modstruve_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_modstruve_types[0] = <char>NPY_FLOAT
ufunc_modstruve_types[1] = <char>NPY_FLOAT
ufunc_modstruve_types[2] = <char>NPY_FLOAT
ufunc_modstruve_types[3] = <char>NPY_DOUBLE
ufunc_modstruve_types[4] = <char>NPY_DOUBLE
ufunc_modstruve_types[5] = <char>NPY_DOUBLE
ufunc_modstruve_ptr[2*0] = <void*>_func_struve_l
ufunc_modstruve_ptr[2*0+1] = <void*>(<char*>"modstruve")
ufunc_modstruve_ptr[2*1] = <void*>_func_struve_l
ufunc_modstruve_ptr[2*1+1] = <void*>(<char*>"modstruve")
ufunc_modstruve_data[0] = &ufunc_modstruve_ptr[2*0]
ufunc_modstruve_data[1] = &ufunc_modstruve_ptr[2*1]
modstruve = np.PyUFunc_FromFuncAndData(ufunc_modstruve_loops, ufunc_modstruve_data, ufunc_modstruve_types, 2, 2, 1, 0, "modstruve", ufunc_modstruve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtr_loops[3]
cdef void *ufunc_nbdtr_ptr[6]
cdef void *ufunc_nbdtr_data[3]
cdef char ufunc_nbdtr_types[12]
cdef char *ufunc_nbdtr_doc = (
    "nbdtr(k, n, p)\n"
    "\n"
    "Negative binomial cumulative distribution function.\n"
    "\n"
    "Returns the sum of the terms 0 through `k` of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=0}^k {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that `k` or fewer failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : ndarray\n"
    "    The probability of `k` or fewer failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "nbdtrc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtr}(k, n, p) = I_{p}(n, k + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_nbdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtr_types[0] = <char>NPY_LONG
ufunc_nbdtr_types[1] = <char>NPY_LONG
ufunc_nbdtr_types[2] = <char>NPY_DOUBLE
ufunc_nbdtr_types[3] = <char>NPY_DOUBLE
ufunc_nbdtr_types[4] = <char>NPY_FLOAT
ufunc_nbdtr_types[5] = <char>NPY_FLOAT
ufunc_nbdtr_types[6] = <char>NPY_FLOAT
ufunc_nbdtr_types[7] = <char>NPY_FLOAT
ufunc_nbdtr_types[8] = <char>NPY_DOUBLE
ufunc_nbdtr_types[9] = <char>NPY_DOUBLE
ufunc_nbdtr_types[10] = <char>NPY_DOUBLE
ufunc_nbdtr_types[11] = <char>NPY_DOUBLE
ufunc_nbdtr_ptr[2*0] = <void*>_func_nbdtr
ufunc_nbdtr_ptr[2*0+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*1] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*1+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_ptr[2*2] = <void*>_func_nbdtr_unsafe
ufunc_nbdtr_ptr[2*2+1] = <void*>(<char*>"nbdtr")
ufunc_nbdtr_data[0] = &ufunc_nbdtr_ptr[2*0]
ufunc_nbdtr_data[1] = &ufunc_nbdtr_ptr[2*1]
ufunc_nbdtr_data[2] = &ufunc_nbdtr_ptr[2*2]
nbdtr = np.PyUFunc_FromFuncAndData(ufunc_nbdtr_loops, ufunc_nbdtr_data, ufunc_nbdtr_types, 3, 3, 1, 0, "nbdtr", ufunc_nbdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrc_loops[3]
cdef void *ufunc_nbdtrc_ptr[6]
cdef void *ufunc_nbdtrc_data[3]
cdef char ufunc_nbdtrc_types[12]
cdef char *ufunc_nbdtrc_doc = (
    "nbdtrc(k, n, p)\n"
    "\n"
    "Negative binomial survival function.\n"
    "\n"
    "Returns the sum of the terms `k + 1` to infinity of the negative binomial\n"
    "distribution probability mass function,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    F = \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j.\n"
    "\n"
    "In a sequence of Bernoulli trials with individual success probabilities\n"
    "`p`, this is the probability that more than `k` failures precede the nth\n"
    "success.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "F : ndarray\n"
    "    The probability of `k + 1` or more failures before `n` successes in a\n"
    "    sequence of events with individual success probability `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "If floating point values are passed for `k` or `n`, they will be truncated\n"
    "to integers.\n"
    "\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{nbdtrc}(k, n, p) = I_{1 - p}(k + 1, n).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `nbdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_nbdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrc_types[0] = <char>NPY_LONG
ufunc_nbdtrc_types[1] = <char>NPY_LONG
ufunc_nbdtrc_types[2] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[3] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[4] = <char>NPY_FLOAT
ufunc_nbdtrc_types[5] = <char>NPY_FLOAT
ufunc_nbdtrc_types[6] = <char>NPY_FLOAT
ufunc_nbdtrc_types[7] = <char>NPY_FLOAT
ufunc_nbdtrc_types[8] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[9] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[10] = <char>NPY_DOUBLE
ufunc_nbdtrc_types[11] = <char>NPY_DOUBLE
ufunc_nbdtrc_ptr[2*0] = <void*>_func_nbdtrc
ufunc_nbdtrc_ptr[2*0+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*1] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*1+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_ptr[2*2] = <void*>_func_nbdtrc_unsafe
ufunc_nbdtrc_ptr[2*2+1] = <void*>(<char*>"nbdtrc")
ufunc_nbdtrc_data[0] = &ufunc_nbdtrc_ptr[2*0]
ufunc_nbdtrc_data[1] = &ufunc_nbdtrc_ptr[2*1]
ufunc_nbdtrc_data[2] = &ufunc_nbdtrc_ptr[2*2]
nbdtrc = np.PyUFunc_FromFuncAndData(ufunc_nbdtrc_loops, ufunc_nbdtrc_data, ufunc_nbdtrc_types, 3, 3, 1, 0, "nbdtrc", ufunc_nbdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtri_loops[3]
cdef void *ufunc_nbdtri_ptr[6]
cdef void *ufunc_nbdtri_data[3]
cdef char ufunc_nbdtri_types[12]
cdef char *ufunc_nbdtri_doc = (
    "nbdtri(k, n, y)\n"
    "\n"
    "Inverse of `nbdtr` vs `p`.\n"
    "\n"
    "Returns the inverse with respect to the parameter `p` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : ndarray\n"
    "    Probability of success in a single event (float) such that\n"
    "    `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `nbdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_nbdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_iid__As_lld_d
ufunc_nbdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtri_types[0] = <char>NPY_LONG
ufunc_nbdtri_types[1] = <char>NPY_LONG
ufunc_nbdtri_types[2] = <char>NPY_DOUBLE
ufunc_nbdtri_types[3] = <char>NPY_DOUBLE
ufunc_nbdtri_types[4] = <char>NPY_FLOAT
ufunc_nbdtri_types[5] = <char>NPY_FLOAT
ufunc_nbdtri_types[6] = <char>NPY_FLOAT
ufunc_nbdtri_types[7] = <char>NPY_FLOAT
ufunc_nbdtri_types[8] = <char>NPY_DOUBLE
ufunc_nbdtri_types[9] = <char>NPY_DOUBLE
ufunc_nbdtri_types[10] = <char>NPY_DOUBLE
ufunc_nbdtri_types[11] = <char>NPY_DOUBLE
ufunc_nbdtri_ptr[2*0] = <void*>_func_nbdtri
ufunc_nbdtri_ptr[2*0+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*1] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*1+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_ptr[2*2] = <void*>_func_nbdtri_unsafe
ufunc_nbdtri_ptr[2*2+1] = <void*>(<char*>"nbdtri")
ufunc_nbdtri_data[0] = &ufunc_nbdtri_ptr[2*0]
ufunc_nbdtri_data[1] = &ufunc_nbdtri_ptr[2*1]
ufunc_nbdtri_data[2] = &ufunc_nbdtri_ptr[2*2]
nbdtri = np.PyUFunc_FromFuncAndData(ufunc_nbdtri_loops, ufunc_nbdtri_data, ufunc_nbdtri_types, 3, 3, 1, 0, "nbdtri", ufunc_nbdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrik_loops[2]
cdef void *ufunc_nbdtrik_ptr[4]
cdef void *ufunc_nbdtrik_data[2]
cdef char ufunc_nbdtrik_types[8]
cdef char *ufunc_nbdtrik_doc = (
    "nbdtrik(y, n, p)\n"
    "\n"
    "Inverse of `nbdtr` vs `k`.\n"
    "\n"
    "Returns the inverse with respect to the parameter `k` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "n : array_like\n"
    "    The target number of successes (positive int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : ndarray\n"
    "    The maximum number of allowed failures such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrin : Inverse with respect to `n` of `nbdtr(k, n, p)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_nbdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrik_types[0] = <char>NPY_FLOAT
ufunc_nbdtrik_types[1] = <char>NPY_FLOAT
ufunc_nbdtrik_types[2] = <char>NPY_FLOAT
ufunc_nbdtrik_types[3] = <char>NPY_FLOAT
ufunc_nbdtrik_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrik_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrik_ptr[2*0] = <void*>_func_cdfnbn2_wrap
ufunc_nbdtrik_ptr[2*0+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_ptr[2*1] = <void*>_func_cdfnbn2_wrap
ufunc_nbdtrik_ptr[2*1+1] = <void*>(<char*>"nbdtrik")
ufunc_nbdtrik_data[0] = &ufunc_nbdtrik_ptr[2*0]
ufunc_nbdtrik_data[1] = &ufunc_nbdtrik_ptr[2*1]
nbdtrik = np.PyUFunc_FromFuncAndData(ufunc_nbdtrik_loops, ufunc_nbdtrik_data, ufunc_nbdtrik_types, 2, 3, 1, 0, "nbdtrik", ufunc_nbdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nbdtrin_loops[2]
cdef void *ufunc_nbdtrin_ptr[4]
cdef void *ufunc_nbdtrin_data[2]
cdef char ufunc_nbdtrin_types[8]
cdef char *ufunc_nbdtrin_doc = (
    "nbdtrin(k, y, p)\n"
    "\n"
    "Inverse of `nbdtr` vs `n`.\n"
    "\n"
    "Returns the inverse with respect to the parameter `n` of\n"
    "`y = nbdtr(k, n, p)`, the negative binomial cumulative distribution\n"
    "function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    The maximum number of allowed failures (nonnegative int).\n"
    "y : array_like\n"
    "    The probability of `k` or fewer failures before `n` successes (float).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : ndarray\n"
    "    The number of successes `n` such that `nbdtr(k, n, p) = y`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "nbdtr : Cumulative distribution function of the negative binomial.\n"
    "nbdtri : Inverse with respect to `p` of `nbdtr(k, n, p)`.\n"
    "nbdtrik : Inverse with respect to `k` of `nbdtr(k, n, p)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfnbn`.\n"
    "\n"
    "Formula 26.5.26 of [2]_,\n"
    "\n"
    ".. math::\n"
    "    \\sum_{j=k + 1}^\\infty {{n + j - 1}\\choose{j}} p^n (1 - p)^j = I_{1 - p}(k + 1, n),\n"
    "\n"
    "is used to reduce calculation of the cumulative distribution function to\n"
    "that of a regularized incomplete beta :math:`I`.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`.  The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.")
ufunc_nbdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nbdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nbdtrin_types[0] = <char>NPY_FLOAT
ufunc_nbdtrin_types[1] = <char>NPY_FLOAT
ufunc_nbdtrin_types[2] = <char>NPY_FLOAT
ufunc_nbdtrin_types[3] = <char>NPY_FLOAT
ufunc_nbdtrin_types[4] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[5] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[6] = <char>NPY_DOUBLE
ufunc_nbdtrin_types[7] = <char>NPY_DOUBLE
ufunc_nbdtrin_ptr[2*0] = <void*>_func_cdfnbn3_wrap
ufunc_nbdtrin_ptr[2*0+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_ptr[2*1] = <void*>_func_cdfnbn3_wrap
ufunc_nbdtrin_ptr[2*1+1] = <void*>(<char*>"nbdtrin")
ufunc_nbdtrin_data[0] = &ufunc_nbdtrin_ptr[2*0]
ufunc_nbdtrin_data[1] = &ufunc_nbdtrin_ptr[2*1]
nbdtrin = np.PyUFunc_FromFuncAndData(ufunc_nbdtrin_loops, ufunc_nbdtrin_data, ufunc_nbdtrin_types, 2, 3, 1, 0, "nbdtrin", ufunc_nbdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtr_loops[2]
cdef void *ufunc_ncfdtr_ptr[4]
cdef void *ufunc_ncfdtr_data[2]
cdef char ufunc_ncfdtr_types[10]
cdef char *ufunc_ncfdtr_doc = (
    "ncfdtr(dfn, dfd, nc, f)\n"
    "\n"
    "Cumulative distribution function of the non-central F distribution.\n"
    "\n"
    "The non-central F describes the distribution of,\n"
    "\n"
    ".. math::\n"
    "    Z = \\frac{X/d_n}{Y/d_d}\n"
    "\n"
    "where :math:`X` and :math:`Y` are independently distributed, with\n"
    ":math:`X` distributed non-central :math:`\\chi^2` with noncentrality\n"
    "parameter `nc` and :math:`d_n` degrees of freedom, and :math:`Y`\n"
    "distributed :math:`\\chi^2` with :math:`d_d` degrees of freedom.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "dfn : array_like\n"
    "    Degrees of freedom of the numerator sum of squares.  Range (0, inf).\n"
    "dfd : array_like\n"
    "    Degrees of freedom of the denominator sum of squares.  Range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (0, 1e4).\n"
    "f : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : float or ndarray\n"
    "    The calculated CDF.  If all inputs are scalar, the return will be a\n"
    "    float.  Otherwise it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "ncdfdtri : Inverse CDF (iCDF) of the non-central F distribution.\n"
    "ncdfdtridfd : Calculate dfd, given CDF and iCDF values.\n"
    "ncdfdtridfn : Calculate dfn, given CDF and iCDF values.\n"
    "ncdfdtrinc : Calculate noncentrality parameter, given CDF, iCDF, dfn, dfd.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdffnc`.\n"
    "\n"
    "The cumulative distribution function is computed using Formula 26.6.20 of\n"
    "[2]_:\n"
    "\n"
    ".. math::\n"
    "    F(d_n, d_d, n_c, f) = \\sum_{j=0}^\\infty e^{-n_c/2} \\frac{(n_c/2)^j}{j!} I_{x}(\\frac{d_n}{2} + j, \\frac{d_d}{2}),\n"
    "\n"
    "where :math:`I` is the regularized incomplete beta function, and\n"
    ":math:`x = f d_n/(f d_n + d_d)`.\n"
    "\n"
    "The computation time required for this routine is proportional to the\n"
    "noncentrality parameter `nc`.  Very large values of this parameter can\n"
    "consume immense computer resources.  This is why the search range is\n"
    "bounded by 10,000.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central F distribution, for nc=0.  Compare with the\n"
    "F-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-1, 8, num=500)\n"
    ">>> dfn = 3\n"
    ">>> dfd = 2\n"
    ">>> ncf_stats = stats.f.cdf(x, dfn, dfd)\n"
    ">>> ncf_special = special.ncfdtr(dfn, dfd, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, ncf_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, ncf_special, 'r-')\n"
    ">>> plt.show()")
ufunc_ncfdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtr_types[0] = <char>NPY_FLOAT
ufunc_ncfdtr_types[1] = <char>NPY_FLOAT
ufunc_ncfdtr_types[2] = <char>NPY_FLOAT
ufunc_ncfdtr_types[3] = <char>NPY_FLOAT
ufunc_ncfdtr_types[4] = <char>NPY_FLOAT
ufunc_ncfdtr_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtr_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtr_ptr[2*0] = <void*>_func_cdffnc1_wrap
ufunc_ncfdtr_ptr[2*0+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_ptr[2*1] = <void*>_func_cdffnc1_wrap
ufunc_ncfdtr_ptr[2*1+1] = <void*>(<char*>"ncfdtr")
ufunc_ncfdtr_data[0] = &ufunc_ncfdtr_ptr[2*0]
ufunc_ncfdtr_data[1] = &ufunc_ncfdtr_ptr[2*1]
ncfdtr = np.PyUFunc_FromFuncAndData(ufunc_ncfdtr_loops, ufunc_ncfdtr_data, ufunc_ncfdtr_types, 2, 4, 1, 0, "ncfdtr", ufunc_ncfdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtri_loops[2]
cdef void *ufunc_ncfdtri_ptr[4]
cdef void *ufunc_ncfdtri_data[2]
cdef char ufunc_ncfdtri_types[10]
cdef char *ufunc_ncfdtri_doc = (
    "ncfdtri(p, dfn, dfd, nc)\n"
    "\n"
    "Inverse cumulative distribution function of the non-central F distribution.\n"
    "\n"
    "See `ncfdtr` for more details.")
ufunc_ncfdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtri_types[0] = <char>NPY_FLOAT
ufunc_ncfdtri_types[1] = <char>NPY_FLOAT
ufunc_ncfdtri_types[2] = <char>NPY_FLOAT
ufunc_ncfdtri_types[3] = <char>NPY_FLOAT
ufunc_ncfdtri_types[4] = <char>NPY_FLOAT
ufunc_ncfdtri_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtri_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtri_ptr[2*0] = <void*>_func_cdffnc2_wrap
ufunc_ncfdtri_ptr[2*0+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_ptr[2*1] = <void*>_func_cdffnc2_wrap
ufunc_ncfdtri_ptr[2*1+1] = <void*>(<char*>"ncfdtri")
ufunc_ncfdtri_data[0] = &ufunc_ncfdtri_ptr[2*0]
ufunc_ncfdtri_data[1] = &ufunc_ncfdtri_ptr[2*1]
ncfdtri = np.PyUFunc_FromFuncAndData(ufunc_ncfdtri_loops, ufunc_ncfdtri_data, ufunc_ncfdtri_types, 2, 4, 1, 0, "ncfdtri", ufunc_ncfdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfd_loops[2]
cdef void *ufunc_ncfdtridfd_ptr[4]
cdef void *ufunc_ncfdtridfd_data[2]
cdef char ufunc_ncfdtridfd_types[10]
cdef char *ufunc_ncfdtridfd_doc = (
    "ncfdtridfd(p, f, dfn, nc)\n"
    "\n"
    "Calculate degrees of freedom (denominator) for the noncentral F-distribution.\n"
    "\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom.  There thus may be two values that\n"
    "provide a given CDF value.  This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.")
ufunc_ncfdtridfd_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfd_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfd_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfd_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfd_ptr[2*0] = <void*>_func_cdffnc4_wrap
ufunc_ncfdtridfd_ptr[2*0+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_ptr[2*1] = <void*>_func_cdffnc4_wrap
ufunc_ncfdtridfd_ptr[2*1+1] = <void*>(<char*>"ncfdtridfd")
ufunc_ncfdtridfd_data[0] = &ufunc_ncfdtridfd_ptr[2*0]
ufunc_ncfdtridfd_data[1] = &ufunc_ncfdtridfd_ptr[2*1]
ncfdtridfd = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfd_loops, ufunc_ncfdtridfd_data, ufunc_ncfdtridfd_types, 2, 4, 1, 0, "ncfdtridfd", ufunc_ncfdtridfd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtridfn_loops[2]
cdef void *ufunc_ncfdtridfn_ptr[4]
cdef void *ufunc_ncfdtridfn_data[2]
cdef char ufunc_ncfdtridfn_types[10]
cdef char *ufunc_ncfdtridfn_doc = (
    "ncfdtridfn(p, f, dfd, nc)\n"
    "\n"
    "Calculate degrees of freedom (numerator) for the noncentral F-distribution.\n"
    "\n"
    "See `ncfdtr` for more details.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of the cumulative noncentral F distribution is not necessarily\n"
    "monotone in either degrees of freedom.  There thus may be two values that\n"
    "provide a given CDF value.  This routine assumes monotonicity and will\n"
    "find an arbitrary one of the two values.")
ufunc_ncfdtridfn_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtridfn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtridfn_types[0] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[1] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[2] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[3] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[4] = <char>NPY_FLOAT
ufunc_ncfdtridfn_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtridfn_ptr[2*0] = <void*>_func_cdffnc3_wrap
ufunc_ncfdtridfn_ptr[2*0+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_ptr[2*1] = <void*>_func_cdffnc3_wrap
ufunc_ncfdtridfn_ptr[2*1+1] = <void*>(<char*>"ncfdtridfn")
ufunc_ncfdtridfn_data[0] = &ufunc_ncfdtridfn_ptr[2*0]
ufunc_ncfdtridfn_data[1] = &ufunc_ncfdtridfn_ptr[2*1]
ncfdtridfn = np.PyUFunc_FromFuncAndData(ufunc_ncfdtridfn_loops, ufunc_ncfdtridfn_data, ufunc_ncfdtridfn_types, 2, 4, 1, 0, "ncfdtridfn", ufunc_ncfdtridfn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ncfdtrinc_loops[2]
cdef void *ufunc_ncfdtrinc_ptr[4]
cdef void *ufunc_ncfdtrinc_data[2]
cdef char ufunc_ncfdtrinc_types[10]
cdef char *ufunc_ncfdtrinc_doc = (
    "ncfdtrinc(p, f, dfn, dfd)\n"
    "\n"
    "Calculate non-centrality parameter for non-central F distribution.\n"
    "\n"
    "See `ncfdtr` for more details.")
ufunc_ncfdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd__As_ffff_f
ufunc_ncfdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc_ncfdtrinc_types[0] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[1] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[2] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[3] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[4] = <char>NPY_FLOAT
ufunc_ncfdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[8] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_types[9] = <char>NPY_DOUBLE
ufunc_ncfdtrinc_ptr[2*0] = <void*>_func_cdffnc5_wrap
ufunc_ncfdtrinc_ptr[2*0+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_ptr[2*1] = <void*>_func_cdffnc5_wrap
ufunc_ncfdtrinc_ptr[2*1+1] = <void*>(<char*>"ncfdtrinc")
ufunc_ncfdtrinc_data[0] = &ufunc_ncfdtrinc_ptr[2*0]
ufunc_ncfdtrinc_data[1] = &ufunc_ncfdtrinc_ptr[2*1]
ncfdtrinc = np.PyUFunc_FromFuncAndData(ufunc_ncfdtrinc_loops, ufunc_ncfdtrinc_data, ufunc_ncfdtrinc_types, 2, 4, 1, 0, "ncfdtrinc", ufunc_ncfdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtr_loops[2]
cdef void *ufunc_nctdtr_ptr[4]
cdef void *ufunc_nctdtr_data[2]
cdef char ufunc_nctdtr_types[8]
cdef char *ufunc_nctdtr_doc = (
    "nctdtr(df, nc, t)\n"
    "\n"
    "Cumulative distribution function of the non-central `t` distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution.  Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (-1e6, 1e6).\n"
    "t : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "cdf : float or ndarray\n"
    "    The calculated CDF.  If all inputs are scalar, the return will be a\n"
    "    float.  Otherwise it will be an array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nctdtrit : Inverse CDF (iCDF) of the non-central t distribution.\n"
    "nctdtridf : Calculate degrees of freedom, given CDF and iCDF values.\n"
    "nctdtrinc : Calculate non-centrality parameter, given CDF iCDF values.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> from scipy import stats\n"
    ">>> import matplotlib.pyplot as plt\n"
    "\n"
    "Plot the CDF of the non-central t distribution, for nc=0.  Compare with the\n"
    "t-distribution from scipy.stats:\n"
    "\n"
    ">>> x = np.linspace(-5, 5, num=500)\n"
    ">>> df = 3\n"
    ">>> nct_stats = stats.t.cdf(x, df)\n"
    ">>> nct_special = special.nctdtr(df, 0, x)\n"
    "\n"
    ">>> fig = plt.figure()\n"
    ">>> ax = fig.add_subplot(111)\n"
    ">>> ax.plot(x, nct_stats, 'b-', lw=3)\n"
    ">>> ax.plot(x, nct_special, 'r-')\n"
    ">>> plt.show()")
ufunc_nctdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtr_types[0] = <char>NPY_FLOAT
ufunc_nctdtr_types[1] = <char>NPY_FLOAT
ufunc_nctdtr_types[2] = <char>NPY_FLOAT
ufunc_nctdtr_types[3] = <char>NPY_FLOAT
ufunc_nctdtr_types[4] = <char>NPY_DOUBLE
ufunc_nctdtr_types[5] = <char>NPY_DOUBLE
ufunc_nctdtr_types[6] = <char>NPY_DOUBLE
ufunc_nctdtr_types[7] = <char>NPY_DOUBLE
ufunc_nctdtr_ptr[2*0] = <void*>_func_cdftnc1_wrap
ufunc_nctdtr_ptr[2*0+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_ptr[2*1] = <void*>_func_cdftnc1_wrap
ufunc_nctdtr_ptr[2*1+1] = <void*>(<char*>"nctdtr")
ufunc_nctdtr_data[0] = &ufunc_nctdtr_ptr[2*0]
ufunc_nctdtr_data[1] = &ufunc_nctdtr_ptr[2*1]
nctdtr = np.PyUFunc_FromFuncAndData(ufunc_nctdtr_loops, ufunc_nctdtr_data, ufunc_nctdtr_types, 2, 3, 1, 0, "nctdtr", ufunc_nctdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtridf_loops[2]
cdef void *ufunc_nctdtridf_ptr[4]
cdef void *ufunc_nctdtridf_data[2]
cdef char ufunc_nctdtridf_types[8]
cdef char *ufunc_nctdtridf_doc = (
    "nctdtridf(p, nc, t)\n"
    "\n"
    "Calculate degrees of freedom for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (-1e6, 1e6).\n"
    "t : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.")
ufunc_nctdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtridf_types[0] = <char>NPY_FLOAT
ufunc_nctdtridf_types[1] = <char>NPY_FLOAT
ufunc_nctdtridf_types[2] = <char>NPY_FLOAT
ufunc_nctdtridf_types[3] = <char>NPY_FLOAT
ufunc_nctdtridf_types[4] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[5] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[6] = <char>NPY_DOUBLE
ufunc_nctdtridf_types[7] = <char>NPY_DOUBLE
ufunc_nctdtridf_ptr[2*0] = <void*>_func_cdftnc3_wrap
ufunc_nctdtridf_ptr[2*0+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_ptr[2*1] = <void*>_func_cdftnc3_wrap
ufunc_nctdtridf_ptr[2*1+1] = <void*>(<char*>"nctdtridf")
ufunc_nctdtridf_data[0] = &ufunc_nctdtridf_ptr[2*0]
ufunc_nctdtridf_data[1] = &ufunc_nctdtridf_ptr[2*1]
nctdtridf = np.PyUFunc_FromFuncAndData(ufunc_nctdtridf_loops, ufunc_nctdtridf_data, ufunc_nctdtridf_types, 2, 3, 1, 0, "nctdtridf", ufunc_nctdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrinc_loops[2]
cdef void *ufunc_nctdtrinc_ptr[4]
cdef void *ufunc_nctdtrinc_data[2]
cdef char ufunc_nctdtrinc_types[8]
cdef char *ufunc_nctdtrinc_doc = (
    "nctdtrinc(df, p, t)\n"
    "\n"
    "Calculate non-centrality parameter for non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution.  Should be in range (0, inf).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "t : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.")
ufunc_nctdtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrinc_types[0] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[1] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[2] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[3] = <char>NPY_FLOAT
ufunc_nctdtrinc_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrinc_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrinc_ptr[2*0] = <void*>_func_cdftnc4_wrap
ufunc_nctdtrinc_ptr[2*0+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_ptr[2*1] = <void*>_func_cdftnc4_wrap
ufunc_nctdtrinc_ptr[2*1+1] = <void*>(<char*>"nctdtrinc")
ufunc_nctdtrinc_data[0] = &ufunc_nctdtrinc_ptr[2*0]
ufunc_nctdtrinc_data[1] = &ufunc_nctdtrinc_ptr[2*1]
nctdtrinc = np.PyUFunc_FromFuncAndData(ufunc_nctdtrinc_loops, ufunc_nctdtrinc_data, ufunc_nctdtrinc_types, 2, 3, 1, 0, "nctdtrinc", ufunc_nctdtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nctdtrit_loops[2]
cdef void *ufunc_nctdtrit_ptr[4]
cdef void *ufunc_nctdtrit_data[2]
cdef char ufunc_nctdtrit_types[8]
cdef char *ufunc_nctdtrit_doc = (
    "nctdtrit(df, nc, p)\n"
    "\n"
    "Inverse cumulative distribution function of the non-central t distribution.\n"
    "\n"
    "See `nctdtr` for more details.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "df : array_like\n"
    "    Degrees of freedom of the distribution.  Should be in range (0, inf).\n"
    "nc : array_like\n"
    "    Noncentrality parameter.  Should be in range (-1e6, 1e6).\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].")
ufunc_nctdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nctdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nctdtrit_types[0] = <char>NPY_FLOAT
ufunc_nctdtrit_types[1] = <char>NPY_FLOAT
ufunc_nctdtrit_types[2] = <char>NPY_FLOAT
ufunc_nctdtrit_types[3] = <char>NPY_FLOAT
ufunc_nctdtrit_types[4] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[5] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[6] = <char>NPY_DOUBLE
ufunc_nctdtrit_types[7] = <char>NPY_DOUBLE
ufunc_nctdtrit_ptr[2*0] = <void*>_func_cdftnc2_wrap
ufunc_nctdtrit_ptr[2*0+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_ptr[2*1] = <void*>_func_cdftnc2_wrap
ufunc_nctdtrit_ptr[2*1+1] = <void*>(<char*>"nctdtrit")
ufunc_nctdtrit_data[0] = &ufunc_nctdtrit_ptr[2*0]
ufunc_nctdtrit_data[1] = &ufunc_nctdtrit_ptr[2*1]
nctdtrit = np.PyUFunc_FromFuncAndData(ufunc_nctdtrit_loops, ufunc_nctdtrit_data, ufunc_nctdtrit_types, 2, 3, 1, 0, "nctdtrit", ufunc_nctdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtr_loops[4]
cdef void *ufunc_ndtr_ptr[8]
cdef void *ufunc_ndtr_data[4]
cdef char ufunc_ndtr_types[8]
cdef char *ufunc_ndtr_doc = (
    "ndtr(x)\n"
    "\n"
    "Gaussian cumulative distribution function.\n"
    "\n"
    "Returns the area under the standard Gaussian probability\n"
    "density function, integrated from minus infinity to `x`\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^x \\exp(-t^2/2) dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like, real or complex\n"
    "    Argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "ndarray\n"
    "    The value of the normal CDF evaluated at `x`\n"
    "\n"
    "See Also\n"
    "--------\n"
    "erf\n"
    "erfc\n"
    "scipy.stats.norm\n"
    "log_ndtr")
ufunc_ndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtr_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_ndtr_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_ndtr_types[0] = <char>NPY_FLOAT
ufunc_ndtr_types[1] = <char>NPY_FLOAT
ufunc_ndtr_types[2] = <char>NPY_DOUBLE
ufunc_ndtr_types[3] = <char>NPY_DOUBLE
ufunc_ndtr_types[4] = <char>NPY_CFLOAT
ufunc_ndtr_types[5] = <char>NPY_CFLOAT
ufunc_ndtr_types[6] = <char>NPY_CDOUBLE
ufunc_ndtr_types[7] = <char>NPY_CDOUBLE
ufunc_ndtr_ptr[2*0] = <void*>_func_ndtr
ufunc_ndtr_ptr[2*0+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*1] = <void*>_func_ndtr
ufunc_ndtr_ptr[2*1+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*2+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_ndtr
ufunc_ndtr_ptr[2*3+1] = <void*>(<char*>"ndtr")
ufunc_ndtr_data[0] = &ufunc_ndtr_ptr[2*0]
ufunc_ndtr_data[1] = &ufunc_ndtr_ptr[2*1]
ufunc_ndtr_data[2] = &ufunc_ndtr_ptr[2*2]
ufunc_ndtr_data[3] = &ufunc_ndtr_ptr[2*3]
ndtr = np.PyUFunc_FromFuncAndData(ufunc_ndtr_loops, ufunc_ndtr_data, ufunc_ndtr_types, 4, 1, 1, 0, "ndtr", ufunc_ndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_ndtri_loops[2]
cdef void *ufunc_ndtri_ptr[4]
cdef void *ufunc_ndtri_data[2]
cdef char ufunc_ndtri_types[4]
cdef char *ufunc_ndtri_doc = (
    "ndtri(y)\n"
    "\n"
    "Inverse of `ndtr` vs x\n"
    "\n"
    "Returns the argument x for which the area under the Gaussian\n"
    "probability density function (integrated from minus infinity to `x`)\n"
    "is equal to y.")
ufunc_ndtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_ndtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_ndtri_types[0] = <char>NPY_FLOAT
ufunc_ndtri_types[1] = <char>NPY_FLOAT
ufunc_ndtri_types[2] = <char>NPY_DOUBLE
ufunc_ndtri_types[3] = <char>NPY_DOUBLE
ufunc_ndtri_ptr[2*0] = <void*>_func_ndtri
ufunc_ndtri_ptr[2*0+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_ptr[2*1] = <void*>_func_ndtri
ufunc_ndtri_ptr[2*1+1] = <void*>(<char*>"ndtri")
ufunc_ndtri_data[0] = &ufunc_ndtri_ptr[2*0]
ufunc_ndtri_data[1] = &ufunc_ndtri_ptr[2*1]
ndtri = np.PyUFunc_FromFuncAndData(ufunc_ndtri_loops, ufunc_ndtri_data, ufunc_ndtri_types, 2, 1, 1, 0, "ndtri", ufunc_ndtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrimn_loops[2]
cdef void *ufunc_nrdtrimn_ptr[4]
cdef void *ufunc_nrdtrimn_data[2]
cdef char ufunc_nrdtrimn_types[8]
cdef char *ufunc_nrdtrimn_doc = (
    "nrdtrimn(p, x, std)\n"
    "\n"
    "Calculate mean of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "std : array_like\n"
    "    Standard deviation.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "mn : float or ndarray\n"
    "    The mean of the normal distribution.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nrdtrimn, ndtr")
ufunc_nrdtrimn_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrimn_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrimn_types[0] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[1] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[2] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[3] = <char>NPY_FLOAT
ufunc_nrdtrimn_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrimn_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrimn_ptr[2*0] = <void*>_func_cdfnor3_wrap
ufunc_nrdtrimn_ptr[2*0+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_ptr[2*1] = <void*>_func_cdfnor3_wrap
ufunc_nrdtrimn_ptr[2*1+1] = <void*>(<char*>"nrdtrimn")
ufunc_nrdtrimn_data[0] = &ufunc_nrdtrimn_ptr[2*0]
ufunc_nrdtrimn_data[1] = &ufunc_nrdtrimn_ptr[2*1]
nrdtrimn = np.PyUFunc_FromFuncAndData(ufunc_nrdtrimn_loops, ufunc_nrdtrimn_data, ufunc_nrdtrimn_types, 2, 3, 1, 0, "nrdtrimn", ufunc_nrdtrimn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_nrdtrisd_loops[2]
cdef void *ufunc_nrdtrisd_ptr[4]
cdef void *ufunc_nrdtrisd_data[2]
cdef char ufunc_nrdtrisd_types[8]
cdef char *ufunc_nrdtrisd_doc = (
    "nrdtrisd(p, x, mn)\n"
    "\n"
    "Calculate standard deviation of normal distribution given other params.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    CDF values, in range (0, 1].\n"
    "x : array_like\n"
    "    Quantiles, i.e. the upper limit of integration.\n"
    "mn : float or ndarray\n"
    "    The mean of the normal distribution.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "std : array_like\n"
    "    Standard deviation.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "nrdtristd, ndtr")
ufunc_nrdtrisd_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_nrdtrisd_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_nrdtrisd_types[0] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[1] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[2] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[3] = <char>NPY_FLOAT
ufunc_nrdtrisd_types[4] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[5] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[6] = <char>NPY_DOUBLE
ufunc_nrdtrisd_types[7] = <char>NPY_DOUBLE
ufunc_nrdtrisd_ptr[2*0] = <void*>_func_cdfnor4_wrap
ufunc_nrdtrisd_ptr[2*0+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_ptr[2*1] = <void*>_func_cdfnor4_wrap
ufunc_nrdtrisd_ptr[2*1+1] = <void*>(<char*>"nrdtrisd")
ufunc_nrdtrisd_data[0] = &ufunc_nrdtrisd_ptr[2*0]
ufunc_nrdtrisd_data[1] = &ufunc_nrdtrisd_ptr[2*1]
nrdtrisd = np.PyUFunc_FromFuncAndData(ufunc_nrdtrisd_loops, ufunc_nrdtrisd_data, ufunc_nrdtrisd_types, 2, 3, 1, 0, "nrdtrisd", ufunc_nrdtrisd_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_ang1_loops[2]
cdef void *ufunc_obl_ang1_ptr[4]
cdef void *ufunc_obl_ang1_data[2]
cdef char ufunc_obl_ang1_types[12]
cdef char *ufunc_obl_ang1_doc = (
    "obl_ang1(m, n, c, x)\n"
    "\n"
    "Oblate spheroidal angular function of the first kind and its derivative\n"
    "\n"
    "Computes the oblate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_ang1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_ang1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_ang1_types[0] = <char>NPY_FLOAT
ufunc_obl_ang1_types[1] = <char>NPY_FLOAT
ufunc_obl_ang1_types[2] = <char>NPY_FLOAT
ufunc_obl_ang1_types[3] = <char>NPY_FLOAT
ufunc_obl_ang1_types[4] = <char>NPY_FLOAT
ufunc_obl_ang1_types[5] = <char>NPY_FLOAT
ufunc_obl_ang1_types[6] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[7] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[8] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[9] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[10] = <char>NPY_DOUBLE
ufunc_obl_ang1_types[11] = <char>NPY_DOUBLE
ufunc_obl_ang1_ptr[2*0] = <void*>_func_oblate_aswfa_nocv_wrap
ufunc_obl_ang1_ptr[2*0+1] = <void*>(<char*>"obl_ang1")
ufunc_obl_ang1_ptr[2*1] = <void*>_func_oblate_aswfa_nocv_wrap
ufunc_obl_ang1_ptr[2*1+1] = <void*>(<char*>"obl_ang1")
ufunc_obl_ang1_data[0] = &ufunc_obl_ang1_ptr[2*0]
ufunc_obl_ang1_data[1] = &ufunc_obl_ang1_ptr[2*1]
obl_ang1 = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_loops, ufunc_obl_ang1_data, ufunc_obl_ang1_types, 2, 4, 2, 0, "obl_ang1", ufunc_obl_ang1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_ang1_cv_loops[2]
cdef void *ufunc_obl_ang1_cv_ptr[4]
cdef void *ufunc_obl_ang1_cv_data[2]
cdef char ufunc_obl_ang1_cv_types[14]
cdef char *ufunc_obl_ang1_cv_doc = (
    "obl_ang1_cv(m, n, c, cv, x)\n"
    "\n"
    "Oblate spheroidal angular function obl_ang1 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_ang1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_ang1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_ang1_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_ang1_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_ang1_cv_ptr[2*0] = <void*>_func_oblate_aswfa_wrap
ufunc_obl_ang1_cv_ptr[2*0+1] = <void*>(<char*>"obl_ang1_cv")
ufunc_obl_ang1_cv_ptr[2*1] = <void*>_func_oblate_aswfa_wrap
ufunc_obl_ang1_cv_ptr[2*1+1] = <void*>(<char*>"obl_ang1_cv")
ufunc_obl_ang1_cv_data[0] = &ufunc_obl_ang1_cv_ptr[2*0]
ufunc_obl_ang1_cv_data[1] = &ufunc_obl_ang1_cv_ptr[2*1]
obl_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_ang1_cv_loops, ufunc_obl_ang1_cv_data, ufunc_obl_ang1_cv_types, 2, 5, 2, 0, "obl_ang1_cv", ufunc_obl_ang1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_cv_loops[2]
cdef void *ufunc_obl_cv_ptr[4]
cdef void *ufunc_obl_cv_data[2]
cdef char ufunc_obl_cv_types[8]
cdef char *ufunc_obl_cv_doc = (
    "obl_cv(m, n, c)\n"
    "\n"
    "Characteristic value of oblate spheroidal function\n"
    "\n"
    "Computes the characteristic value of oblate spheroidal wave\n"
    "functions of order `m`, `n` (n>=m) and spheroidal parameter `c`.")
ufunc_obl_cv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_obl_cv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_obl_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_cv_types[4] = <char>NPY_DOUBLE
ufunc_obl_cv_types[5] = <char>NPY_DOUBLE
ufunc_obl_cv_types[6] = <char>NPY_DOUBLE
ufunc_obl_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_cv_ptr[2*0] = <void*>_func_oblate_segv_wrap
ufunc_obl_cv_ptr[2*0+1] = <void*>(<char*>"obl_cv")
ufunc_obl_cv_ptr[2*1] = <void*>_func_oblate_segv_wrap
ufunc_obl_cv_ptr[2*1+1] = <void*>(<char*>"obl_cv")
ufunc_obl_cv_data[0] = &ufunc_obl_cv_ptr[2*0]
ufunc_obl_cv_data[1] = &ufunc_obl_cv_ptr[2*1]
obl_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_cv_loops, ufunc_obl_cv_data, ufunc_obl_cv_types, 2, 3, 1, 0, "obl_cv", ufunc_obl_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad1_loops[2]
cdef void *ufunc_obl_rad1_ptr[4]
cdef void *ufunc_obl_rad1_data[2]
cdef char ufunc_obl_rad1_types[12]
cdef char *ufunc_obl_rad1_doc = (
    "obl_rad1(m, n, c, x)\n"
    "\n"
    "Oblate spheroidal radial function of the first kind and its derivative\n"
    "\n"
    "Computes the oblate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_rad1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_rad1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_rad1_types[0] = <char>NPY_FLOAT
ufunc_obl_rad1_types[1] = <char>NPY_FLOAT
ufunc_obl_rad1_types[2] = <char>NPY_FLOAT
ufunc_obl_rad1_types[3] = <char>NPY_FLOAT
ufunc_obl_rad1_types[4] = <char>NPY_FLOAT
ufunc_obl_rad1_types[5] = <char>NPY_FLOAT
ufunc_obl_rad1_types[6] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad1_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad1_ptr[2*0] = <void*>_func_oblate_radial1_nocv_wrap
ufunc_obl_rad1_ptr[2*0+1] = <void*>(<char*>"obl_rad1")
ufunc_obl_rad1_ptr[2*1] = <void*>_func_oblate_radial1_nocv_wrap
ufunc_obl_rad1_ptr[2*1+1] = <void*>(<char*>"obl_rad1")
ufunc_obl_rad1_data[0] = &ufunc_obl_rad1_ptr[2*0]
ufunc_obl_rad1_data[1] = &ufunc_obl_rad1_ptr[2*1]
obl_rad1 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_loops, ufunc_obl_rad1_data, ufunc_obl_rad1_types, 2, 4, 2, 0, "obl_rad1", ufunc_obl_rad1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad1_cv_loops[2]
cdef void *ufunc_obl_rad1_cv_ptr[4]
cdef void *ufunc_obl_rad1_cv_data[2]
cdef char ufunc_obl_rad1_cv_types[14]
cdef char *ufunc_obl_rad1_cv_doc = (
    "obl_rad1_cv(m, n, c, cv, x)\n"
    "\n"
    "Oblate spheroidal radial function obl_rad1 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_rad1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_rad1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_rad1_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_rad1_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_rad1_cv_ptr[2*0] = <void*>_func_oblate_radial1_wrap
ufunc_obl_rad1_cv_ptr[2*0+1] = <void*>(<char*>"obl_rad1_cv")
ufunc_obl_rad1_cv_ptr[2*1] = <void*>_func_oblate_radial1_wrap
ufunc_obl_rad1_cv_ptr[2*1+1] = <void*>(<char*>"obl_rad1_cv")
ufunc_obl_rad1_cv_data[0] = &ufunc_obl_rad1_cv_ptr[2*0]
ufunc_obl_rad1_cv_data[1] = &ufunc_obl_rad1_cv_ptr[2*1]
obl_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad1_cv_loops, ufunc_obl_rad1_cv_data, ufunc_obl_rad1_cv_types, 2, 5, 2, 0, "obl_rad1_cv", ufunc_obl_rad1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad2_loops[2]
cdef void *ufunc_obl_rad2_ptr[4]
cdef void *ufunc_obl_rad2_data[2]
cdef char ufunc_obl_rad2_types[12]
cdef char *ufunc_obl_rad2_doc = (
    "obl_rad2(m, n, c, x)\n"
    "\n"
    "Oblate spheroidal radial function of the second kind and its derivative.\n"
    "\n"
    "Computes the oblate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_rad2_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_obl_rad2_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_obl_rad2_types[0] = <char>NPY_FLOAT
ufunc_obl_rad2_types[1] = <char>NPY_FLOAT
ufunc_obl_rad2_types[2] = <char>NPY_FLOAT
ufunc_obl_rad2_types[3] = <char>NPY_FLOAT
ufunc_obl_rad2_types[4] = <char>NPY_FLOAT
ufunc_obl_rad2_types[5] = <char>NPY_FLOAT
ufunc_obl_rad2_types[6] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad2_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad2_ptr[2*0] = <void*>_func_oblate_radial2_nocv_wrap
ufunc_obl_rad2_ptr[2*0+1] = <void*>(<char*>"obl_rad2")
ufunc_obl_rad2_ptr[2*1] = <void*>_func_oblate_radial2_nocv_wrap
ufunc_obl_rad2_ptr[2*1+1] = <void*>(<char*>"obl_rad2")
ufunc_obl_rad2_data[0] = &ufunc_obl_rad2_ptr[2*0]
ufunc_obl_rad2_data[1] = &ufunc_obl_rad2_ptr[2*1]
obl_rad2 = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_loops, ufunc_obl_rad2_data, ufunc_obl_rad2_types, 2, 4, 2, 0, "obl_rad2", ufunc_obl_rad2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_obl_rad2_cv_loops[2]
cdef void *ufunc_obl_rad2_cv_ptr[4]
cdef void *ufunc_obl_rad2_cv_data[2]
cdef char ufunc_obl_rad2_cv_types[14]
cdef char *ufunc_obl_rad2_cv_doc = (
    "obl_rad2_cv(m, n, c, cv, x)\n"
    "\n"
    "Oblate spheroidal radial function obl_rad2 for precomputed characteristic value\n"
    "\n"
    "Computes the oblate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_obl_rad2_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_obl_rad2_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_obl_rad2_cv_types[0] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[1] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[2] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[3] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[4] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[5] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[6] = <char>NPY_FLOAT
ufunc_obl_rad2_cv_types[7] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[8] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[9] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[10] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[11] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[12] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_types[13] = <char>NPY_DOUBLE
ufunc_obl_rad2_cv_ptr[2*0] = <void*>_func_oblate_radial2_wrap
ufunc_obl_rad2_cv_ptr[2*0+1] = <void*>(<char*>"obl_rad2_cv")
ufunc_obl_rad2_cv_ptr[2*1] = <void*>_func_oblate_radial2_wrap
ufunc_obl_rad2_cv_ptr[2*1+1] = <void*>(<char*>"obl_rad2_cv")
ufunc_obl_rad2_cv_data[0] = &ufunc_obl_rad2_cv_ptr[2*0]
ufunc_obl_rad2_cv_data[1] = &ufunc_obl_rad2_cv_ptr[2*1]
obl_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_obl_rad2_cv_loops, ufunc_obl_rad2_cv_data, ufunc_obl_rad2_cv_types, 2, 5, 2, 0, "obl_rad2_cv", ufunc_obl_rad2_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbdv_loops[2]
cdef void *ufunc_pbdv_ptr[4]
cdef void *ufunc_pbdv_data[2]
cdef char ufunc_pbdv_types[8]
cdef char *ufunc_pbdv_doc = (
    "pbdv(v, x)\n"
    "\n"
    "Parabolic cylinder function D\n"
    "\n"
    "Returns (d, dp) the parabolic cylinder function Dv(x) in d and the\n"
    "derivative, Dv'(x) in dp.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "d\n"
    "    Value of the function\n"
    "dp\n"
    "    Value of the derivative vs x")
ufunc_pbdv_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbdv_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbdv_types[0] = <char>NPY_FLOAT
ufunc_pbdv_types[1] = <char>NPY_FLOAT
ufunc_pbdv_types[2] = <char>NPY_FLOAT
ufunc_pbdv_types[3] = <char>NPY_FLOAT
ufunc_pbdv_types[4] = <char>NPY_DOUBLE
ufunc_pbdv_types[5] = <char>NPY_DOUBLE
ufunc_pbdv_types[6] = <char>NPY_DOUBLE
ufunc_pbdv_types[7] = <char>NPY_DOUBLE
ufunc_pbdv_ptr[2*0] = <void*>_func_pbdv_wrap
ufunc_pbdv_ptr[2*0+1] = <void*>(<char*>"pbdv")
ufunc_pbdv_ptr[2*1] = <void*>_func_pbdv_wrap
ufunc_pbdv_ptr[2*1+1] = <void*>(<char*>"pbdv")
ufunc_pbdv_data[0] = &ufunc_pbdv_ptr[2*0]
ufunc_pbdv_data[1] = &ufunc_pbdv_ptr[2*1]
pbdv = np.PyUFunc_FromFuncAndData(ufunc_pbdv_loops, ufunc_pbdv_data, ufunc_pbdv_types, 2, 2, 2, 0, "pbdv", ufunc_pbdv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbvv_loops[2]
cdef void *ufunc_pbvv_ptr[4]
cdef void *ufunc_pbvv_data[2]
cdef char ufunc_pbvv_types[8]
cdef char *ufunc_pbvv_doc = (
    "pbvv(v, x)\n"
    "\n"
    "Parabolic cylinder function V\n"
    "\n"
    "Returns the parabolic cylinder function Vv(x) in v and the\n"
    "derivative, Vv'(x) in vp.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v\n"
    "    Value of the function\n"
    "vp\n"
    "    Value of the derivative vs x")
ufunc_pbvv_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbvv_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbvv_types[0] = <char>NPY_FLOAT
ufunc_pbvv_types[1] = <char>NPY_FLOAT
ufunc_pbvv_types[2] = <char>NPY_FLOAT
ufunc_pbvv_types[3] = <char>NPY_FLOAT
ufunc_pbvv_types[4] = <char>NPY_DOUBLE
ufunc_pbvv_types[5] = <char>NPY_DOUBLE
ufunc_pbvv_types[6] = <char>NPY_DOUBLE
ufunc_pbvv_types[7] = <char>NPY_DOUBLE
ufunc_pbvv_ptr[2*0] = <void*>_func_pbvv_wrap
ufunc_pbvv_ptr[2*0+1] = <void*>(<char*>"pbvv")
ufunc_pbvv_ptr[2*1] = <void*>_func_pbvv_wrap
ufunc_pbvv_ptr[2*1+1] = <void*>(<char*>"pbvv")
ufunc_pbvv_data[0] = &ufunc_pbvv_ptr[2*0]
ufunc_pbvv_data[1] = &ufunc_pbvv_ptr[2*1]
pbvv = np.PyUFunc_FromFuncAndData(ufunc_pbvv_loops, ufunc_pbvv_data, ufunc_pbvv_types, 2, 2, 2, 0, "pbvv", ufunc_pbvv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pbwa_loops[2]
cdef void *ufunc_pbwa_ptr[4]
cdef void *ufunc_pbwa_data[2]
cdef char ufunc_pbwa_types[8]
cdef char *ufunc_pbwa_doc = (
    "pbwa(a, x)\n"
    "\n"
    "Parabolic cylinder function W.\n"
    "\n"
    "The function is a particular solution to the differential equation\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y'' + \\left(\\frac{1}{4}x^2 - a\\right)y = 0,\n"
    "\n"
    "for a full definition see section 12.14 in [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Real parameter\n"
    "x : array_like\n"
    "    Real argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "w : scalar or ndarray\n"
    "    Value of the function\n"
    "wp : scalar or ndarray\n"
    "    Value of the derivative in x\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The function is a wrapper for a Fortran routine by Zhang and Jin\n"
    "[2]_. The implementation is accurate only for ``|a|, |x| < 5`` and\n"
    "returns NaN outside that range.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 14.30.\n"
    "       http://dlmf.nist.gov/14.30\n"
    ".. [2] Zhang, Shanjie and Jin, Jianming. \"Computation of Special\n"
    "       Functions\", John Wiley and Sons, 1996.\n"
    "       http://jin.ece.illinois.edu/specfunc.html")
ufunc_pbwa_loops[0] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_ff_ff
ufunc_pbwa_loops[1] = <np.PyUFuncGenericFunction>loop_i_dd_dd_As_dd_dd
ufunc_pbwa_types[0] = <char>NPY_FLOAT
ufunc_pbwa_types[1] = <char>NPY_FLOAT
ufunc_pbwa_types[2] = <char>NPY_FLOAT
ufunc_pbwa_types[3] = <char>NPY_FLOAT
ufunc_pbwa_types[4] = <char>NPY_DOUBLE
ufunc_pbwa_types[5] = <char>NPY_DOUBLE
ufunc_pbwa_types[6] = <char>NPY_DOUBLE
ufunc_pbwa_types[7] = <char>NPY_DOUBLE
ufunc_pbwa_ptr[2*0] = <void*>_func_pbwa_wrap
ufunc_pbwa_ptr[2*0+1] = <void*>(<char*>"pbwa")
ufunc_pbwa_ptr[2*1] = <void*>_func_pbwa_wrap
ufunc_pbwa_ptr[2*1+1] = <void*>(<char*>"pbwa")
ufunc_pbwa_data[0] = &ufunc_pbwa_ptr[2*0]
ufunc_pbwa_data[1] = &ufunc_pbwa_ptr[2*1]
pbwa = np.PyUFunc_FromFuncAndData(ufunc_pbwa_loops, ufunc_pbwa_data, ufunc_pbwa_types, 2, 2, 2, 0, "pbwa", ufunc_pbwa_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtr_loops[3]
cdef void *ufunc_pdtr_ptr[6]
cdef void *ufunc_pdtr_data[3]
cdef char ufunc_pdtr_types[9]
cdef char *ufunc_pdtr_doc = (
    "pdtr(k, m)\n"
    "\n"
    "Poisson cumulative distribution function\n"
    "\n"
    "Returns the sum of the first `k` terms of the Poisson distribution:\n"
    "sum(exp(-m) * m**j / j!, j=0..k) = gammaincc( k+1, m).  Arguments\n"
    "must both be positive and `k` an integer.")
ufunc_pdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_pdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtr_types[0] = <char>NPY_LONG
ufunc_pdtr_types[1] = <char>NPY_DOUBLE
ufunc_pdtr_types[2] = <char>NPY_DOUBLE
ufunc_pdtr_types[3] = <char>NPY_FLOAT
ufunc_pdtr_types[4] = <char>NPY_FLOAT
ufunc_pdtr_types[5] = <char>NPY_FLOAT
ufunc_pdtr_types[6] = <char>NPY_DOUBLE
ufunc_pdtr_types[7] = <char>NPY_DOUBLE
ufunc_pdtr_types[8] = <char>NPY_DOUBLE
ufunc_pdtr_ptr[2*0] = <void*>_func_pdtr
ufunc_pdtr_ptr[2*0+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_ptr[2*1] = <void*>_func_pdtr_unsafe
ufunc_pdtr_ptr[2*1+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_ptr[2*2] = <void*>_func_pdtr_unsafe
ufunc_pdtr_ptr[2*2+1] = <void*>(<char*>"pdtr")
ufunc_pdtr_data[0] = &ufunc_pdtr_ptr[2*0]
ufunc_pdtr_data[1] = &ufunc_pdtr_ptr[2*1]
ufunc_pdtr_data[2] = &ufunc_pdtr_ptr[2*2]
pdtr = np.PyUFunc_FromFuncAndData(ufunc_pdtr_loops, ufunc_pdtr_data, ufunc_pdtr_types, 3, 2, 1, 0, "pdtr", ufunc_pdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrc_loops[3]
cdef void *ufunc_pdtrc_ptr[6]
cdef void *ufunc_pdtrc_data[3]
cdef char ufunc_pdtrc_types[9]
cdef char *ufunc_pdtrc_doc = (
    "pdtrc(k, m)\n"
    "\n"
    "Poisson survival function\n"
    "\n"
    "Returns the sum of the terms from k+1 to infinity of the Poisson\n"
    "distribution: sum(exp(-m) * m**j / j!, j=k+1..inf) = gammainc(\n"
    "k+1, m).  Arguments must both be positive and `k` an integer.")
ufunc_pdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_pdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrc_types[0] = <char>NPY_LONG
ufunc_pdtrc_types[1] = <char>NPY_DOUBLE
ufunc_pdtrc_types[2] = <char>NPY_DOUBLE
ufunc_pdtrc_types[3] = <char>NPY_FLOAT
ufunc_pdtrc_types[4] = <char>NPY_FLOAT
ufunc_pdtrc_types[5] = <char>NPY_FLOAT
ufunc_pdtrc_types[6] = <char>NPY_DOUBLE
ufunc_pdtrc_types[7] = <char>NPY_DOUBLE
ufunc_pdtrc_types[8] = <char>NPY_DOUBLE
ufunc_pdtrc_ptr[2*0] = <void*>_func_pdtrc
ufunc_pdtrc_ptr[2*0+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_ptr[2*1] = <void*>_func_pdtrc_unsafe
ufunc_pdtrc_ptr[2*1+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_ptr[2*2] = <void*>_func_pdtrc_unsafe
ufunc_pdtrc_ptr[2*2+1] = <void*>(<char*>"pdtrc")
ufunc_pdtrc_data[0] = &ufunc_pdtrc_ptr[2*0]
ufunc_pdtrc_data[1] = &ufunc_pdtrc_ptr[2*1]
ufunc_pdtrc_data[2] = &ufunc_pdtrc_ptr[2*2]
pdtrc = np.PyUFunc_FromFuncAndData(ufunc_pdtrc_loops, ufunc_pdtrc_data, ufunc_pdtrc_types, 3, 2, 1, 0, "pdtrc", ufunc_pdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtri_loops[3]
cdef void *ufunc_pdtri_ptr[6]
cdef void *ufunc_pdtri_data[3]
cdef char ufunc_pdtri_types[9]
cdef char *ufunc_pdtri_doc = (
    "pdtri(k, y)\n"
    "\n"
    "Inverse to `pdtr` vs m\n"
    "\n"
    "Returns the Poisson variable `m` such that the sum from 0 to `k` of\n"
    "the Poisson density is equal to the given probability `y`:\n"
    "calculated by gammaincinv(k+1, y). `k` must be a nonnegative\n"
    "integer and `y` between 0 and 1.")
ufunc_pdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_pdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtri_types[0] = <char>NPY_LONG
ufunc_pdtri_types[1] = <char>NPY_DOUBLE
ufunc_pdtri_types[2] = <char>NPY_DOUBLE
ufunc_pdtri_types[3] = <char>NPY_FLOAT
ufunc_pdtri_types[4] = <char>NPY_FLOAT
ufunc_pdtri_types[5] = <char>NPY_FLOAT
ufunc_pdtri_types[6] = <char>NPY_DOUBLE
ufunc_pdtri_types[7] = <char>NPY_DOUBLE
ufunc_pdtri_types[8] = <char>NPY_DOUBLE
ufunc_pdtri_ptr[2*0] = <void*>_func_pdtri
ufunc_pdtri_ptr[2*0+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*1] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*1+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_ptr[2*2] = <void*>_func_pdtri_unsafe
ufunc_pdtri_ptr[2*2+1] = <void*>(<char*>"pdtri")
ufunc_pdtri_data[0] = &ufunc_pdtri_ptr[2*0]
ufunc_pdtri_data[1] = &ufunc_pdtri_ptr[2*1]
ufunc_pdtri_data[2] = &ufunc_pdtri_ptr[2*2]
pdtri = np.PyUFunc_FromFuncAndData(ufunc_pdtri_loops, ufunc_pdtri_data, ufunc_pdtri_types, 3, 2, 1, 0, "pdtri", ufunc_pdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pdtrik_loops[2]
cdef void *ufunc_pdtrik_ptr[4]
cdef void *ufunc_pdtrik_data[2]
cdef char ufunc_pdtrik_types[6]
cdef char *ufunc_pdtrik_doc = (
    "pdtrik(p, m)\n"
    "\n"
    "Inverse to `pdtr` vs k\n"
    "\n"
    "Returns the quantile k such that ``pdtr(k, m) = p``")
ufunc_pdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pdtrik_types[0] = <char>NPY_FLOAT
ufunc_pdtrik_types[1] = <char>NPY_FLOAT
ufunc_pdtrik_types[2] = <char>NPY_FLOAT
ufunc_pdtrik_types[3] = <char>NPY_DOUBLE
ufunc_pdtrik_types[4] = <char>NPY_DOUBLE
ufunc_pdtrik_types[5] = <char>NPY_DOUBLE
ufunc_pdtrik_ptr[2*0] = <void*>_func_cdfpoi2_wrap
ufunc_pdtrik_ptr[2*0+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_ptr[2*1] = <void*>_func_cdfpoi2_wrap
ufunc_pdtrik_ptr[2*1+1] = <void*>(<char*>"pdtrik")
ufunc_pdtrik_data[0] = &ufunc_pdtrik_ptr[2*0]
ufunc_pdtrik_data[1] = &ufunc_pdtrik_ptr[2*1]
pdtrik = np.PyUFunc_FromFuncAndData(ufunc_pdtrik_loops, ufunc_pdtrik_data, ufunc_pdtrik_types, 2, 2, 1, 0, "pdtrik", ufunc_pdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_poch_loops[2]
cdef void *ufunc_poch_ptr[4]
cdef void *ufunc_poch_data[2]
cdef char ufunc_poch_types[6]
cdef char *ufunc_poch_doc = (
    "poch(z, m)\n"
    "\n"
    "Rising factorial (z)_m\n"
    "\n"
    "The Pochhammer symbol (rising factorial), is defined as::\n"
    "\n"
    "    (z)_m = gamma(z + m) / gamma(z)\n"
    "\n"
    "For positive integer `m` it reads::\n"
    "\n"
    "    (z)_m = z * (z + 1) * ... * (z + m - 1)")
ufunc_poch_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_poch_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_poch_types[0] = <char>NPY_FLOAT
ufunc_poch_types[1] = <char>NPY_FLOAT
ufunc_poch_types[2] = <char>NPY_FLOAT
ufunc_poch_types[3] = <char>NPY_DOUBLE
ufunc_poch_types[4] = <char>NPY_DOUBLE
ufunc_poch_types[5] = <char>NPY_DOUBLE
ufunc_poch_ptr[2*0] = <void*>_func_poch
ufunc_poch_ptr[2*0+1] = <void*>(<char*>"poch")
ufunc_poch_ptr[2*1] = <void*>_func_poch
ufunc_poch_ptr[2*1+1] = <void*>(<char*>"poch")
ufunc_poch_data[0] = &ufunc_poch_ptr[2*0]
ufunc_poch_data[1] = &ufunc_poch_ptr[2*1]
poch = np.PyUFunc_FromFuncAndData(ufunc_poch_loops, ufunc_poch_data, ufunc_poch_types, 2, 2, 1, 0, "poch", ufunc_poch_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_ang1_loops[2]
cdef void *ufunc_pro_ang1_ptr[4]
cdef void *ufunc_pro_ang1_data[2]
cdef char ufunc_pro_ang1_types[12]
cdef char *ufunc_pro_ang1_doc = (
    "pro_ang1(m, n, c, x)\n"
    "\n"
    "Prolate spheroidal angular function of the first kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_ang1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_ang1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_ang1_types[0] = <char>NPY_FLOAT
ufunc_pro_ang1_types[1] = <char>NPY_FLOAT
ufunc_pro_ang1_types[2] = <char>NPY_FLOAT
ufunc_pro_ang1_types[3] = <char>NPY_FLOAT
ufunc_pro_ang1_types[4] = <char>NPY_FLOAT
ufunc_pro_ang1_types[5] = <char>NPY_FLOAT
ufunc_pro_ang1_types[6] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[7] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[8] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[9] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[10] = <char>NPY_DOUBLE
ufunc_pro_ang1_types[11] = <char>NPY_DOUBLE
ufunc_pro_ang1_ptr[2*0] = <void*>_func_prolate_aswfa_nocv_wrap
ufunc_pro_ang1_ptr[2*0+1] = <void*>(<char*>"pro_ang1")
ufunc_pro_ang1_ptr[2*1] = <void*>_func_prolate_aswfa_nocv_wrap
ufunc_pro_ang1_ptr[2*1+1] = <void*>(<char*>"pro_ang1")
ufunc_pro_ang1_data[0] = &ufunc_pro_ang1_ptr[2*0]
ufunc_pro_ang1_data[1] = &ufunc_pro_ang1_ptr[2*1]
pro_ang1 = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_loops, ufunc_pro_ang1_data, ufunc_pro_ang1_types, 2, 4, 2, 0, "pro_ang1", ufunc_pro_ang1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_ang1_cv_loops[2]
cdef void *ufunc_pro_ang1_cv_ptr[4]
cdef void *ufunc_pro_ang1_cv_data[2]
cdef char ufunc_pro_ang1_cv_types[14]
cdef char *ufunc_pro_ang1_cv_doc = (
    "pro_ang1_cv(m, n, c, cv, x)\n"
    "\n"
    "Prolate spheroidal angular function pro_ang1 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal angular function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_ang1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_ang1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_ang1_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_ang1_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_ang1_cv_ptr[2*0] = <void*>_func_prolate_aswfa_wrap
ufunc_pro_ang1_cv_ptr[2*0+1] = <void*>(<char*>"pro_ang1_cv")
ufunc_pro_ang1_cv_ptr[2*1] = <void*>_func_prolate_aswfa_wrap
ufunc_pro_ang1_cv_ptr[2*1+1] = <void*>(<char*>"pro_ang1_cv")
ufunc_pro_ang1_cv_data[0] = &ufunc_pro_ang1_cv_ptr[2*0]
ufunc_pro_ang1_cv_data[1] = &ufunc_pro_ang1_cv_ptr[2*1]
pro_ang1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_ang1_cv_loops, ufunc_pro_ang1_cv_data, ufunc_pro_ang1_cv_types, 2, 5, 2, 0, "pro_ang1_cv", ufunc_pro_ang1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_cv_loops[2]
cdef void *ufunc_pro_cv_ptr[4]
cdef void *ufunc_pro_cv_data[2]
cdef char ufunc_pro_cv_types[8]
cdef char *ufunc_pro_cv_doc = (
    "pro_cv(m, n, c)\n"
    "\n"
    "Characteristic value of prolate spheroidal function\n"
    "\n"
    "Computes the characteristic value of prolate spheroidal wave\n"
    "functions of order `m`, `n` (n>=m) and spheroidal parameter `c`.")
ufunc_pro_cv_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_pro_cv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_pro_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_cv_types[4] = <char>NPY_DOUBLE
ufunc_pro_cv_types[5] = <char>NPY_DOUBLE
ufunc_pro_cv_types[6] = <char>NPY_DOUBLE
ufunc_pro_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_cv_ptr[2*0] = <void*>_func_prolate_segv_wrap
ufunc_pro_cv_ptr[2*0+1] = <void*>(<char*>"pro_cv")
ufunc_pro_cv_ptr[2*1] = <void*>_func_prolate_segv_wrap
ufunc_pro_cv_ptr[2*1+1] = <void*>(<char*>"pro_cv")
ufunc_pro_cv_data[0] = &ufunc_pro_cv_ptr[2*0]
ufunc_pro_cv_data[1] = &ufunc_pro_cv_ptr[2*1]
pro_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_cv_loops, ufunc_pro_cv_data, ufunc_pro_cv_types, 2, 3, 1, 0, "pro_cv", ufunc_pro_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad1_loops[2]
cdef void *ufunc_pro_rad1_ptr[4]
cdef void *ufunc_pro_rad1_data[2]
cdef char ufunc_pro_rad1_types[12]
cdef char *ufunc_pro_rad1_doc = (
    "pro_rad1(m, n, c, x)\n"
    "\n"
    "Prolate spheroidal radial function of the first kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_rad1_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_rad1_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_rad1_types[0] = <char>NPY_FLOAT
ufunc_pro_rad1_types[1] = <char>NPY_FLOAT
ufunc_pro_rad1_types[2] = <char>NPY_FLOAT
ufunc_pro_rad1_types[3] = <char>NPY_FLOAT
ufunc_pro_rad1_types[4] = <char>NPY_FLOAT
ufunc_pro_rad1_types[5] = <char>NPY_FLOAT
ufunc_pro_rad1_types[6] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad1_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad1_ptr[2*0] = <void*>_func_prolate_radial1_nocv_wrap
ufunc_pro_rad1_ptr[2*0+1] = <void*>(<char*>"pro_rad1")
ufunc_pro_rad1_ptr[2*1] = <void*>_func_prolate_radial1_nocv_wrap
ufunc_pro_rad1_ptr[2*1+1] = <void*>(<char*>"pro_rad1")
ufunc_pro_rad1_data[0] = &ufunc_pro_rad1_ptr[2*0]
ufunc_pro_rad1_data[1] = &ufunc_pro_rad1_ptr[2*1]
pro_rad1 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_loops, ufunc_pro_rad1_data, ufunc_pro_rad1_types, 2, 4, 2, 0, "pro_rad1", ufunc_pro_rad1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad1_cv_loops[2]
cdef void *ufunc_pro_rad1_cv_ptr[4]
cdef void *ufunc_pro_rad1_cv_data[2]
cdef char ufunc_pro_rad1_cv_types[14]
cdef char *ufunc_pro_rad1_cv_doc = (
    "pro_rad1_cv(m, n, c, cv, x)\n"
    "\n"
    "Prolate spheroidal radial function pro_rad1 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal radial function of the first kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_rad1_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_rad1_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_rad1_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_rad1_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_rad1_cv_ptr[2*0] = <void*>_func_prolate_radial1_wrap
ufunc_pro_rad1_cv_ptr[2*0+1] = <void*>(<char*>"pro_rad1_cv")
ufunc_pro_rad1_cv_ptr[2*1] = <void*>_func_prolate_radial1_wrap
ufunc_pro_rad1_cv_ptr[2*1+1] = <void*>(<char*>"pro_rad1_cv")
ufunc_pro_rad1_cv_data[0] = &ufunc_pro_rad1_cv_ptr[2*0]
ufunc_pro_rad1_cv_data[1] = &ufunc_pro_rad1_cv_ptr[2*1]
pro_rad1_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad1_cv_loops, ufunc_pro_rad1_cv_data, ufunc_pro_rad1_cv_types, 2, 5, 2, 0, "pro_rad1_cv", ufunc_pro_rad1_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad2_loops[2]
cdef void *ufunc_pro_rad2_ptr[4]
cdef void *ufunc_pro_rad2_data[2]
cdef char ufunc_pro_rad2_types[12]
cdef char *ufunc_pro_rad2_doc = (
    "pro_rad2(m, n, c, x)\n"
    "\n"
    "Prolate spheroidal radial function of the second kind and its derivative\n"
    "\n"
    "Computes the prolate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_rad2_loops[0] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_ffff_ff
ufunc_pro_rad2_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd_d_As_dddd_dd
ufunc_pro_rad2_types[0] = <char>NPY_FLOAT
ufunc_pro_rad2_types[1] = <char>NPY_FLOAT
ufunc_pro_rad2_types[2] = <char>NPY_FLOAT
ufunc_pro_rad2_types[3] = <char>NPY_FLOAT
ufunc_pro_rad2_types[4] = <char>NPY_FLOAT
ufunc_pro_rad2_types[5] = <char>NPY_FLOAT
ufunc_pro_rad2_types[6] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad2_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad2_ptr[2*0] = <void*>_func_prolate_radial2_nocv_wrap
ufunc_pro_rad2_ptr[2*0+1] = <void*>(<char*>"pro_rad2")
ufunc_pro_rad2_ptr[2*1] = <void*>_func_prolate_radial2_nocv_wrap
ufunc_pro_rad2_ptr[2*1+1] = <void*>(<char*>"pro_rad2")
ufunc_pro_rad2_data[0] = &ufunc_pro_rad2_ptr[2*0]
ufunc_pro_rad2_data[1] = &ufunc_pro_rad2_ptr[2*1]
pro_rad2 = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_loops, ufunc_pro_rad2_data, ufunc_pro_rad2_types, 2, 4, 2, 0, "pro_rad2", ufunc_pro_rad2_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pro_rad2_cv_loops[2]
cdef void *ufunc_pro_rad2_cv_ptr[4]
cdef void *ufunc_pro_rad2_cv_data[2]
cdef char ufunc_pro_rad2_cv_types[14]
cdef char *ufunc_pro_rad2_cv_doc = (
    "pro_rad2_cv(m, n, c, cv, x)\n"
    "\n"
    "Prolate spheroidal radial function pro_rad2 for precomputed characteristic value\n"
    "\n"
    "Computes the prolate spheroidal radial function of the second kind\n"
    "and its derivative (with respect to `x`) for mode parameters m>=0\n"
    "and n>=m, spheroidal parameter `c` and ``|x| < 1.0``. Requires\n"
    "pre-computed characteristic value.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s\n"
    "    Value of the function\n"
    "sp\n"
    "    Value of the derivative vs x")
ufunc_pro_rad2_cv_loops[0] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_fffff_ff
ufunc_pro_rad2_cv_loops[1] = <np.PyUFuncGenericFunction>loop_i_ddddd_dd_As_ddddd_dd
ufunc_pro_rad2_cv_types[0] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[1] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[2] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[3] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[4] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[5] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[6] = <char>NPY_FLOAT
ufunc_pro_rad2_cv_types[7] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[8] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[9] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[10] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[11] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[12] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_types[13] = <char>NPY_DOUBLE
ufunc_pro_rad2_cv_ptr[2*0] = <void*>_func_prolate_radial2_wrap
ufunc_pro_rad2_cv_ptr[2*0+1] = <void*>(<char*>"pro_rad2_cv")
ufunc_pro_rad2_cv_ptr[2*1] = <void*>_func_prolate_radial2_wrap
ufunc_pro_rad2_cv_ptr[2*1+1] = <void*>(<char*>"pro_rad2_cv")
ufunc_pro_rad2_cv_data[0] = &ufunc_pro_rad2_cv_ptr[2*0]
ufunc_pro_rad2_cv_data[1] = &ufunc_pro_rad2_cv_ptr[2*1]
pro_rad2_cv = np.PyUFunc_FromFuncAndData(ufunc_pro_rad2_cv_loops, ufunc_pro_rad2_cv_data, ufunc_pro_rad2_cv_types, 2, 5, 2, 0, "pro_rad2_cv", ufunc_pro_rad2_cv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_pseudo_huber_loops[2]
cdef void *ufunc_pseudo_huber_ptr[4]
cdef void *ufunc_pseudo_huber_data[2]
cdef char ufunc_pseudo_huber_types[6]
cdef char *ufunc_pseudo_huber_doc = (
    "pseudo_huber(delta, r)\n"
    "\n"
    "Pseudo-Huber loss function.\n"
    "\n"
    ".. math:: \\mathrm{pseudo\\_huber}(\\delta, r) = \\delta^2 \\left( \\sqrt{ 1 + \\left( \\frac{r}{\\delta} \\right)^2 } - 1 \\right)\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "delta : ndarray\n"
    "    Input array, indicating the soft quadratic vs. linear loss changepoint.\n"
    "r : ndarray\n"
    "    Input array, possibly representing residuals.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    The computed Pseudo-Huber loss function values.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is convex in :math:`r`.\n"
    "\n"
    ".. versionadded:: 0.15.0")
ufunc_pseudo_huber_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_pseudo_huber_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_pseudo_huber_types[0] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[1] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[2] = <char>NPY_FLOAT
ufunc_pseudo_huber_types[3] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[4] = <char>NPY_DOUBLE
ufunc_pseudo_huber_types[5] = <char>NPY_DOUBLE
ufunc_pseudo_huber_ptr[2*0] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*0+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_ptr[2*1] = <void*>_func_pseudo_huber
ufunc_pseudo_huber_ptr[2*1+1] = <void*>(<char*>"pseudo_huber")
ufunc_pseudo_huber_data[0] = &ufunc_pseudo_huber_ptr[2*0]
ufunc_pseudo_huber_data[1] = &ufunc_pseudo_huber_ptr[2*1]
pseudo_huber = np.PyUFunc_FromFuncAndData(ufunc_pseudo_huber_loops, ufunc_pseudo_huber_data, ufunc_pseudo_huber_types, 2, 2, 1, 0, "pseudo_huber", ufunc_pseudo_huber_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_psi_loops[4]
cdef void *ufunc_psi_ptr[8]
cdef void *ufunc_psi_data[4]
cdef char ufunc_psi_types[8]
cdef char *ufunc_psi_doc = (
    "psi(z, out=None)\n"
    "\n"
    "The digamma function.\n"
    "\n"
    "The logarithmic derivative of the gamma function evaluated at ``z``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Real or complex argument.\n"
    "out : ndarray, optional\n"
    "    Array for the computed values of ``psi``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "digamma : ndarray\n"
    "    Computed values of ``psi``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For large values not close to the negative real axis ``psi`` is\n"
    "computed using the asymptotic series (5.11.2) from [1]_. For small\n"
    "arguments not close to the negative real axis the recurrence\n"
    "relation (5.5.2) from [1]_ is used until the argument is large\n"
    "enough to use the asymptotic series. For values close to the\n"
    "negative real axis the reflection formula (5.5.4) from [1]_ is\n"
    "used first.  Note that ``psi`` has a family of zeros on the\n"
    "negative real axis which occur between the poles at nonpositive\n"
    "integers. Around the zeros the reflection formula suffers from\n"
    "cancellation and the implementation loses precision. The sole\n"
    "positive zero and the first negative zero, however, are handled\n"
    "separately by precomputing series expansions using [2]_, so the\n"
    "function should maintain full accuracy around the origin.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       http://dlmf.nist.gov/5\n"
    ".. [2] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point arithmetic\"\n"
    "       (Version 0.19) http://mpmath.org/")
ufunc_psi_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_psi_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_psi_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_psi_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_psi_types[0] = <char>NPY_FLOAT
ufunc_psi_types[1] = <char>NPY_FLOAT
ufunc_psi_types[2] = <char>NPY_DOUBLE
ufunc_psi_types[3] = <char>NPY_DOUBLE
ufunc_psi_types[4] = <char>NPY_CFLOAT
ufunc_psi_types[5] = <char>NPY_CFLOAT
ufunc_psi_types[6] = <char>NPY_CDOUBLE
ufunc_psi_types[7] = <char>NPY_CDOUBLE
ufunc_psi_ptr[2*0] = <void*>_func_digamma
ufunc_psi_ptr[2*0+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*1] = <void*>_func_digamma
ufunc_psi_ptr[2*1+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*2] = <void*>_func_cdigamma
ufunc_psi_ptr[2*2+1] = <void*>(<char*>"psi")
ufunc_psi_ptr[2*3] = <void*>_func_cdigamma
ufunc_psi_ptr[2*3+1] = <void*>(<char*>"psi")
ufunc_psi_data[0] = &ufunc_psi_ptr[2*0]
ufunc_psi_data[1] = &ufunc_psi_ptr[2*1]
ufunc_psi_data[2] = &ufunc_psi_ptr[2*2]
ufunc_psi_data[3] = &ufunc_psi_ptr[2*3]
psi = np.PyUFunc_FromFuncAndData(ufunc_psi_loops, ufunc_psi_data, ufunc_psi_types, 4, 1, 1, 0, "psi", ufunc_psi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_radian_loops[2]
cdef void *ufunc_radian_ptr[4]
cdef void *ufunc_radian_data[2]
cdef char ufunc_radian_types[8]
cdef char *ufunc_radian_doc = (
    "radian(d, m, s)\n"
    "\n"
    "Convert from degrees to radians\n"
    "\n"
    "Returns the angle given in (d)egrees, (m)inutes, and (s)econds in\n"
    "radians.")
ufunc_radian_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_radian_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_radian_types[0] = <char>NPY_FLOAT
ufunc_radian_types[1] = <char>NPY_FLOAT
ufunc_radian_types[2] = <char>NPY_FLOAT
ufunc_radian_types[3] = <char>NPY_FLOAT
ufunc_radian_types[4] = <char>NPY_DOUBLE
ufunc_radian_types[5] = <char>NPY_DOUBLE
ufunc_radian_types[6] = <char>NPY_DOUBLE
ufunc_radian_types[7] = <char>NPY_DOUBLE
ufunc_radian_ptr[2*0] = <void*>_func_radian
ufunc_radian_ptr[2*0+1] = <void*>(<char*>"radian")
ufunc_radian_ptr[2*1] = <void*>_func_radian
ufunc_radian_ptr[2*1+1] = <void*>(<char*>"radian")
ufunc_radian_data[0] = &ufunc_radian_ptr[2*0]
ufunc_radian_data[1] = &ufunc_radian_ptr[2*1]
radian = np.PyUFunc_FromFuncAndData(ufunc_radian_loops, ufunc_radian_data, ufunc_radian_types, 2, 3, 1, 0, "radian", ufunc_radian_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_rel_entr_loops[2]
cdef void *ufunc_rel_entr_ptr[4]
cdef void *ufunc_rel_entr_data[2]
cdef char ufunc_rel_entr_types[6]
cdef char *ufunc_rel_entr_doc = (
    "rel_entr(x, y)\n"
    "\n"
    "Elementwise function for computing relative entropy.\n"
    "\n"
    ".. math:: \\mathrm{rel\\_entr}(x, y) = \\begin{cases} x \\log(x / y) & x > 0, y > 0 \\\\ 0 & x = 0, y \\ge 0 \\\\ \\infty & \\text{otherwise} \\end{cases}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : ndarray\n"
    "    First input array.\n"
    "y : ndarray\n"
    "    Second input array.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "res : ndarray\n"
    "    Output array.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "entr, kl_div\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is jointly convex in x and y.\n"
    "\n"
    ".. versionadded:: 0.15.0")
ufunc_rel_entr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_rel_entr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_rel_entr_types[0] = <char>NPY_FLOAT
ufunc_rel_entr_types[1] = <char>NPY_FLOAT
ufunc_rel_entr_types[2] = <char>NPY_FLOAT
ufunc_rel_entr_types[3] = <char>NPY_DOUBLE
ufunc_rel_entr_types[4] = <char>NPY_DOUBLE
ufunc_rel_entr_types[5] = <char>NPY_DOUBLE
ufunc_rel_entr_ptr[2*0] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*0+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_ptr[2*1] = <void*>_func_rel_entr
ufunc_rel_entr_ptr[2*1+1] = <void*>(<char*>"rel_entr")
ufunc_rel_entr_data[0] = &ufunc_rel_entr_ptr[2*0]
ufunc_rel_entr_data[1] = &ufunc_rel_entr_ptr[2*1]
rel_entr = np.PyUFunc_FromFuncAndData(ufunc_rel_entr_loops, ufunc_rel_entr_data, ufunc_rel_entr_types, 2, 2, 1, 0, "rel_entr", ufunc_rel_entr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_rgamma_loops[4]
cdef void *ufunc_rgamma_ptr[8]
cdef void *ufunc_rgamma_data[4]
cdef char ufunc_rgamma_types[8]
cdef char *ufunc_rgamma_doc = (
    "rgamma(z)\n"
    "\n"
    "Gamma function inverted\n"
    "\n"
    "Returns ``1/gamma(x)``")
ufunc_rgamma_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_rgamma_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_rgamma_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_rgamma_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_rgamma_types[0] = <char>NPY_FLOAT
ufunc_rgamma_types[1] = <char>NPY_FLOAT
ufunc_rgamma_types[2] = <char>NPY_DOUBLE
ufunc_rgamma_types[3] = <char>NPY_DOUBLE
ufunc_rgamma_types[4] = <char>NPY_CFLOAT
ufunc_rgamma_types[5] = <char>NPY_CFLOAT
ufunc_rgamma_types[6] = <char>NPY_CDOUBLE
ufunc_rgamma_types[7] = <char>NPY_CDOUBLE
ufunc_rgamma_ptr[2*0] = <void*>_func_rgamma
ufunc_rgamma_ptr[2*0+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*1] = <void*>_func_rgamma
ufunc_rgamma_ptr[2*1+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*2] = <void*>_func_crgamma
ufunc_rgamma_ptr[2*2+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_ptr[2*3] = <void*>_func_crgamma
ufunc_rgamma_ptr[2*3+1] = <void*>(<char*>"rgamma")
ufunc_rgamma_data[0] = &ufunc_rgamma_ptr[2*0]
ufunc_rgamma_data[1] = &ufunc_rgamma_ptr[2*1]
ufunc_rgamma_data[2] = &ufunc_rgamma_ptr[2*2]
ufunc_rgamma_data[3] = &ufunc_rgamma_ptr[2*3]
rgamma = np.PyUFunc_FromFuncAndData(ufunc_rgamma_loops, ufunc_rgamma_data, ufunc_rgamma_types, 4, 1, 1, 0, "rgamma", ufunc_rgamma_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_round_loops[2]
cdef void *ufunc_round_ptr[4]
cdef void *ufunc_round_data[2]
cdef char ufunc_round_types[4]
cdef char *ufunc_round_doc = (
    "round(x)\n"
    "\n"
    "Round to nearest integer\n"
    "\n"
    "Returns the nearest integer to `x` as a double precision floating\n"
    "point result.  If `x` ends in 0.5 exactly, the nearest even integer\n"
    "is chosen.")
ufunc_round_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_round_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_round_types[0] = <char>NPY_FLOAT
ufunc_round_types[1] = <char>NPY_FLOAT
ufunc_round_types[2] = <char>NPY_DOUBLE
ufunc_round_types[3] = <char>NPY_DOUBLE
ufunc_round_ptr[2*0] = <void*>_func_round
ufunc_round_ptr[2*0+1] = <void*>(<char*>"round")
ufunc_round_ptr[2*1] = <void*>_func_round
ufunc_round_ptr[2*1+1] = <void*>(<char*>"round")
ufunc_round_data[0] = &ufunc_round_ptr[2*0]
ufunc_round_data[1] = &ufunc_round_ptr[2*1]
round = np.PyUFunc_FromFuncAndData(ufunc_round_loops, ufunc_round_data, ufunc_round_types, 2, 1, 1, 0, "round", ufunc_round_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_shichi_loops[4]
cdef void *ufunc_shichi_ptr[8]
cdef void *ufunc_shichi_data[4]
cdef char ufunc_shichi_types[12]
cdef char *ufunc_shichi_doc = (
    "shichi(x, out=None)\n"
    "\n"
    "Hyperbolic sine and cosine integrals.\n"
    "\n"
    "The hyperbolic sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sinh{t}}{t}dt\n"
    "\n"
    "and the hyperbolic cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cosh{t} - 1}{t} dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principle branch of the logarithm.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the hyperbolic sine\n"
    "    and cosine integrals.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : ndarray\n"
    "    Hyperbolic sine integral at ``x``\n"
    "ci : ndarray\n"
    "    Hyperbolic cosine integral at ``x``\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``chi`` is the real part of the\n"
    "hyperbolic cosine integral. For such points ``chi(x)`` and ``chi(x\n"
    "+ 0j)`` differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[1]_ *shichi* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [2]_ *shi* and *chi* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point arithmetic\"\n"
    "       (Version 0.19) http://mpmath.org/")
ufunc_shichi_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_shichi_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_shichi_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_shichi_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_shichi_types[0] = <char>NPY_FLOAT
ufunc_shichi_types[1] = <char>NPY_FLOAT
ufunc_shichi_types[2] = <char>NPY_FLOAT
ufunc_shichi_types[3] = <char>NPY_DOUBLE
ufunc_shichi_types[4] = <char>NPY_DOUBLE
ufunc_shichi_types[5] = <char>NPY_DOUBLE
ufunc_shichi_types[6] = <char>NPY_CFLOAT
ufunc_shichi_types[7] = <char>NPY_CFLOAT
ufunc_shichi_types[8] = <char>NPY_CFLOAT
ufunc_shichi_types[9] = <char>NPY_CDOUBLE
ufunc_shichi_types[10] = <char>NPY_CDOUBLE
ufunc_shichi_types[11] = <char>NPY_CDOUBLE
ufunc_shichi_ptr[2*0] = <void*>_func_shichi
ufunc_shichi_ptr[2*0+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*1] = <void*>_func_shichi
ufunc_shichi_ptr[2*1+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*2] = <void*>_func_cshichi
ufunc_shichi_ptr[2*2+1] = <void*>(<char*>"shichi")
ufunc_shichi_ptr[2*3] = <void*>_func_cshichi
ufunc_shichi_ptr[2*3+1] = <void*>(<char*>"shichi")
ufunc_shichi_data[0] = &ufunc_shichi_ptr[2*0]
ufunc_shichi_data[1] = &ufunc_shichi_ptr[2*1]
ufunc_shichi_data[2] = &ufunc_shichi_ptr[2*2]
ufunc_shichi_data[3] = &ufunc_shichi_ptr[2*3]
shichi = np.PyUFunc_FromFuncAndData(ufunc_shichi_loops, ufunc_shichi_data, ufunc_shichi_types, 4, 1, 2, 0, "shichi", ufunc_shichi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sici_loops[4]
cdef void *ufunc_sici_ptr[8]
cdef void *ufunc_sici_data[4]
cdef char ufunc_sici_types[12]
cdef char *ufunc_sici_doc = (
    "sici(x, out=None)\n"
    "\n"
    "Sine and cosine integrals.\n"
    "\n"
    "The sine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\int_0^x \\frac{\\sin{t}}{t}dt\n"
    "\n"
    "and the cosine integral is\n"
    "\n"
    ".. math::\n"
    "\n"
    "  \\gamma + \\log(x) + \\int_0^x \\frac{\\cos{t} - 1}{t}dt\n"
    "\n"
    "where :math:`\\gamma` is Euler's constant and :math:`\\log` is the\n"
    "principle branch of the logarithm.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real or complex points at which to compute the sine and cosine\n"
    "    integrals.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "si : ndarray\n"
    "    Sine integral at ``x``\n"
    "ci : ndarray\n"
    "    Cosine integral at ``x``\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For real arguments with ``x < 0``, ``ci`` is the real part of the\n"
    "cosine integral. For such points ``ci(x)`` and ``ci(x + 0j)``\n"
    "differ by a factor of ``1j*pi``.\n"
    "\n"
    "For real arguments the function is computed by calling Cephes'\n"
    "[1]_ *sici* routine. For complex arguments the algorithm is based\n"
    "on Mpmath's [2]_ *si* and *ci* routines.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html\n"
    ".. [2] Fredrik Johansson and others.\n"
    "       \"mpmath: a Python library for arbitrary-precision floating-point arithmetic\"\n"
    "       (Version 0.19) http://mpmath.org/")
ufunc_sici_loops[0] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_f_ff
ufunc_sici_loops[1] = <np.PyUFuncGenericFunction>loop_i_d_dd_As_d_dd
ufunc_sici_loops[2] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_F_FF
ufunc_sici_loops[3] = <np.PyUFuncGenericFunction>loop_i_D_DD_As_D_DD
ufunc_sici_types[0] = <char>NPY_FLOAT
ufunc_sici_types[1] = <char>NPY_FLOAT
ufunc_sici_types[2] = <char>NPY_FLOAT
ufunc_sici_types[3] = <char>NPY_DOUBLE
ufunc_sici_types[4] = <char>NPY_DOUBLE
ufunc_sici_types[5] = <char>NPY_DOUBLE
ufunc_sici_types[6] = <char>NPY_CFLOAT
ufunc_sici_types[7] = <char>NPY_CFLOAT
ufunc_sici_types[8] = <char>NPY_CFLOAT
ufunc_sici_types[9] = <char>NPY_CDOUBLE
ufunc_sici_types[10] = <char>NPY_CDOUBLE
ufunc_sici_types[11] = <char>NPY_CDOUBLE
ufunc_sici_ptr[2*0] = <void*>_func_sici
ufunc_sici_ptr[2*0+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*1] = <void*>_func_sici
ufunc_sici_ptr[2*1+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*2] = <void*>_func_csici
ufunc_sici_ptr[2*2+1] = <void*>(<char*>"sici")
ufunc_sici_ptr[2*3] = <void*>_func_csici
ufunc_sici_ptr[2*3+1] = <void*>(<char*>"sici")
ufunc_sici_data[0] = &ufunc_sici_ptr[2*0]
ufunc_sici_data[1] = &ufunc_sici_ptr[2*1]
ufunc_sici_data[2] = &ufunc_sici_ptr[2*2]
ufunc_sici_data[3] = &ufunc_sici_ptr[2*3]
sici = np.PyUFunc_FromFuncAndData(ufunc_sici_loops, ufunc_sici_data, ufunc_sici_types, 4, 1, 2, 0, "sici", ufunc_sici_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sindg_loops[2]
cdef void *ufunc_sindg_ptr[4]
cdef void *ufunc_sindg_data[2]
cdef char ufunc_sindg_types[4]
cdef char *ufunc_sindg_doc = (
    "sindg(x)\n"
    "\n"
    "Sine of angle given in degrees")
ufunc_sindg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_sindg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_sindg_types[0] = <char>NPY_FLOAT
ufunc_sindg_types[1] = <char>NPY_FLOAT
ufunc_sindg_types[2] = <char>NPY_DOUBLE
ufunc_sindg_types[3] = <char>NPY_DOUBLE
ufunc_sindg_ptr[2*0] = <void*>_func_sindg
ufunc_sindg_ptr[2*0+1] = <void*>(<char*>"sindg")
ufunc_sindg_ptr[2*1] = <void*>_func_sindg
ufunc_sindg_ptr[2*1+1] = <void*>(<char*>"sindg")
ufunc_sindg_data[0] = &ufunc_sindg_ptr[2*0]
ufunc_sindg_data[1] = &ufunc_sindg_ptr[2*1]
sindg = np.PyUFunc_FromFuncAndData(ufunc_sindg_loops, ufunc_sindg_data, ufunc_sindg_types, 2, 1, 1, 0, "sindg", ufunc_sindg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnov_loops[3]
cdef void *ufunc_smirnov_ptr[6]
cdef void *ufunc_smirnov_data[3]
cdef char ufunc_smirnov_types[9]
cdef char *ufunc_smirnov_doc = (
    "smirnov(n, e)\n"
    "\n"
    "Kolmogorov-Smirnov complementary cumulative distribution function\n"
    "\n"
    "Returns the exact Kolmogorov-Smirnov complementary cumulative\n"
    "distribution function (Dn+ or Dn-) for a one-sided test of\n"
    "equality between an empirical and a theoretical distribution. It\n"
    "is equal to the probability that the maximum difference between a\n"
    "theoretical distribution and an empirical one based on `n` samples\n"
    "is greater than e.")
ufunc_smirnov_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_smirnov_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnov_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnov_types[0] = <char>NPY_LONG
ufunc_smirnov_types[1] = <char>NPY_DOUBLE
ufunc_smirnov_types[2] = <char>NPY_DOUBLE
ufunc_smirnov_types[3] = <char>NPY_FLOAT
ufunc_smirnov_types[4] = <char>NPY_FLOAT
ufunc_smirnov_types[5] = <char>NPY_FLOAT
ufunc_smirnov_types[6] = <char>NPY_DOUBLE
ufunc_smirnov_types[7] = <char>NPY_DOUBLE
ufunc_smirnov_types[8] = <char>NPY_DOUBLE
ufunc_smirnov_ptr[2*0] = <void*>_func_smirnov
ufunc_smirnov_ptr[2*0+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*1] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*1+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_ptr[2*2] = <void*>_func_smirnov_unsafe
ufunc_smirnov_ptr[2*2+1] = <void*>(<char*>"smirnov")
ufunc_smirnov_data[0] = &ufunc_smirnov_ptr[2*0]
ufunc_smirnov_data[1] = &ufunc_smirnov_ptr[2*1]
ufunc_smirnov_data[2] = &ufunc_smirnov_ptr[2*2]
smirnov = np.PyUFunc_FromFuncAndData(ufunc_smirnov_loops, ufunc_smirnov_data, ufunc_smirnov_types, 3, 2, 1, 0, "smirnov", ufunc_smirnov_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnovi_loops[3]
cdef void *ufunc_smirnovi_ptr[6]
cdef void *ufunc_smirnovi_data[3]
cdef char ufunc_smirnovi_types[9]
cdef char *ufunc_smirnovi_doc = (
    "smirnovi(n, y)\n"
    "\n"
    "Inverse to `smirnov`\n"
    "\n"
    "Returns ``e`` such that ``smirnov(n, e) = y``.")
ufunc_smirnovi_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_smirnovi_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnovi_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnovi_types[0] = <char>NPY_LONG
ufunc_smirnovi_types[1] = <char>NPY_DOUBLE
ufunc_smirnovi_types[2] = <char>NPY_DOUBLE
ufunc_smirnovi_types[3] = <char>NPY_FLOAT
ufunc_smirnovi_types[4] = <char>NPY_FLOAT
ufunc_smirnovi_types[5] = <char>NPY_FLOAT
ufunc_smirnovi_types[6] = <char>NPY_DOUBLE
ufunc_smirnovi_types[7] = <char>NPY_DOUBLE
ufunc_smirnovi_types[8] = <char>NPY_DOUBLE
ufunc_smirnovi_ptr[2*0] = <void*>_func_smirnovi
ufunc_smirnovi_ptr[2*0+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*1] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*1+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_ptr[2*2] = <void*>_func_smirnovi_unsafe
ufunc_smirnovi_ptr[2*2+1] = <void*>(<char*>"smirnovi")
ufunc_smirnovi_data[0] = &ufunc_smirnovi_ptr[2*0]
ufunc_smirnovi_data[1] = &ufunc_smirnovi_ptr[2*1]
ufunc_smirnovi_data[2] = &ufunc_smirnovi_ptr[2*2]
smirnovi = np.PyUFunc_FromFuncAndData(ufunc_smirnovi_loops, ufunc_smirnovi_data, ufunc_smirnovi_types, 3, 2, 1, 0, "smirnovi", ufunc_smirnovi_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_smirnovp_loops[3]
cdef void *ufunc_smirnovp_ptr[6]
cdef void *ufunc_smirnovp_data[3]
cdef char ufunc_smirnovp_types[9]
cdef char *ufunc_smirnovp_doc = (
    "smirnovp(n, y)\n"
    "\n"
    "Derivative of `smirnov`")
ufunc_smirnovp_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_smirnovp_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_smirnovp_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_smirnovp_types[0] = <char>NPY_LONG
ufunc_smirnovp_types[1] = <char>NPY_DOUBLE
ufunc_smirnovp_types[2] = <char>NPY_DOUBLE
ufunc_smirnovp_types[3] = <char>NPY_FLOAT
ufunc_smirnovp_types[4] = <char>NPY_FLOAT
ufunc_smirnovp_types[5] = <char>NPY_FLOAT
ufunc_smirnovp_types[6] = <char>NPY_DOUBLE
ufunc_smirnovp_types[7] = <char>NPY_DOUBLE
ufunc_smirnovp_types[8] = <char>NPY_DOUBLE
ufunc_smirnovp_ptr[2*0] = <void*>_func_smirnovp
ufunc_smirnovp_ptr[2*0+1] = <void*>(<char*>"smirnovp")
ufunc_smirnovp_ptr[2*1] = <void*>_func_smirnovp_unsafe
ufunc_smirnovp_ptr[2*1+1] = <void*>(<char*>"smirnovp")
ufunc_smirnovp_ptr[2*2] = <void*>_func_smirnovp_unsafe
ufunc_smirnovp_ptr[2*2+1] = <void*>(<char*>"smirnovp")
ufunc_smirnovp_data[0] = &ufunc_smirnovp_ptr[2*0]
ufunc_smirnovp_data[1] = &ufunc_smirnovp_ptr[2*1]
ufunc_smirnovp_data[2] = &ufunc_smirnovp_ptr[2*2]
smirnovp = np.PyUFunc_FromFuncAndData(ufunc_smirnovp_loops, ufunc_smirnovp_data, ufunc_smirnovp_types, 3, 2, 1, 0, "smirnovp", ufunc_smirnovp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_spence_loops[4]
cdef void *ufunc_spence_ptr[8]
cdef void *ufunc_spence_data[4]
cdef char ufunc_spence_types[8]
cdef char *ufunc_spence_doc = (
    "spence(z, out=None)\n"
    "\n"
    "Spence's function, also known as the dilogarithm.\n"
    "\n"
    "It is defined to be\n"
    "\n"
    ".. math::\n"
    "  \\int_0^z \\frac{\\log(t)}{1 - t}dt\n"
    "\n"
    "for complex :math:`z`, where the contour of integration is taken\n"
    "to avoid the branch cut of the logarithm. Spence's function is\n"
    "analytic everywhere except the negative real axis where it has a\n"
    "branch cut.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate Spence's function\n"
    "\n"
    "Returns\n"
    "-------\n"
    "s : ndarray\n"
    "    Computed values of Spence's function\n"
    "\n"
    "Notes\n"
    "-----\n"
    "There is a different convention which defines Spence's function by\n"
    "the integral\n"
    "\n"
    ".. math::\n"
    "  -\\int_0^z \\frac{\\log(1 - t)}{t}dt;\n"
    "\n"
    "this is our ``spence(1 - z)``.")
ufunc_spence_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_spence_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_spence_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_spence_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_spence_types[0] = <char>NPY_FLOAT
ufunc_spence_types[1] = <char>NPY_FLOAT
ufunc_spence_types[2] = <char>NPY_DOUBLE
ufunc_spence_types[3] = <char>NPY_DOUBLE
ufunc_spence_types[4] = <char>NPY_CFLOAT
ufunc_spence_types[5] = <char>NPY_CFLOAT
ufunc_spence_types[6] = <char>NPY_CDOUBLE
ufunc_spence_types[7] = <char>NPY_CDOUBLE
ufunc_spence_ptr[2*0] = <void*>_func_spence
ufunc_spence_ptr[2*0+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*1] = <void*>_func_spence
ufunc_spence_ptr[2*1+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*2] = <void*>_func_cspence
ufunc_spence_ptr[2*2+1] = <void*>(<char*>"spence")
ufunc_spence_ptr[2*3] = <void*>_func_cspence
ufunc_spence_ptr[2*3+1] = <void*>(<char*>"spence")
ufunc_spence_data[0] = &ufunc_spence_ptr[2*0]
ufunc_spence_data[1] = &ufunc_spence_ptr[2*1]
ufunc_spence_data[2] = &ufunc_spence_ptr[2*2]
ufunc_spence_data[3] = &ufunc_spence_ptr[2*3]
spence = np.PyUFunc_FromFuncAndData(ufunc_spence_loops, ufunc_spence_data, ufunc_spence_types, 4, 1, 1, 0, "spence", ufunc_spence_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_sph_harm_loops[3]
cdef void *ufunc_sph_harm_ptr[6]
cdef void *ufunc_sph_harm_data[3]
cdef char ufunc_sph_harm_types[15]
cdef char *ufunc_sph_harm_doc = (
    "sph_harm(m, n, theta, phi)\n"
    "\n"
    "Compute spherical harmonics.\n"
    "\n"
    "The spherical harmonics are defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y^m_n(\\theta,\\phi) = \\sqrt{\\frac{2n+1}{4\\pi} \\frac{(n-m)!}{(n+m)!}}\n"
    "      e^{i m \\theta} P^m_n(\\cos(\\phi))\n"
    "\n"
    "where :math:`P_n^m` are the associated Legendre functions; see `lpmv`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "m : array_like\n"
    "    Order of the harmonic (int); must have ``|m| <= n``.\n"
    "n : array_like\n"
    "   Degree of the harmonic (int); must have ``n >= 0``. This is\n"
    "   often denoted by ``l`` (lower case L) in descriptions of\n"
    "   spherical harmonics.\n"
    "theta : array_like\n"
    "   Azimuthal (longitudinal) coordinate; must be in ``[0, 2*pi]``.\n"
    "phi : array_like\n"
    "   Polar (colatitudinal) coordinate; must be in ``[0, pi]``.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y_mn : complex float\n"
    "   The harmonic :math:`Y^m_n` sampled at ``theta`` and ``phi``.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "There are different conventions for the meanings of the input\n"
    "arguments ``theta`` and ``phi``. In SciPy ``theta`` is the\n"
    "azimuthal angle and ``phi`` is the polar angle. It is common to\n"
    "see the opposite convention, that is, ``theta`` as the polar angle\n"
    "and ``phi`` as the azimuthal angle.\n"
    "\n"
    "Note that SciPy's spherical harmonics include the Condon-Shortley\n"
    "phase [2]_ because it is part of `lpmv`.\n"
    "\n"
    "With SciPy's conventions, the first several spherical harmonics\n"
    "are\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y_0^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{1}{\\pi}} \\\\\n"
    "    Y_1^{-1}(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n"
    "                                e^{-i\\theta} \\sin(\\phi) \\\\\n"
    "    Y_1^0(\\theta, \\phi) &= \\frac{1}{2} \\sqrt{\\frac{3}{\\pi}}\n"
    "                             \\cos(\\phi) \\\\\n"
    "    Y_1^1(\\theta, \\phi) &= -\\frac{1}{2} \\sqrt{\\frac{3}{2\\pi}}\n"
    "                             e^{i\\theta} \\sin(\\phi).\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Digital Library of Mathematical Functions, 14.30.\n"
    "       http://dlmf.nist.gov/14.30\n"
    ".. [2] https://en.wikipedia.org/wiki/Spherical_harmonics#Condon.E2.80.93Shortley_phase")
ufunc_sph_harm_loops[0] = <np.PyUFuncGenericFunction>loop_D_iidd__As_lldd_D
ufunc_sph_harm_loops[1] = <np.PyUFuncGenericFunction>loop_D_dddd__As_ffff_F
ufunc_sph_harm_loops[2] = <np.PyUFuncGenericFunction>loop_D_dddd__As_dddd_D
ufunc_sph_harm_types[0] = <char>NPY_LONG
ufunc_sph_harm_types[1] = <char>NPY_LONG
ufunc_sph_harm_types[2] = <char>NPY_DOUBLE
ufunc_sph_harm_types[3] = <char>NPY_DOUBLE
ufunc_sph_harm_types[4] = <char>NPY_CDOUBLE
ufunc_sph_harm_types[5] = <char>NPY_FLOAT
ufunc_sph_harm_types[6] = <char>NPY_FLOAT
ufunc_sph_harm_types[7] = <char>NPY_FLOAT
ufunc_sph_harm_types[8] = <char>NPY_FLOAT
ufunc_sph_harm_types[9] = <char>NPY_CFLOAT
ufunc_sph_harm_types[10] = <char>NPY_DOUBLE
ufunc_sph_harm_types[11] = <char>NPY_DOUBLE
ufunc_sph_harm_types[12] = <char>NPY_DOUBLE
ufunc_sph_harm_types[13] = <char>NPY_DOUBLE
ufunc_sph_harm_types[14] = <char>NPY_CDOUBLE
ufunc_sph_harm_ptr[2*0] = <void*>_func_sph_harmonic
ufunc_sph_harm_ptr[2*0+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_ptr[2*1] = <void*>_func_sph_harmonic_unsafe
ufunc_sph_harm_ptr[2*1+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_ptr[2*2] = <void*>_func_sph_harmonic_unsafe
ufunc_sph_harm_ptr[2*2+1] = <void*>(<char*>"sph_harm")
ufunc_sph_harm_data[0] = &ufunc_sph_harm_ptr[2*0]
ufunc_sph_harm_data[1] = &ufunc_sph_harm_ptr[2*1]
ufunc_sph_harm_data[2] = &ufunc_sph_harm_ptr[2*2]
sph_harm = np.PyUFunc_FromFuncAndData(ufunc_sph_harm_loops, ufunc_sph_harm_data, ufunc_sph_harm_types, 3, 4, 1, 0, "sph_harm", ufunc_sph_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtr_loops[2]
cdef void *ufunc_stdtr_ptr[4]
cdef void *ufunc_stdtr_data[2]
cdef char ufunc_stdtr_types[6]
cdef char *ufunc_stdtr_doc = (
    "stdtr(df, t)\n"
    "\n"
    "Student t distribution cumulative density function\n"
    "\n"
    "Returns the integral from minus infinity to t of the Student t\n"
    "distribution with df > 0 degrees of freedom::\n"
    "\n"
    "   gamma((df+1)/2)/(sqrt(df*pi)*gamma(df/2)) *\n"
    "   integral((1+x**2/df)**(-df/2-1/2), x=-inf..t)")
ufunc_stdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtr_types[0] = <char>NPY_FLOAT
ufunc_stdtr_types[1] = <char>NPY_FLOAT
ufunc_stdtr_types[2] = <char>NPY_FLOAT
ufunc_stdtr_types[3] = <char>NPY_DOUBLE
ufunc_stdtr_types[4] = <char>NPY_DOUBLE
ufunc_stdtr_types[5] = <char>NPY_DOUBLE
ufunc_stdtr_ptr[2*0] = <void*>_func_cdft1_wrap
ufunc_stdtr_ptr[2*0+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_ptr[2*1] = <void*>_func_cdft1_wrap
ufunc_stdtr_ptr[2*1+1] = <void*>(<char*>"stdtr")
ufunc_stdtr_data[0] = &ufunc_stdtr_ptr[2*0]
ufunc_stdtr_data[1] = &ufunc_stdtr_ptr[2*1]
stdtr = np.PyUFunc_FromFuncAndData(ufunc_stdtr_loops, ufunc_stdtr_data, ufunc_stdtr_types, 2, 2, 1, 0, "stdtr", ufunc_stdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtridf_loops[2]
cdef void *ufunc_stdtridf_ptr[4]
cdef void *ufunc_stdtridf_data[2]
cdef char ufunc_stdtridf_types[6]
cdef char *ufunc_stdtridf_doc = (
    "stdtridf(p, t)\n"
    "\n"
    "Inverse of `stdtr` vs df\n"
    "\n"
    "Returns the argument df such that stdtr(df, t) is equal to `p`.")
ufunc_stdtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtridf_types[0] = <char>NPY_FLOAT
ufunc_stdtridf_types[1] = <char>NPY_FLOAT
ufunc_stdtridf_types[2] = <char>NPY_FLOAT
ufunc_stdtridf_types[3] = <char>NPY_DOUBLE
ufunc_stdtridf_types[4] = <char>NPY_DOUBLE
ufunc_stdtridf_types[5] = <char>NPY_DOUBLE
ufunc_stdtridf_ptr[2*0] = <void*>_func_cdft3_wrap
ufunc_stdtridf_ptr[2*0+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_ptr[2*1] = <void*>_func_cdft3_wrap
ufunc_stdtridf_ptr[2*1+1] = <void*>(<char*>"stdtridf")
ufunc_stdtridf_data[0] = &ufunc_stdtridf_ptr[2*0]
ufunc_stdtridf_data[1] = &ufunc_stdtridf_ptr[2*1]
stdtridf = np.PyUFunc_FromFuncAndData(ufunc_stdtridf_loops, ufunc_stdtridf_data, ufunc_stdtridf_types, 2, 2, 1, 0, "stdtridf", ufunc_stdtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_stdtrit_loops[2]
cdef void *ufunc_stdtrit_ptr[4]
cdef void *ufunc_stdtrit_data[2]
cdef char ufunc_stdtrit_types[6]
cdef char *ufunc_stdtrit_doc = (
    "stdtrit(df, p)\n"
    "\n"
    "Inverse of `stdtr` vs `t`\n"
    "\n"
    "Returns the argument `t` such that stdtr(df, t) is equal to `p`.")
ufunc_stdtrit_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_stdtrit_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_stdtrit_types[0] = <char>NPY_FLOAT
ufunc_stdtrit_types[1] = <char>NPY_FLOAT
ufunc_stdtrit_types[2] = <char>NPY_FLOAT
ufunc_stdtrit_types[3] = <char>NPY_DOUBLE
ufunc_stdtrit_types[4] = <char>NPY_DOUBLE
ufunc_stdtrit_types[5] = <char>NPY_DOUBLE
ufunc_stdtrit_ptr[2*0] = <void*>_func_cdft2_wrap
ufunc_stdtrit_ptr[2*0+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_ptr[2*1] = <void*>_func_cdft2_wrap
ufunc_stdtrit_ptr[2*1+1] = <void*>(<char*>"stdtrit")
ufunc_stdtrit_data[0] = &ufunc_stdtrit_ptr[2*0]
ufunc_stdtrit_data[1] = &ufunc_stdtrit_ptr[2*1]
stdtrit = np.PyUFunc_FromFuncAndData(ufunc_stdtrit_loops, ufunc_stdtrit_data, ufunc_stdtrit_types, 2, 2, 1, 0, "stdtrit", ufunc_stdtrit_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_struve_loops[2]
cdef void *ufunc_struve_ptr[4]
cdef void *ufunc_struve_data[2]
cdef char ufunc_struve_types[6]
cdef char *ufunc_struve_doc = (
    "struve(v, x)\n"
    "\n"
    "Struve function.\n"
    "\n"
    "Return the value of the Struve function of order `v` at `x`.  The Struve\n"
    "function is defined as,\n"
    "\n"
    ".. math::\n"
    "    H_v(x) = (z/2)^{v + 1} \\sum_{n=0}^\\infty \\frac{(-1)^n (z/2)^{2n}}{\\Gamma(n + \\frac{3}{2}) \\Gamma(n + v + \\frac{3}{2})},\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order of the Struve function (float).\n"
    "x : array_like\n"
    "    Argument of the Struve function (float; must be positive unless `v` is\n"
    "    an integer).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "H : ndarray\n"
    "    Value of the Struve function of order `v` at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Three methods discussed in [1]_ are used to evaluate the Struve function:\n"
    "\n"
    "- power series\n"
    "- expansion in Bessel functions (if :math:`|z| < |v| + 20`)\n"
    "- asymptotic large-z expansion (if :math:`z \\geq 0.7v + 12`)\n"
    "\n"
    "Rounding errors are estimated based on the largest terms in the sums, and\n"
    "the result associated with the smallest error is returned.\n"
    "\n"
    "See also\n"
    "--------\n"
    "modstruve\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       http://dlmf.nist.gov/11")
ufunc_struve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_struve_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_struve_types[0] = <char>NPY_FLOAT
ufunc_struve_types[1] = <char>NPY_FLOAT
ufunc_struve_types[2] = <char>NPY_FLOAT
ufunc_struve_types[3] = <char>NPY_DOUBLE
ufunc_struve_types[4] = <char>NPY_DOUBLE
ufunc_struve_types[5] = <char>NPY_DOUBLE
ufunc_struve_ptr[2*0] = <void*>_func_struve_h
ufunc_struve_ptr[2*0+1] = <void*>(<char*>"struve")
ufunc_struve_ptr[2*1] = <void*>_func_struve_h
ufunc_struve_ptr[2*1+1] = <void*>(<char*>"struve")
ufunc_struve_data[0] = &ufunc_struve_ptr[2*0]
ufunc_struve_data[1] = &ufunc_struve_ptr[2*1]
struve = np.PyUFunc_FromFuncAndData(ufunc_struve_loops, ufunc_struve_data, ufunc_struve_types, 2, 2, 1, 0, "struve", ufunc_struve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_tandg_loops[2]
cdef void *ufunc_tandg_ptr[4]
cdef void *ufunc_tandg_data[2]
cdef char ufunc_tandg_types[4]
cdef char *ufunc_tandg_doc = (
    "tandg(x)\n"
    "\n"
    "Tangent of angle x given in degrees.")
ufunc_tandg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_tandg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_tandg_types[0] = <char>NPY_FLOAT
ufunc_tandg_types[1] = <char>NPY_FLOAT
ufunc_tandg_types[2] = <char>NPY_DOUBLE
ufunc_tandg_types[3] = <char>NPY_DOUBLE
ufunc_tandg_ptr[2*0] = <void*>_func_tandg
ufunc_tandg_ptr[2*0+1] = <void*>(<char*>"tandg")
ufunc_tandg_ptr[2*1] = <void*>_func_tandg
ufunc_tandg_ptr[2*1+1] = <void*>(<char*>"tandg")
ufunc_tandg_data[0] = &ufunc_tandg_ptr[2*0]
ufunc_tandg_data[1] = &ufunc_tandg_ptr[2*1]
tandg = np.PyUFunc_FromFuncAndData(ufunc_tandg_loops, ufunc_tandg_data, ufunc_tandg_types, 2, 1, 1, 0, "tandg", ufunc_tandg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_tklmbda_loops[2]
cdef void *ufunc_tklmbda_ptr[4]
cdef void *ufunc_tklmbda_data[2]
cdef char ufunc_tklmbda_types[6]
cdef char *ufunc_tklmbda_doc = (
    "tklmbda(x, lmbda)\n"
    "\n"
    "Tukey-Lambda cumulative distribution function")
ufunc_tklmbda_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_tklmbda_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_tklmbda_types[0] = <char>NPY_FLOAT
ufunc_tklmbda_types[1] = <char>NPY_FLOAT
ufunc_tklmbda_types[2] = <char>NPY_FLOAT
ufunc_tklmbda_types[3] = <char>NPY_DOUBLE
ufunc_tklmbda_types[4] = <char>NPY_DOUBLE
ufunc_tklmbda_types[5] = <char>NPY_DOUBLE
ufunc_tklmbda_ptr[2*0] = <void*>_func_tukeylambdacdf
ufunc_tklmbda_ptr[2*0+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_ptr[2*1] = <void*>_func_tukeylambdacdf
ufunc_tklmbda_ptr[2*1+1] = <void*>(<char*>"tklmbda")
ufunc_tklmbda_data[0] = &ufunc_tklmbda_ptr[2*0]
ufunc_tklmbda_data[1] = &ufunc_tklmbda_ptr[2*1]
tklmbda = np.PyUFunc_FromFuncAndData(ufunc_tklmbda_loops, ufunc_tklmbda_data, ufunc_tklmbda_types, 2, 2, 1, 0, "tklmbda", ufunc_tklmbda_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wofz_loops[2]
cdef void *ufunc_wofz_ptr[4]
cdef void *ufunc_wofz_data[2]
cdef char ufunc_wofz_types[4]
cdef char *ufunc_wofz_doc = (
    "wofz(z)\n"
    "\n"
    "Faddeeva function\n"
    "\n"
    "Returns the value of the Faddeeva function for complex argument::\n"
    "\n"
    "    exp(-z**2) * erfc(-i*z)\n"
    "\n"
    "See Also\n"
    "--------\n"
    "dawsn, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-3, 3)\n"
    ">>> plt.plot(x, special.wofz(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$wofz(x)$')\n"
    ">>> plt.show()")
ufunc_wofz_loops[0] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wofz_loops[1] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wofz_types[0] = <char>NPY_CFLOAT
ufunc_wofz_types[1] = <char>NPY_CFLOAT
ufunc_wofz_types[2] = <char>NPY_CDOUBLE
ufunc_wofz_types[3] = <char>NPY_CDOUBLE
ufunc_wofz_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*0+1] = <void*>(<char*>"wofz")
ufunc_wofz_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_w
ufunc_wofz_ptr[2*1+1] = <void*>(<char*>"wofz")
ufunc_wofz_data[0] = &ufunc_wofz_ptr[2*0]
ufunc_wofz_data[1] = &ufunc_wofz_ptr[2*1]
wofz = np.PyUFunc_FromFuncAndData(ufunc_wofz_loops, ufunc_wofz_data, ufunc_wofz_types, 2, 1, 1, 0, "wofz", ufunc_wofz_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_wrightomega_loops[2]
cdef void *ufunc_wrightomega_ptr[4]
cdef void *ufunc_wrightomega_data[2]
cdef char ufunc_wrightomega_types[4]
cdef char *ufunc_wrightomega_doc = (
    "wrightomega(z, out=None)\n"
    "\n"
    "Wright Omega function.\n"
    "\n"
    "Defined as the solution to\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega + \\log(\\omega) = z\n"
    "\n"
    "where :math:`\\log` is the principal branch of the complex logarithm.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "z : array_like\n"
    "    Points at which to evaluate the Wright Omega function\n"
    "\n"
    "Returns\n"
    "-------\n"
    "omega : ndarray\n"
    "    Values of the Wright Omega function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 0.19.0\n"
    "\n"
    "The function can also be defined as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\omega(z) = W_{K(z)}(e^z)\n"
    "\n"
    "where :math:`K(z) = \\lceil (\\Im(z) - \\pi)/(2\\pi) \\rceil` is the\n"
    "unwinding number and :math:`W` is the Lambert W function.\n"
    "\n"
    "The implementation here is taken from [1]_.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "lambertw : The Lambert W function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Lawrence, Corless, and Jeffrey, \"Algorithm 917: Complex\n"
    "       Double-Precision Evaluation of the Wright :math:`\\omega`\n"
    "       Function.\" ACM Transactions on Mathematical Software,\n"
    "       2012. :doi:`10.1145/2168773.2168779`.")
ufunc_wrightomega_loops[0] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_wrightomega_loops[1] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_wrightomega_types[0] = <char>NPY_CFLOAT
ufunc_wrightomega_types[1] = <char>NPY_CFLOAT
ufunc_wrightomega_types[2] = <char>NPY_CDOUBLE
ufunc_wrightomega_types[3] = <char>NPY_CDOUBLE
ufunc_wrightomega_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*0+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_wrightomega
ufunc_wrightomega_ptr[2*1+1] = <void*>(<char*>"wrightomega")
ufunc_wrightomega_data[0] = &ufunc_wrightomega_ptr[2*0]
ufunc_wrightomega_data[1] = &ufunc_wrightomega_ptr[2*1]
wrightomega = np.PyUFunc_FromFuncAndData(ufunc_wrightomega_loops, ufunc_wrightomega_data, ufunc_wrightomega_types, 2, 1, 1, 0, "wrightomega", ufunc_wrightomega_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlog1py_loops[4]
cdef void *ufunc_xlog1py_ptr[8]
cdef void *ufunc_xlog1py_data[4]
cdef char ufunc_xlog1py_types[12]
cdef char *ufunc_xlog1py_doc = (
    "xlog1py(x, y)\n"
    "\n"
    "Compute ``x*log1p(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : array_like\n"
    "    Computed x*log1p(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.13.0")
ufunc_xlog1py_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlog1py_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlog1py_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlog1py_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlog1py_types[0] = <char>NPY_FLOAT
ufunc_xlog1py_types[1] = <char>NPY_FLOAT
ufunc_xlog1py_types[2] = <char>NPY_FLOAT
ufunc_xlog1py_types[3] = <char>NPY_DOUBLE
ufunc_xlog1py_types[4] = <char>NPY_DOUBLE
ufunc_xlog1py_types[5] = <char>NPY_DOUBLE
ufunc_xlog1py_types[6] = <char>NPY_CFLOAT
ufunc_xlog1py_types[7] = <char>NPY_CFLOAT
ufunc_xlog1py_types[8] = <char>NPY_CFLOAT
ufunc_xlog1py_types[9] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[10] = <char>NPY_CDOUBLE
ufunc_xlog1py_types[11] = <char>NPY_CDOUBLE
ufunc_xlog1py_ptr[2*0] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*0+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*1] = <void*>_func_xlog1py[double]
ufunc_xlog1py_ptr[2*1+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*2] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*2+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_ptr[2*3] = <void*>_func_xlog1py[double_complex]
ufunc_xlog1py_ptr[2*3+1] = <void*>(<char*>"xlog1py")
ufunc_xlog1py_data[0] = &ufunc_xlog1py_ptr[2*0]
ufunc_xlog1py_data[1] = &ufunc_xlog1py_ptr[2*1]
ufunc_xlog1py_data[2] = &ufunc_xlog1py_ptr[2*2]
ufunc_xlog1py_data[3] = &ufunc_xlog1py_ptr[2*3]
xlog1py = np.PyUFunc_FromFuncAndData(ufunc_xlog1py_loops, ufunc_xlog1py_data, ufunc_xlog1py_types, 4, 2, 1, 0, "xlog1py", ufunc_xlog1py_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_xlogy_loops[4]
cdef void *ufunc_xlogy_ptr[8]
cdef void *ufunc_xlogy_data[4]
cdef char ufunc_xlogy_types[12]
cdef char *ufunc_xlogy_doc = (
    "xlogy(x, y)\n"
    "\n"
    "Compute ``x*log(y)`` so that the result is 0 if ``x = 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Multiplier\n"
    "y : array_like\n"
    "    Argument\n"
    "\n"
    "Returns\n"
    "-------\n"
    "z : array_like\n"
    "    Computed x*log(y)\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.13.0")
ufunc_xlogy_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_xlogy_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_xlogy_loops[2] = <np.PyUFuncGenericFunction>loop_D_DD__As_FF_F
ufunc_xlogy_loops[3] = <np.PyUFuncGenericFunction>loop_D_DD__As_DD_D
ufunc_xlogy_types[0] = <char>NPY_FLOAT
ufunc_xlogy_types[1] = <char>NPY_FLOAT
ufunc_xlogy_types[2] = <char>NPY_FLOAT
ufunc_xlogy_types[3] = <char>NPY_DOUBLE
ufunc_xlogy_types[4] = <char>NPY_DOUBLE
ufunc_xlogy_types[5] = <char>NPY_DOUBLE
ufunc_xlogy_types[6] = <char>NPY_CFLOAT
ufunc_xlogy_types[7] = <char>NPY_CFLOAT
ufunc_xlogy_types[8] = <char>NPY_CFLOAT
ufunc_xlogy_types[9] = <char>NPY_CDOUBLE
ufunc_xlogy_types[10] = <char>NPY_CDOUBLE
ufunc_xlogy_types[11] = <char>NPY_CDOUBLE
ufunc_xlogy_ptr[2*0] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*0+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*1] = <void*>_func_xlogy[double]
ufunc_xlogy_ptr[2*1+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*2] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*2+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_ptr[2*3] = <void*>_func_xlogy[double_complex]
ufunc_xlogy_ptr[2*3+1] = <void*>(<char*>"xlogy")
ufunc_xlogy_data[0] = &ufunc_xlogy_ptr[2*0]
ufunc_xlogy_data[1] = &ufunc_xlogy_ptr[2*1]
ufunc_xlogy_data[2] = &ufunc_xlogy_ptr[2*2]
ufunc_xlogy_data[3] = &ufunc_xlogy_ptr[2*3]
xlogy = np.PyUFunc_FromFuncAndData(ufunc_xlogy_loops, ufunc_xlogy_data, ufunc_xlogy_types, 4, 2, 1, 0, "xlogy", ufunc_xlogy_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_y0_loops[2]
cdef void *ufunc_y0_ptr[4]
cdef void *ufunc_y0_data[2]
cdef char ufunc_y0_types[4]
cdef char *ufunc_y0_doc = (
    "y0(x)\n"
    "\n"
    "Bessel function of the second kind of order 0.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : ndarray\n"
    "    Value of the Bessel function of the second kind of order 0 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    "The domain is divided into the intervals [0, 5] and (5, infinity). In the\n"
    "first interval a rational approximation :math:`R(x)` is employed to\n"
    "compute,\n"
    "\n"
    ".. math::\n"
    "\n"
    "    Y_0(x) = R(x) + \\frac{2 \\log(x) J_0(x)}{\\pi},\n"
    "\n"
    "where :math:`J_0` is the Bessel function of the first kind of order 0.\n"
    "\n"
    "In the second interval, the Hankel asymptotic expansion is employed with\n"
    "two rational functions of degree 6/6 and 7/7.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `y0`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "j0\n"
    "yv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_y0_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_y0_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_y0_types[0] = <char>NPY_FLOAT
ufunc_y0_types[1] = <char>NPY_FLOAT
ufunc_y0_types[2] = <char>NPY_DOUBLE
ufunc_y0_types[3] = <char>NPY_DOUBLE
ufunc_y0_ptr[2*0] = <void*>_func_y0
ufunc_y0_ptr[2*0+1] = <void*>(<char*>"y0")
ufunc_y0_ptr[2*1] = <void*>_func_y0
ufunc_y0_ptr[2*1+1] = <void*>(<char*>"y0")
ufunc_y0_data[0] = &ufunc_y0_ptr[2*0]
ufunc_y0_data[1] = &ufunc_y0_ptr[2*1]
y0 = np.PyUFunc_FromFuncAndData(ufunc_y0_loops, ufunc_y0_data, ufunc_y0_types, 2, 1, 1, 0, "y0", ufunc_y0_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_y1_loops[2]
cdef void *ufunc_y1_ptr[4]
cdef void *ufunc_y1_data[2]
cdef char ufunc_y1_types[4]
cdef char *ufunc_y1_doc = (
    "y1(x)\n"
    "\n"
    "Bessel function of the second kind of order 1.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : ndarray\n"
    "    Value of the Bessel function of the second kind of order 1 at `x`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    "The domain is divided into the intervals [0, 8] and (8, infinity). In the\n"
    "first interval a 25 term Chebyshev expansion is used, and computing\n"
    ":math:`J_1` (the Bessel function of the first kind) is required. In the\n"
    "second, the asymptotic trigonometric representation is employed using two\n"
    "rational functions of degree 5/5.\n"
    "\n"
    "This function is a wrapper for the Cephes [1]_ routine `y1`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "j1\n"
    "yn\n"
    "yv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_y1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_y1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_y1_types[0] = <char>NPY_FLOAT
ufunc_y1_types[1] = <char>NPY_FLOAT
ufunc_y1_types[2] = <char>NPY_DOUBLE
ufunc_y1_types[3] = <char>NPY_DOUBLE
ufunc_y1_ptr[2*0] = <void*>_func_y1
ufunc_y1_ptr[2*0+1] = <void*>(<char*>"y1")
ufunc_y1_ptr[2*1] = <void*>_func_y1
ufunc_y1_ptr[2*1+1] = <void*>(<char*>"y1")
ufunc_y1_data[0] = &ufunc_y1_ptr[2*0]
ufunc_y1_data[1] = &ufunc_y1_ptr[2*1]
y1 = np.PyUFunc_FromFuncAndData(ufunc_y1_loops, ufunc_y1_data, ufunc_y1_types, 2, 1, 1, 0, "y1", ufunc_y1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yn_loops[3]
cdef void *ufunc_yn_ptr[6]
cdef void *ufunc_yn_data[3]
cdef char ufunc_yn_types[9]
cdef char *ufunc_yn_doc = (
    "yn(n, x)\n"
    "\n"
    "Bessel function of the second kind of integer order and real argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "n : array_like\n"
    "    Order (integer).\n"
    "z : array_like\n"
    "    Argument (float).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : ndarray\n"
    "    Value of the Bessel function, :math:`Y_n(x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the Cephes [1]_ routine `yn`.\n"
    "\n"
    "The function is evaluated by forward recurrence on `n`, starting with\n"
    "values computed by the Cephes routines `y0` and `y1`. If `n = 0` or 1,\n"
    "the routine for `y0` or `y1` is called directly.\n"
    "\n"
    "See also\n"
    "--------\n"
    "yv : For real order and real or complex argument.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/index.html")
ufunc_yn_loops[0] = <np.PyUFuncGenericFunction>loop_d_id__As_ld_d
ufunc_yn_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yn_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yn_types[0] = <char>NPY_LONG
ufunc_yn_types[1] = <char>NPY_DOUBLE
ufunc_yn_types[2] = <char>NPY_DOUBLE
ufunc_yn_types[3] = <char>NPY_FLOAT
ufunc_yn_types[4] = <char>NPY_FLOAT
ufunc_yn_types[5] = <char>NPY_FLOAT
ufunc_yn_types[6] = <char>NPY_DOUBLE
ufunc_yn_types[7] = <char>NPY_DOUBLE
ufunc_yn_types[8] = <char>NPY_DOUBLE
ufunc_yn_ptr[2*0] = <void*>_func_yn
ufunc_yn_ptr[2*0+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*1] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*1+1] = <void*>(<char*>"yn")
ufunc_yn_ptr[2*2] = <void*>_func_yn_unsafe
ufunc_yn_ptr[2*2+1] = <void*>(<char*>"yn")
ufunc_yn_data[0] = &ufunc_yn_ptr[2*0]
ufunc_yn_data[1] = &ufunc_yn_ptr[2*1]
ufunc_yn_data[2] = &ufunc_yn_ptr[2*2]
yn = np.PyUFunc_FromFuncAndData(ufunc_yn_loops, ufunc_yn_data, ufunc_yn_types, 3, 2, 1, 0, "yn", ufunc_yn_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yv_loops[4]
cdef void *ufunc_yv_ptr[8]
cdef void *ufunc_yv_data[4]
cdef char ufunc_yv_types[12]
cdef char *ufunc_yv_doc = (
    "yv(v, z)\n"
    "\n"
    "Bessel function of the second kind of real order and complex argument.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : ndarray\n"
    "    Value of the Bessel function of the second kind, :math:`Y_v(x)`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the\n"
    "AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n"
    "Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n"
    "\n"
    ".. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n"
    "computed using the AMOS routine `zbesj`.  Note that the second term is\n"
    "exactly zero for integer `v`; to improve accuracy the second term is\n"
    "explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "See also\n"
    "--------\n"
    "yve : :math:`Y_v` with leading exponential behavior stripped off.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_yv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yv_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_yv_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yv_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_yv_types[0] = <char>NPY_FLOAT
ufunc_yv_types[1] = <char>NPY_FLOAT
ufunc_yv_types[2] = <char>NPY_FLOAT
ufunc_yv_types[3] = <char>NPY_FLOAT
ufunc_yv_types[4] = <char>NPY_CFLOAT
ufunc_yv_types[5] = <char>NPY_CFLOAT
ufunc_yv_types[6] = <char>NPY_DOUBLE
ufunc_yv_types[7] = <char>NPY_DOUBLE
ufunc_yv_types[8] = <char>NPY_DOUBLE
ufunc_yv_types[9] = <char>NPY_DOUBLE
ufunc_yv_types[10] = <char>NPY_CDOUBLE
ufunc_yv_types[11] = <char>NPY_CDOUBLE
ufunc_yv_ptr[2*0] = <void*>_func_cbesy_wrap_real
ufunc_yv_ptr[2*0+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*1] = <void*>_func_cbesy_wrap
ufunc_yv_ptr[2*1+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*2] = <void*>_func_cbesy_wrap_real
ufunc_yv_ptr[2*2+1] = <void*>(<char*>"yv")
ufunc_yv_ptr[2*3] = <void*>_func_cbesy_wrap
ufunc_yv_ptr[2*3+1] = <void*>(<char*>"yv")
ufunc_yv_data[0] = &ufunc_yv_ptr[2*0]
ufunc_yv_data[1] = &ufunc_yv_ptr[2*1]
ufunc_yv_data[2] = &ufunc_yv_ptr[2*2]
ufunc_yv_data[3] = &ufunc_yv_ptr[2*3]
yv = np.PyUFunc_FromFuncAndData(ufunc_yv_loops, ufunc_yv_data, ufunc_yv_types, 4, 2, 1, 0, "yv", ufunc_yv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_yve_loops[4]
cdef void *ufunc_yve_ptr[8]
cdef void *ufunc_yve_data[4]
cdef char ufunc_yve_types[12]
cdef char *ufunc_yve_doc = (
    "yve(v, z)\n"
    "\n"
    "Exponentially scaled Bessel function of the second kind of real order.\n"
    "\n"
    "Returns the exponentially scaled Bessel function of the second\n"
    "kind of real order `v` at complex `z`::\n"
    "\n"
    "    yve(v, z) = yv(v, z) * exp(-abs(z.imag))\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Order (float).\n"
    "z : array_like\n"
    "    Argument (float or complex).\n"
    "\n"
    "Returns\n"
    "-------\n"
    "Y : ndarray\n"
    "    Value of the exponentially scaled Bessel function.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "For positive `v` values, the computation is carried out using the\n"
    "AMOS [1]_ `zbesy` routine, which exploits the connection to the Hankel\n"
    "Bessel functions :math:`H_v^{(1)}` and :math:`H_v^{(2)}`,\n"
    "\n"
    ".. math:: Y_v(z) = \\frac{1}{2\\imath} (H_v^{(1)} - H_v^{(2)}).\n"
    "\n"
    "For negative `v` values the formula,\n"
    "\n"
    ".. math:: Y_{-v}(z) = Y_v(z) \\cos(\\pi v) + J_v(z) \\sin(\\pi v)\n"
    "\n"
    "is used, where :math:`J_v(z)` is the Bessel function of the first kind,\n"
    "computed using the AMOS routine `zbesj`.  Note that the second term is\n"
    "exactly zero for integer `v`; to improve accuracy the second term is\n"
    "explicitly omitted for `v` values such that `v = floor(v)`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Donald E. Amos, \"AMOS, A Portable Package for Bessel Functions\n"
    "       of a Complex Argument and Nonnegative Order\",\n"
    "       http://netlib.org/amos/")
ufunc_yve_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_yve_loops[1] = <np.PyUFuncGenericFunction>loop_D_dD__As_fF_F
ufunc_yve_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_yve_loops[3] = <np.PyUFuncGenericFunction>loop_D_dD__As_dD_D
ufunc_yve_types[0] = <char>NPY_FLOAT
ufunc_yve_types[1] = <char>NPY_FLOAT
ufunc_yve_types[2] = <char>NPY_FLOAT
ufunc_yve_types[3] = <char>NPY_FLOAT
ufunc_yve_types[4] = <char>NPY_CFLOAT
ufunc_yve_types[5] = <char>NPY_CFLOAT
ufunc_yve_types[6] = <char>NPY_DOUBLE
ufunc_yve_types[7] = <char>NPY_DOUBLE
ufunc_yve_types[8] = <char>NPY_DOUBLE
ufunc_yve_types[9] = <char>NPY_DOUBLE
ufunc_yve_types[10] = <char>NPY_CDOUBLE
ufunc_yve_types[11] = <char>NPY_CDOUBLE
ufunc_yve_ptr[2*0] = <void*>_func_cbesy_wrap_e_real
ufunc_yve_ptr[2*0+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*1] = <void*>_func_cbesy_wrap_e
ufunc_yve_ptr[2*1+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*2] = <void*>_func_cbesy_wrap_e_real
ufunc_yve_ptr[2*2+1] = <void*>(<char*>"yve")
ufunc_yve_ptr[2*3] = <void*>_func_cbesy_wrap_e
ufunc_yve_ptr[2*3+1] = <void*>(<char*>"yve")
ufunc_yve_data[0] = &ufunc_yve_ptr[2*0]
ufunc_yve_data[1] = &ufunc_yve_ptr[2*1]
ufunc_yve_data[2] = &ufunc_yve_ptr[2*2]
ufunc_yve_data[3] = &ufunc_yve_ptr[2*3]
yve = np.PyUFunc_FromFuncAndData(ufunc_yve_loops, ufunc_yve_data, ufunc_yve_types, 4, 2, 1, 0, "yve", ufunc_yve_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_zetac_loops[2]
cdef void *ufunc_zetac_ptr[4]
cdef void *ufunc_zetac_data[2]
cdef char ufunc_zetac_types[4]
cdef char *ufunc_zetac_doc = (
    "zetac(x)\n"
    "\n"
    "Riemann zeta function minus 1.\n"
    "\n"
    "This function is defined as\n"
    "\n"
    ".. math:: \\zeta(x) = \\sum_{k=2}^{\\infty} 1 / k^x,\n"
    "\n"
    "where ``x > 1``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "zeta")
ufunc_zetac_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_zetac_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_zetac_types[0] = <char>NPY_FLOAT
ufunc_zetac_types[1] = <char>NPY_FLOAT
ufunc_zetac_types[2] = <char>NPY_DOUBLE
ufunc_zetac_types[3] = <char>NPY_DOUBLE
ufunc_zetac_ptr[2*0] = <void*>_func_zetac
ufunc_zetac_ptr[2*0+1] = <void*>(<char*>"zetac")
ufunc_zetac_ptr[2*1] = <void*>_func_zetac
ufunc_zetac_ptr[2*1+1] = <void*>(<char*>"zetac")
ufunc_zetac_data[0] = &ufunc_zetac_ptr[2*0]
ufunc_zetac_data[1] = &ufunc_zetac_ptr[2*1]
zetac = np.PyUFunc_FromFuncAndData(ufunc_zetac_loops, ufunc_zetac_data, ufunc_zetac_types, 2, 1, 1, 0, "zetac", ufunc_zetac_doc, 0)

#
# Aliases
#
jn = jv
