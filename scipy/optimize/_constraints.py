from __future__ import division, print_function, absolute_import
import numpy as np
import scipy.sparse as spc


__all__ = ['NonlinearConstraint',
           'LinearConstraint',
           'BoxConstraint']


class NonlinearConstraint:
    """Nonlinear constraint

    Parameters
    ----------
    fun : callable
        The function defining the constraint.

            fun(x) -> array_like, shape (m,)

        where x is a (n,) ndarray and ``m``
        is the number of constraints.
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= fun(x) <= ub
            - ("greater", lb): for a constraint of the type:
                fun(x) >= lb
            - ("less", ub): for a constraint of the type:
                fun(x) <= ub
            - ("equals", c): for a constraint of the type:
                fun(x) == c

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    jac : callable
        Jacobian Matrix:

            jac(x) -> {ndarray, sparse matrix}, shape (m, n)

        where x is a (n,) ndarray.
    hess : {callable, None}
        Hessian matrix of `dot(fun, v)`:

            hess(x, v) -> {LinearOperator, sparse matrix, ndarray}, shape (n, n)

        where x is a (n,) ndarray and v is a (m,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, fun, kind, jac, hess, enforce_feasibility=False):
        self.fun = fun
        self.kind, self.size = check_kind(kind)
        self.jac = jac
        self.hess = hess
        self.enforce_feasibility = check_enforce_feasibility(self.size,
                                                             enforce_feasibility)


class LinearConstraint:
    """Linear constraint.

    Parameters
    ----------
    A : {ndarray, sparse matrix}, shape (m, n)
        Matrix for the linear constraint.
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= A x <= ub
            - ("greater", lb): for a constraint of the type:
                A x >= lb
            - ("less", ub): for a constraint of the type:
                A x <= ub
            - ("equals", c): for a constraint of the type:
                A x == c

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, A, kind, enforce_feasibility=False):
        self.A = A
        self.kind, self.size = check_kind(kind)
        self.enforce_feasibility = check_enforce_feasibility(self.size,
                                                             enforce_feasibility)

    def to_nonlinear(self, sparse_jacobian=None):
        def fun(x):
            return self.A.dot(x)

        def jac(x):
            return check_sparsity(self.A, sparse_jacobian)

        return NonlinearConstraint(fun, self.kind,  jac, None,
                                   self.enforce_feasibility)


class BoxConstraint:
    """Box constraint.

    Parameters
    ----------
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= x <= ub
            - ("greater", lb): for a constraint of the type:
                x >= lb
            - ("less", ub): for a constraint of the type:
                x <= ub

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, kind, enforce_feasibility=False):
        self.kind, self.size = check_kind(kind)
        self.enforce_feasibility = check_enforce_feasibility(self.size,
                                                             enforce_feasibility)

    def to_linear(self, sparse_jacobian=None):
        # Set default value
        if sparse_jacobian is None:
            sparse_jacobian = True
        # Define matrix A
        fun_len = len(self.kind[1])
        if sparse_jacobian:
            A = spc.eye(fun_len).tocsc()
        else:
            A = np.eye(fun_len)
        # Return Constraint
        return LinearConstraint(A, self.kind, self.enforce_feasibility)

    def to_nonlinear(self, sparse_jacobian=None):
        return self.to_linear(sparse_jacobian).to_nonlinear()

    def reinforce_constraint(self, x,
                             relative_tolerance=0.01,
                             absolute_tolerance=0.01):
        """Reinforce box constraint"""
        x = np.copy(np.asarray(x, dtype=float))
        kind = self.kind
        enforce_feasibility = self.enforce_feasibility
        if kind[0] == "greater":
            lb = np.asarray(kind[1], dtype=float)
            ub = np.full_like(lb, np.inf, dtype=float)
        elif kind[0] == "less":
            ub = np.asarray(kind[1], dtype=float)
            lb = np.full_like(ub, -np.inf, dtype=float)
        elif kind[0] == "interval":
            lb = np.asarray(kind[1], dtype=float)
            ub = np.asarray(kind[2], dtype=float)
        lower_bound = np.minimum(lb[enforce_feasibility] + absolute_tolerance,
                                 lb[enforce_feasibility] +
                                 relative_tolerance *
                                 (ub[enforce_feasibility]-lb[enforce_feasibility]))
        upper_bound = np.maximum(ub[enforce_feasibility] - absolute_tolerance,
                                 ub[enforce_feasibility] -
                                 relative_tolerance *
                                 (ub[enforce_feasibility]-lb[enforce_feasibility]))
        x[enforce_feasibility] = np.maximum(x[enforce_feasibility], lower_bound)
        x[enforce_feasibility] = np.minimum(x[enforce_feasibility], upper_bound)
        return x


def check_sparsity(A, sparse):
    """Return a spmatrix if `sparse` is True and a dense numpy array otherwise.
    """
    if (sparse is None) or \
       (sparse and spc.issparse(A)) or \
       (not sparse and not spc.issparse(A)):
        return A
    elif sparse:
        return spc.csc_matrix(A)
    else:
        return A.toarray()


def check_kind(kind):
    if not isinstance(kind, (tuple, list)):
        raise ValueError("The parameter 'kind' should be a tuple or a list.")
    if len(kind) == 0:
        raise ValueError("The parameter 'kind' should not be empty.")
    keyword = kind[0]
    if keyword not in ("greater", "less", "equals", "interval"):
        raise ValueError("Keyword '%s' not available." % keyword)
    if len(kind) == 2 and keyword not in ("greater", "less", "equals") \
       or len(kind) == 3 and keyword not in ("interval"):
        raise ValueError("Invalid 'kind' format.")
    if keyword == "interval":
        lb = np.asarray(kind[1])
        ub = np.asarray(kind[2])
        size = np.size(lb)
        if len(lb) != len(ub):
            raise ValueError("Mismatching 'ub' and 'lb' dimensions.")
        if (lb > ub).any():
            raise ValueError("lb[i] > ub[i]")
        return (keyword, lb, ub), size
    else:
        c = np.array(kind[1])
        size = np.size(c)
        return (keyword, c), size


def check_enforce_feasibility(size, enforce_feasibility):
    if isinstance(enforce_feasibility, bool):
        enforce_feasibility = np.full(size,
                                      enforce_feasibility,
                                      dtype=bool)
    else:
        enforce_feasibility = np.array(enforce_feasibility,
                                       dtype=bool)

        if enforce_feasibility.size != size:
            raise ValueError("'enforce_feasibility' has the wrong "
                             "number of elements.")
    return enforce_feasibility
