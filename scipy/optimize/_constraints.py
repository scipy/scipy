from __future__ import division, print_function, absolute_import
import numpy as np
import scipy.sparse as spc


__all__ = ['NonlinearConstraint',
           'LinearConstraint',
           'BoxConstraint',
           'check_sparsity']


class NonlinearConstraint:
    """Nonlinear constraint

    Parameters
    ----------
    fun : callable
        The function defining the constraint.

            fun(x) -> array_like, shape (m,)

        where x is a (n,) ndarray and ``m``
        is the number of constraints.
    jac : callable
        Jacobian Matrix:

            jac(x) -> {ndarray, sparse matrix}, shape (m, n)

        where x is a (n,) ndarray.
    hess : {callable, None}
        Hessian matrix of `dot(fun, v)`:

            hess(x, v) -> {LinearOperator, sparse matrix, ndarray}, shape (n, n)

        where x is a (n,) ndarray and v is a (m,) ndarray.
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= fun(x) <= ub
            - ("greater", lb): for a constraint of the type:
                fun(x) >= lb
            - ("less", ub): for a constraint of the type:
                fun(x) <= ub
            - ("equals", c): for a constraint of the type:
                fun(x) == c

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, fun, jac, hess, kind, enforce_feasibility=False):
        self.fun = fun
        self.jac = jac
        self.hess = hess
        self.kind = kind
        fun_len = len(self.kind[1])
        if isinstance(enforce_feasibility, bool):
            self.enforce_feasibility = np.full(fun_len,
                                               enforce_feasibility,
                                               dtype=bool)
        else:
            self.enforce_feasibility = np.array(enforce_feasibility,
                                                dtype=bool)


class LinearConstraint:
    """Linear constraint.

    Parameters
    ----------
    A : {ndarray, sparse matrix}, shape (m, n)
        Matrix for the linear constraint.
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= A x <= ub
            - ("greater", lb): for a constraint of the type:
                A x >= lb
            - ("less", ub): for a constraint of the type:
                A x <= ub
            - ("equals", c): for a constraint of the type:
                A x == c

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, A, kind, enforce_feasibility=False):
        self.A = A
        self.kind = kind
        fun_len = len(self.kind[1])
        if isinstance(enforce_feasibility, bool):
            self.enforce_feasibility = np.full(fun_len,
                                               enforce_feasibility,
                                               dtype=bool)
        else:
            self.enforce_feasibility = np.array(enforce_feasibility,
                                                dtype=bool)

    def to_nonlinear(self, sparse_jacobian=None):
        def fun(x):
            return self.A.dot(x)

        def jac(x):
            return check_sparsity(self.A, sparse_jacobian)

        return NonlinearConstraint(fun, jac, None, self.kind,
                                   self.enforce_feasibility)


class BoxConstraint:
    """Box constraint.

    Parameters
    ----------
    kind : tuple
        Specifies the type of contraint. Options for this
        parameter are:

            - ("interval", lb, ub): for a constraint of the type:
                lb <= x <= ub
            - ("greater", lb): for a constraint of the type:
                x >= lb
            - ("less", ub): for a constraint of the type:
                x <= ub

        where ``lb``,  ``ub`` and ``c`` are (m,) ndarrays and
        ``x`` is a (n,) ndarray.
    enforce_feasibility : {list of boolean, boolean}, optional
        Specify if the constraint must be feasible along the iterations.
        If ``True``  all the iterates generated by the optimization
        algorithm need to be feasible in respect to a constraint. If ``False``
        this is not needed. A list can be passed to specify element-wise
        each constraints needs to stay feasible along the iterations and
        each does not. Alternatively, a single boolean can be used to
        specify the feasibility required of all constraints. By default it
        is False.
    """
    def __init__(self, kind, enforce_feasibility=False):
        self.kind = kind
        fun_len = len(self.kind[1])
        if isinstance(enforce_feasibility, bool):
            self.enforce_feasibility = np.full(fun_len,
                                               enforce_feasibility,
                                               dtype=bool)
        else:
            self.enforce_feasibility = np.array(enforce_feasibility,
                                                dtype=bool)

    def to_linear(self, sparse_jacobian=None):
        # Set default value
        if sparse_jacobian is None:
            sparse_jacobian = True
        # Define matrix A
        fun_len = len(self.kind[1])
        if sparse_jacobian:
            A = spc.eye(fun_len).tocsc()
        else:
            A = np.eye(fun_len)
        # Return Constraint
        return LinearConstraint(A, self.kind, self.enforce_feasibility)

    def to_nonlinear(self, sparse_jacobian=None):
        return self.to_linear(sparse_jacobian).to_nonlinear()

    def reinforce_constraint(self, x,
                             relative_tolerance=0.01,
                             absolute_tolerance=0.01):
        """Reinforce box constraint"""
        x = np.copy(np.asarray(x, dtype=float))
        kind = self.kind
        enforce_feasibility = self.enforce_feasibility
        if kind[0] == "greater":
            lb = np.asarray(kind[1], dtype=float)
            ub = np.full_like(lb, np.inf, dtype=float)
        elif kind[0] == "less":
            ub = np.asarray(kind[1], dtype=float)
            lb = np.full_like(ub, -np.inf, dtype=float)
        elif kind[0] == "interval":
            lb = np.asarray(kind[1], dtype=float)
            ub = np.asarray(kind[2], dtype=float)
        lower_bound = np.minimum(lb[enforce_feasibility] + absolute_tolerance,
                                 lb[enforce_feasibility] +
                                 relative_tolerance *
                                 (ub[enforce_feasibility]-lb[enforce_feasibility]))
        upper_bound = np.maximum(ub[enforce_feasibility] - absolute_tolerance,
                                 ub[enforce_feasibility] -
                                 relative_tolerance *
                                 (ub[enforce_feasibility]-lb[enforce_feasibility]))
        x[enforce_feasibility] = np.maximum(x[enforce_feasibility], lower_bound)
        x[enforce_feasibility] = np.minimum(x[enforce_feasibility], upper_bound)
        return x


def check_sparsity(A, sparse):
    """Return a spmatrix if `sparse` is True and a dense numpy array otherwise.
    """
    if (sparse is None) or \
       (sparse and spc.issparse(A)) or \
       (not sparse and not spc.issparse(A)):
        return A
    elif sparse:
        return spc.csc_matrix(A)
    else:
        return A.toarray()
