!%f90 -*- f90 -*-
! Author: Pearu Peterson, August 2002

python module _fftw
    interface

       subroutine zfft_fftw(x,n,direction,howmany,normalize)
         ! y = fft(x[,n,direction,normalize,overwrite_x])
         intent(c) zfft_fftw
         complex*16 intent(c,in,out,copy,out=y) :: x(*)
         integer optional,depend(x),intent(c,in) :: n=size(x)
         check(n>0) n
         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
         check(n*howmany==size(x)) howmany
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) &
              :: normalize = (direction<0)
       end subroutine zfft_fftw

       subroutine drfft_fftw(x,n,direction,howmany,normalize)
         ! y = drfft(x[,n,direction,normalize,overwrite_x])
         intent(c) drfft_fftw
         real*8 intent(c,in,out,copy,out=y) :: x(*)
         integer optional,depend(x),intent(c,in) :: n=size(x)
         check(n>0&&n<=size(x)) n
         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
         check(n*howmany==size(x)) howmany
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) &
              :: normalize = (direction<0)
       end subroutine drfft_fftw

!       subroutine zrfft_fftw(x,n,direction,howmany,normalize)
!         ! y = zrfft(x[,n,direction,normalize,overwrite_x])
!         intent(c) zrfft_fftw
!         complex*16 intent(c,in,out,overwrite,out=y) :: x(*)
!         integer optional,depend(x),intent(c,in) :: n=size(x)
!         check(n>0&&n<=size(x)) n
!         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
!         check(n*howmany==size(x)) howmany
!         integer optional,intent(c,in) :: direction = 1
!         integer optional,intent(c,in),depend(direction) &
!              :: normalize = (direction<0)
!       end subroutine zrfft_fftw

       subroutine zfftnd_fftw(x,r,s,direction,howmany,normalize,j)
         ! y = zfftnd(x[,s,direction,normalize,overwrite_x])
         intent(c) zfftnd_fftw
         complex*16 intent(c,in,out,copy,out=y) :: x(*)
         integer intent(c,hide),depend(x) :: r=old_rank(x)
         integer intent(c,hide) :: j=0
         integer optional,depend(r),dimension(r),intent(c,in) &
              :: s=old_shape(x,j++)
         check(r>=len(s)) s
         integer intent(c,hide) :: howmany = 1
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) :: &
              normalize = (direction<0)
         callprotoargument complex_double*,int,int*,int,int,int
         callstatement {&
              int i,sz=1,xsz=size(x); &
              for (i=0;i<r;++i) sz *= s[i]; &
              howmany = xsz/sz; &
              if (sz*howmany==xsz) &
                (*f2py_func)(x,r,s,direction,howmany,normalize); &
              else {&
                f2py_success = 0; &
                PyErr_SetString(_fftw_error, &
                  "inconsistency in x.shape and s argument"); &
                } &
              }
       end subroutine zfftnd_fftw

    end interface 
end python module _fftw

! See http://cens.ioc.ee/projects/f2py2e/
