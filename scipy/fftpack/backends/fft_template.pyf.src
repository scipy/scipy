!%f90 -*- f90 -*-
! Author: Pearu Peterson, August 2002
! This file is included by the files <backend>/<backend>.pyf.src
! **********************************************************************
! NOTE: IF YOU UPDATE THIS FILE, YOU SHOULD UPDATE IT FOR FFTPACK TOO !
! **********************************************************************

       subroutine zfft<modulename>(x,n,direction,howmany,normalize)
         ! y = fft(x[,n,direction,normalize,overwrite_x])
         intent(c) zfft<modulename>
         complex*16 intent(c,in,out,copy,out=y) :: x(*)
         integer optional,depend(x),intent(c,in) :: n=size(x)
         check(n>0) n
         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
         check(n*howmany==size(x)) howmany
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) &
              :: normalize = (direction<0)
       end subroutine zfft<modulename>

       subroutine drfft<modulename>(x,n,direction,howmany,normalize)
         ! y = drfft(x[,n,direction,normalize,overwrite_x])
         intent(c) drfft<modulename>
         real*8 intent(c,in,out,copy,out=y) :: x(*)
         integer optional,depend(x),intent(c,in) :: n=size(x)
         check(n>0&&n<=size(x)) n
         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
         check(n*howmany==size(x)) howmany
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) &
              :: normalize = (direction<0)
       end subroutine drfft<modulename>

       subroutine zrfft<modulename>(x,n,direction,howmany,normalize)
         ! y = zrfft(x[,n,direction,normalize,overwrite_x])
         intent(c) zrfft<modulename>
         complex*16 intent(c,in,out,overwrite,out=y) :: x(*)
         integer optional,depend(x),intent(c,in) :: n=size(x)
         check(n>0&&n<=size(x)) n
         integer depend(x,n),intent(c,hide) :: howmany = size(x)/n
         check(n*howmany==size(x)) howmany
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) &
              :: normalize = (direction<0)
       end subroutine zrfft<modulename>

       subroutine zfftnd<modulename>(x,r,s,direction,howmany,normalize,j)
         ! y = zfftnd(x[,s,direction,normalize,overwrite_x])
         intent(c) zfftnd<modulename>
         complex*16 intent(c,in,out,copy,out=y) :: x(*)
         integer intent(c,hide),depend(x) :: r=old_rank(x)
         integer intent(c,hide) :: j=0
         integer optional,depend(r),dimension(r),intent(c,in) &
              :: s=old_shape(x,j++)
         check(r>=len(s)) s
         integer intent(c,hide) :: howmany = 1
         integer optional,intent(c,in) :: direction = 1
         integer optional,intent(c,in),depend(direction) :: &
              normalize = (direction<0)
         callprotoargument complex_double*,int,int*,int,int,int
         callstatement {&
              int i,sz=1,xsz=size(x); &
              for (i=0;i<r;++i) sz *= s[i]; &
              howmany = xsz/sz; &
              if (sz*howmany==xsz) &
                (*f2py_func)(x,r,s,direction,howmany,normalize); &
              else {&
                f2py_success = 0; &
                PyErr_SetString(<modulename>_error, &
                  "inconsistency in x.shape and s argument"); &
                } &
              }
       end subroutine zfftnd<modulename>

! See http://cens.ioc.ee/projects/f2py2e/
