This is a list of the functions we need to replace sparsekit --- needed in all 4 precision formats (c, z, s, d)

coocsr  --  converts coordinate to csr format 
              (nrow, nnz, a, ir, jc, ao, jao, iao)
              nrow -- dimension of the matrix
              nnz  -- number of nonzero elements in matrix
              a,ir,jc -- matrix in coordinate format a(k), ir(k), jc(k) 
                        store then nnz nonzero elements of the matrix
      
              ao, jao, iao --- matrix in general sparse matrix format (CSR)
                               ao containing values, jao containing column indices
                               and iao being the pointer to the beginning of the row 
                               in arrays a0 and jao

getelm --  return a(i,j) for any (i,j) from a CSR-stored matrix
              (i,j, a,ja,ia, iadd, sorted)
              
              i,j  --   row and column of element sought
              a,ja,ia --- matrix in CSR format
              sorted --- logical indicating whether the matrix is known to 
                           have its column indices sorted in increasing order
              getelm -- value of a(i,j)
              iadd -- address of element a(i,j) in arrays (a,ja) if found
                      zero otherwise

submat --  extracts the submatrix A(i1:i2,j1:j2) and puts the result in matrix 
            ao, iao, jao
               (n, job, i1, i2, j1, j2, a, ja, ia, nr, nr, nc, ao, jao, iao)
               n -- row dimension of matrix
               i1,i2, j1, j2  --- slice select (i1 <= i2 and j1 <= j2)
               a,ja,ia -- matrix in CSR format
               job -- job indicator:  if job != 1 then the real values in a are 
                                      NOT extracted, only the column indices are.
                                      otherwise values as well as column indices are 
                                      extracted.
           
                nr - number of rows of submatrix
                nc - number of columns of submatrix
                ao, jao, iao -- extracted matrix in general sparse format with 
                                jao containing the column indices and iao being the
                                pointer to the beginning of the row in arrays a, ja.

aplb  --   computes C = A + B
            (nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr)
               nrow x ncol --- row dimension of A and B
               job         --- integer job indicator (when job =0 only the 
                                  structure (ie jc, ic) is computed and the
                                  values are ignored.

               a,ja,ia -- matrix A in CSR format
               b,jb,ib -- matrix B in CSR format
               nzmax -- the length of arrays c and jc.  amub will stop if result
                          matrix has more elements than nzmax.

              Return:
                
               c,jc,ic -- resulting matrix C = A + B
               ierr    -- integer serving as error message
                          0 -- normal return
                         >0  means aplb stopped while computing the ith 
                             row with i=ierr because number of elements in C > nzmax

amub  --  computes C = A * B
            (nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, iw, ierr)
               nrow x ncol --- row dimension of A and B
               job         --- integer job indicator (when job =0 only the 
                                  structure (ie jc, ic) is computed and the
                                  values are ignored.

               a,ja,ia -- matrix A in CSR format
               b,jb,ib -- matrix B in CSR format
               nzmax -- the length of arrays c and jc.  amub will stop if result
                          matrix has more elements than nzmax.

              Return:
                
               c,jc,ic -- resulting matrix C = A * B
               ierr    -- integer serving as error message
                          0 -- normal return
                         >0  means amub stopped while computing the ith 
                             row with i=ierr because number of elements in C > nzmax



amux  --   matrix by vector using the dot product form
              (n, x, y, a, ja, ia)
              n -- row dimension of A
              x -- array of length equal to the column dimension of A
              a, ja, ia -- input matrix in CSR format
         
              y -- array of length n,  containing the product y = Ax

transp --  in place transposition routine.  (could use csrcsc instead for not inplace)
              (nrow, ncol, a, ja, ia, iwk, ierr)
 
               nrow x ncol --- the row x column dimension of A
               a, ja, ia  --  CSR format matrix  (ia is nrow+1 elements)
               iwk  -- integer work array of same length as ja
               
               On return: 
               ncol -- actual row dimension of transpose of input matrix
               a,ja, ia --- transposed matrix in CSR format

               ierr -- integer error message.  If the number of rows for the
                       transposed matrix exceeds the input value of ncol
                       then ierr is set to that number and transp quits 
                       Otherwise ierr is set to 0.



diacsr --- construct CSR matrix from diagonals 
           (m,n,job, idiag, diag, ndiag, ioff, a, ja, ia)
             
              m,n -- sparse array will be mxn
              job -- if job==0 then check for each entry in diag 
                       whether this entry is zero.  If it is then do not
                       include it in the output matrix.  
 
              idiag -- integer equal to the number of diagonals
              diag  -- array of size (ndiag x idiag) containing the diagonals to
                         be placed in A
              ndiag -- integer equal to the first dimension of array diag
              ioff  -- integer array of length idiag containing the offsets of
                       the diagonals to be extracted.

           on return:
 
              a, ja, ia --- matrix stored in CSR format

